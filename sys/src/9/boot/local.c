#include <u.h>
#include <libc.h>
#include <../boot/boot.h>

static char diskname[2*NAMELEN];
static char *disk;
static char **args;

void
configlocal(Method *mp)
{
	char *p;
	int n;

	if(*sys == '/' || *sys == '#'){
		/*
		 *  if the user specifies the disk in the boot cmd or
		 * 'root is from' prompt, use it
		 */
		disk = sys;
	} else if(strncmp(argv0, "dksc(0,", 7) == 0){
		/*
		 *  on many mips arg0 of the boot command specifies the
		 *  scsi logical unit number
		 */
		p = strchr(argv0, ',');
		n = strtoul(p+1, 0, 10);
		sprint(diskname, "#w%d/sd%dfs", n, n);
		disk = diskname;
	} else if(mp->arg){
		/*
		 *  a default is supplied when the kernel is made
		 */
		disk = mp->arg;
	} else if(*bootdisk){
		/*
		 *  an environment variable from a pc's plan9.ini or
		 *  from the mips nvram or generated by the kernel
		 *  is the last resort.
		 */
		disk = bootdisk;
	}

	/* if we've decided on one, pass it on to all programs */
	if(disk)
		setenv("bootdisk", disk);

	USED(mp);
}

int
authlocal(void)
{
	return -1;
}

int
connectlocal(void)
{
	int i, p[2];
	Dir dir;
	char d[DIRLEN];
	char partition[2*NAMELEN];
	char *dev;
	char **arg, **argp;

	if(stat("/kfs", d) < 0){
		print("stat /kfs fails: %r\n");
		return -1;
	}

	dev = disk ? disk : bootdisk;
	sprint(partition, "%sfs", dev);
	if(dirstat(partition, &dir) < 0){
		strcpy(partition, dev);
		if(dirstat(partition, &dir) < 0){
			print("stat %s fails: %r\n", partition);
			print("(stat %sfs also failed)\n", dev);
			return -1;
		}
	}
	if(dir.mode & CHDIR)
		return -1;

	print("kfs...");
	if(bind("#c", "/dev", MREPL) < 0)
		fatal("bind #c");
	if(bind("#p", "/proc", MREPL) < 0)
		fatal("bind #p");
	if(pipe(p)<0)
		fatal("pipe");
	switch(fork()){
	case -1:
		fatal("fork");
	case 0:
		arg = malloc((bargc+5)*sizeof(char*));
		argp = arg;
		*argp++ = "kfs";
		*argp++ = "-f";
		*argp++ = partition;
		*argp++ = "-s";
		for(i=1; i<bargc; i++)
			*argp++ = bargv[i];
		*argp = 0;

		dup(p[0], 0);
		dup(p[1], 1);
		close(p[0]);
		close(p[1]);
		exec("/kfs", arg);
		fatal("can't exec kfs");
	default:
		break;
	}

	close(p[1]);
	return p[0];
}
