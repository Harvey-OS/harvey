/*
 * This file is part of the UCB release of Plan 9. It is subject to the license
 * terms in the LICENSE file found in the top-level directory of this
 * distribution and at http://akaros.cs.berkeley.edu/files/Plan9License. No
 * part of the UCB release of Plan 9, including this file, may be copied,
 * modified, propagated, or distributed except according to the terms contained
 * in the LICENSE file.
 */

#include <u.h>
#include <libc.h>
#include <../boot/boot.h>

static char diskname[64];
static char *disk;

void shell(char *c, char *d)
{
	char *argv[] = {"rc", "-m", "/boot/rcmain", 0, 0, 0};
	print("Shell: Run %s %s\n", c, d);
	argv[3] = c;
	argv[4] = d;
	switch(fork()){
	case -1:
		print("configrc: fork failed: %r\n");
	case 0:
		exec("/boot/rc", argv);
		fatal("can't exec rc");
	default:
		break;
	}
	while(waitpid() != -1)
		;
}

void
configlocal(Method *mp)
{
	char *p;
	int n;

	if(*sys == '/' || *sys == '#'){
		/*
		 *  if the user specifies the disk in the boot cmd or
		 * 'root is from' prompt, use it
		 */
		disk = sys;
	} else if(strncmp(argv0, "dksc(0,", 7) == 0){
		/*
		 *  on many mips arg0 of the boot command specifies the
		 *  scsi logical unit number
		 */
		p = strchr(argv0, ',');
		n = strtoul(p+1, 0, 10);
		sprint(diskname, "#w%d/sd%dfs", n, n);
		disk = diskname;
	} else if(mp->arg){
		/*
		 *  a default is supplied when the kernel is made
		 */
		disk = mp->arg;
	} else if(*bootdisk){
		/*
		 *  an environment variable from a pc's plan9.ini or
		 *  from the mips nvram or generated by the kernel
		 *  is the last resort.
		 */
		disk = bootdisk;
	} else {
		disk = "#s/sdE0/";
	}
print("configlocal: disk is %s\n", disk);
	/* if we've decided on one, pass it on to all programs */
	if(disk) {
		setenv("bootdisk", disk);
		setenv("nvram", smprint("%s/nvram", disk));
		setenv("venti", smprint("%s/arenas", disk));
	}


	shell("-c", smprint("/boot/fdisk -p '%s/data' > '%s/ctl'", disk, disk));
	shell("-c", smprint("/boot/prep -p '%s/plan9' > '%s/ctl'", disk, disk));
	//shell("-i", nil);
	USED(mp);
}


static int
print1(int fd, char *s)
{
	return write(fd, s, strlen(s));
}

void
configloopback(void)
{
	int fd;

	if((fd = open("/net/ipifc/clone", ORDWR)) < 0){
		bind("#I", "/net", MAFTER);
		if((fd = open("/net/ipifc/clone", ORDWR)) < 0)
			fatal("open /net/ipifc/clone for loopback");
	}
	if(print1(fd, "bind loopback /dev/null") < 0
	|| print1(fd, "add 127.0.0.1 255.255.255.255") < 0)
		fatal("write /net/ipifc/clone for loopback");
	close(fd);
}

int
connectlocalfossil(void)
{
	int fd;
	char *venti, *f[32], *p;
	int nf;
	char partition[128], buf[512];
	char *dev;

	if(stat("/boot/fossil", statbuf, sizeof statbuf) < 0)
		return -1;

	/* look for fossil partition */
	dev = disk ? disk : bootdisk;
	snprint(partition, sizeof partition, "%sfossil", dev);
	fd = open(partition, OREAD);
	if(fd < 0){
		strcpy(partition, dev);
		fd = open(partition, OREAD);
		if(fd < 0)
			return -1;
	}
	memset(buf, 0, sizeof buf);
	pread(fd, buf, 512, 127*1024);
	close(fd);
	if(memcmp(buf, "fossil config\n", 14) != 0){
		if(strstr(partition, "/fossil"))
			print("no fossil config found on %s\n", partition);
		return -1;
	}

	settime(1, -1, nil);

	/* make venti available */
	if((venti = getenv("venti")) && (nf = tokenize(venti, f, nelem(f)))){
print("VENTI on %s\n", f[0]);
		if((fd = open(f[0], OREAD)) >= 0){
			print("venti...");
			memset(buf, 0, sizeof buf);
			pread(fd, buf, 512, 248*1024);
			close(fd);
			if(memcmp(buf, "venti config\n", 13) != 0){
				print("no venti config found on %s\n", f[0]);
				return -1;
			}
			if(stat("/boot/venti", statbuf, sizeof statbuf) < 0){
				print("/boot/venti does not exist\n");
				return -1;
			}
			switch(nf){
			case 1:
				f[1] = "tcp!127.1!17034";
			case 2:
				f[2] = "tcp!127.1!8000";
			}
			configloopback();
			shell("-c", smprint("/boot/venti -c '%s' -a %s -h %s", f[0], f[1], f[2]));
			/*
			 * If the announce address is tcp!*!foo, then set
			 * $venti to tcp!127.1!foo instead, which is actually dialable.
			 */
			if((p = strstr(f[1], "!*!")) != 0){
				*p = 0;
				snprint(buf, sizeof buf, "%s!127.1!%s", f[1], p+3);
				f[1] = buf;
			}
			setenv("venti", f[1]);
		}else{
print("NO VENTI?\n");
			/* set up the network so we can talk to the venti server */
			/* this is such a crock. */
			configip(nf, f, 0);
			setenv("venti", f[0]);
		}
	}

	/* start fossil */
	print("fossil(%s)...", partition);
	shell("-c", smprint("/boot/fossil -f '%s' -c 'srv -A fboot' -c 'srv -p fscons'", partition));
	fd = open("#s/fboot", ORDWR);
	if(fd < 0){
		print("open #s/fboot: %r\n");
		return -1;
	}
	remove("#s/fboot");	/* we'll repost as #s/boot */
	return fd;
}

int
connectlocal(void)
{
	int fd;

	if(bind("#c", "/dev", MREPL) < 0)
		fatal("bind #c");
	if(bind("#p", "/proc", MREPL) < 0)
		fatal("bind #p");
	bind("#S", "/dev", MAFTER);
	bind("#k", "/dev", MAFTER);
	bind("#Ã¦", "/dev", MAFTER);
	if((fd = connectlocalfossil()) < 0){
		shell("-i", nil);
		return -1;
	}
	return fd;
}
