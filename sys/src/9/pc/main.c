/*
 * initialise an x86 pc system, start all cpus, and
 * start scheduling processes on them, notably /boot/boot.
 * also, graceful shutdown and possibly reboot code.
 */
#include	"u.h"
#include	"../port/lib.h"
#include	"mem.h"
#include	"dat.h"
#include	"fns.h"
#include	"io.h"
#include	"ureg.h"

#include	"init.h"
#include	"pool.h"
#include	"reboot.h"
#include	"mp.h"
#include	<tos.h>
#include	<a.out.h>
#include 	"/sys/src/libmach/elf.h"

enum {
	/* space for syscall args, return PC, top-of-stack struct */
	Ustkheadroom	= sizeof(Sargs) + sizeof(uintptr) + sizeof(Tos),

	Prbda = 0,			/* flag: print BDA values */
	Delaylink = 0,
};

CTASSERT((BIOSTABLES/16)*16 == BIOSTABLES, biostables);

extern long consbaud;

Mach *m = (Mach *)MACHADDR;
Conf conf;

static uchar *initusp;		/* initial user stack of init proc */

static void
options(void)
{
	long i, n;
	char *cp, *line[MAXCONF], *p, *q;

	/*
	 *  parse configuration args from dos file plan9.ini
	 */
	cp = BOOTARGS;		/* where 9boot leaves its config */
	cp[BOOTARGSLEN-1] = 0;

	/*
	 * Strip out '\r', change '\t' -> ' '.
	 */
	p = cp;
	for(q = cp; *q; q++){
		if(*q == '\r')
			continue;
		if(*q == '\t')
			*q = ' ';
		*p++ = *q;
	}
	*p = 0;

	n = getfields(cp, line, MAXCONF, 1, "\n");
	for(i = 0; i < n; i++){
		if(*line[i] == '#')
			continue;
		cp = strchr(line[i], '=');
		if(cp == nil)
			continue;
		*cp++ = '\0';
		confname[nconf] = line[i];
		confval[nconf] = cp;
		nconf++;
	}
}

extern void mmuinit0(void);
extern void (*i8237alloc)(void);	/* filled in by ../port/mkdevc */

static void
prbda(void)
{
	int ebda, fbm;

	if (!Prbda)
		return;
	/* gathering addresses for bios tables & pxe payload size */
	ebda = L16GET((uchar *)EBDAADDR) << 4;
	fbm = L16GET((uchar *)FBMADDR);		/* misaligned short */
	print("ebda %#x = %d, free base mem %dK\n", ebda, ebda, fbm);
}

int isapu(void);

void
main(void)
{
	int apu;

	cgapost(0);
	mach0init();
	options();
	ioinit();

	apu = isapu();
	if (apu)
		consbaud = 115200;	/* assume apu2 */
	i8250console();
	quotefmtinstall();
	screeninit();			/* cga setup */

	print("\nPlan 9 (386)\n");
	if (nvramread(Cmosreset) != Rstpwron)
		nvramwrite(Cmosreset, Rstpwron); /* in case of direct load reboot from 9k */

	trapinit0();			/* minimal set up */
	mmuinit0();

	kbdinit();
	i8253init();			/* timer */
	cpuidentify();
	meminit();			/* prints e820 map */
	confinit();			/* printing goes to kmesg after */
	archinit();
	if(!isa20on(1))			/* just check first 2 MB */
		panic("bootstrap didn't leave a20 address line enabled");
	xinit();
	/* (s)malloc & xalloc are now available */

//	if(i8237alloc != nil)
//		i8237alloc();		/* dma (for floppy) init */
	trapinit();
	mmuinit();
	printinit();			/* console input goes to lineq */
	kmesginit();			/* uses vmap */
	if (apu)
		apueccon();		/* uses pci & malloc & print */

	cpuidprint();
//	xsummary();			/* xalloc printing */
	prbda();
	fpsavealloc();

	if(arch->intrinit)
		arch->intrinit();	/* launches other processors on an mp */
	/* all Mach structs should now be allocated */

	pciaddbuses(nil);
	timersinit();
	mathinit();
	kbdenable();
	if(arch->clockenable)
		arch->clockenable();
	procinit0();
	initseg();

	if(Delaylink){			/* never set on the pc */
		bootlinks();		/* generated by config: sets up /boot */
		pcimatch(0, 0, 0);
	}else
		links(); /* generated by config: bootlinks, then device links */
//	if (apu)
//		apueccon();
	chandevreset();
	cgapost(0xcd);

	/* must follow xinit & conf.mem must be populated; prints allocations */
	pageinit();
	i8253link();			/* timer again */
	swapinit();
	/* with luck, all critical kernel data structures are now allocated. */
	userinit();
	cgapost(0x99);

	active.thunderbirdsarego = 1;
	coherence();
	schedinit();
}

void
mach0init(void)
{
	conf.nmach = 1;
	MACHP(0) = (Mach*)CPU0MACH;
	m->pdb = (ulong*)CPU0PDB;
	m->gdt = (Segdesc*)CPU0GDT;

	machinit();

	cpuactive(0);
	active.exiting = 0;
}

void
machinit(void)
{
	int machno;
	ulong *pdb;
	Segdesc *gdt;

	machno = m->machno;
	pdb = m->pdb;
	gdt = m->gdt;
	memset(m, 0, sizeof(Mach));
	m->machno = machno;
	m->pdb = pdb;
	m->gdt = gdt;
	m->perf.period = 1;

	/*
	 * For polled uart output at boot, need
	 * a default delay constant. 100000 should
	 * be enough for a while. Cpuidentify will
	 * calculate the real value later.
	 */
	m->loopconst = 100000;
}

void
init0(void)
{
	int i;
	char buf[2*KNAMELEN];

	up->nerrlab = 0;

	spllo();

	/*
	 * These are o.k. because devroot's init function is null.
	 * Then early kproc's will have a root and dot.
	 */
	up->slash = namec("#/", Atodir, 0, 0);
	pathclose(up->slash->path);
	up->slash->path = newpath("/");
	up->dot = cclone(up->slash);

	chandevinit();

	if(!waserror()){
		snprint(buf, sizeof(buf), "%s %s", arch->id, conffile);
		ksetenv("terminal", buf, 0);
		ksetenv("cputype", "386", 0);
		if(cpuserver)
			ksetenv("service", "cpu", 0);
		else
			ksetenv("service", "terminal", 0);
		for(i = 0; i < nconf; i++){
			if(confname[i][0] != '*')
				ksetenv(confname[i], confval[i], 0);
			ksetenv(confname[i], confval[i], 1);
		}
		poperror();
	}
	kproc("alarm", alarmkproc, 0);
	cgapost(0x9);
	/* initusp is result of bootargs */
	touser(initusp);
}

void
userinit(void)
{
	void *v;
	Proc *p;
	Segment *s;
	Page *pg;

	p = newproc();
	p->pgrp = newpgrp();
	p->egrp = smalloc(sizeof(Egrp));
	p->egrp->ref = 1;
	p->fgrp = dupfgrp(nil);
	p->rgrp = newrgrp();
	p->procmode = 0640;

	kstrdup(&eve, "");
	kstrdup(&p->text, "*init*");
	kstrdup(&p->user, eve);

	p->fpstate = FPinit;
	fpoff();

	/*
	 * Kernel Stack
	 *
	 * N.B. make sure there's enough space for syscall to check
	 *	for valid args and
	 *	4 bytes for gotolabel's return PC
	 */
	p->sched.pc = (ulong)init0;
	p->sched.sp = (ulong)p->kstack+KSTACK-(sizeof(Sargs)+BY2WD);

	/*
	 * User Stack
	 *
	 * N.B. cannot call newpage() with clear=1, because pc kmap
	 * requires up != nil.  use tmpmap instead.
	 */
	s = newseg(SG_STACK, USTKTOP-USTKSIZE, USTKSIZE/BY2PG);
	p->seg[SSEG] = s;
	pg = newpage(0, 0, USTKTOP-BY2PG);
	v = tmpmap(pg);
	memset(v, 0, BY2PG);
	segpage(s, pg);
	initusp = bootargs(v);
	/* initusp will be init0's stack pointer via touser */
	tmpunmap(v);

	/*
	 * Text
	 */
	s = newseg(SG_TEXT, UTZERO, 1);
	s->flushme++;
	p->seg[TSEG] = s;
	pg = newpage(0, 0, UTZERO);
	memset(pg->cachectl, PG_TXTFLUSH, sizeof(pg->cachectl));
	segpage(s, pg);
	v = tmpmap(pg);
	memset(v, 0, BY2PG);
	memmove(v, initcode, sizeof initcode);
	tmpunmap(v);

	ready(p);
}

uchar *
pusharg(uchar *sp, char *p)
{
	int n;

	n = strlen(p)+1;
	sp -= n;
	memmove(sp, p, n);
	return sp;
}

uchar *
bootargs(void *base)
{
 	int i, ac;
	uchar *av[32];
	uchar *sp;
	uchar **lsp;
	char *cp = BOOTLINE;
	char buf[64];

	sp = (uchar*)base + BY2PG - Ustkheadroom;
	ac = 0;
	av[ac++] = sp = pusharg(sp, "/386/9dos");	/* 9dos is long gone */

	/* when boot is changed to only use rc, this code can go away */
	cp[BOOTLINELEN-1] = 0;
	buf[0] = 0;
	if(strncmp(cp, "fd", 2) == 0){
		snprint(buf, sizeof buf, "local!#f/fd%lddisk",
			strtol(cp+2, 0, 0));
		av[ac++] = sp = pusharg(sp, buf);
	} else if(strncmp(cp, "sd", 2) == 0){
		snprint(buf, sizeof buf, "local!#S/sd%c%c/fs", *(cp+2), *(cp+3));
		av[ac++] = sp = pusharg(sp, buf);
	} else if(strncmp(cp, "ether", 5) == 0)
		av[ac++] = sp = pusharg(sp, "-n");

	/* 4 byte word align stack */
	sp = (uchar*)((ulong)sp & ~(BY2WD-1));

	/* build argc, argv on stack */
	sp -= (ac+1)*sizeof(sp);
	lsp = (uchar**)sp;
	for(i = 0; i < ac; i++)
		*lsp++ = av[i] + ((USTKTOP - BY2PG) - (ulong)base);
	*lsp = 0;
	sp += (USTKTOP - BY2PG) - (ulong)base - sizeof(ulong);
	return sp;
}

char*
getconf(char *name)
{
	int i;

	for(i = 0; i < nconf; i++)
		if(cistrcmp(confname[i], name) == 0)
			return confval[i];
	return 0;
}

static void
writeconf(void)
{
	char *p, *q;
	int n;

	p = getconfenv();

	if(waserror()) {
		free(p);
		nexterror();
	}

	/* convert to name=value\n format */
	for(q=p; *q; q++) {
		q += strlen(q);
		*q = '=';
		q += strlen(q);
		*q = '\n';
	}
	n = q - p + 1;
	if(n >= BOOTARGSLEN)
		error("kernel configuration too large");
	memset(BOOTLINE, 0, BOOTLINELEN);
	memmove(BOOTARGS, p, n);
	poperror();
	free(p);
}

enum {
	Kmesgpages = HOWMANY(KMESGSIZE, BY2PG) + 1,
};

static ulong
kernelpages(ulong npages, int userpcnt)
{
	ulong kpages, mb, ksize;

	kpages = npages - (npages*userpcnt)/100;
	if(cpuserver)
		/*
		 * Hack for the big boys. Only good while physmem < 4GB.
		 * Give the kernel fixed max + enough to allocate the page pool.
		 * This is an overestimate as conf.upages < conf.npages.
		 * The patch of nimage is a band-aid, scanning the whole
		 * page list in imagereclaim just takes too long.
		 */
		for (mb = 400; mb >= 100; mb /= 2) {
			ksize = mb*MB + conf.npage*sizeof(Page);
			if(kpages > ksize/BY2PG && cankaddr(ksize)) {
				kpages = ksize/BY2PG + (conf.nproc*KSTACK)/BY2PG;
				conf.nimage = 2000;
				break;
			}
		}
	else
		/*
		 * Make sure terminals with low memory get at least
		 * 4MB on the first Image chunk allocation.
		 */
		if(conf.npage*BY2PG < 16*MB)		/* never true now */
			imagmem->minarena = 4*1024*1024;

	/*
	 * can't go past the end of virtual memory
	 * (ulong)-KZERO is 2^32 - KZERO
	 */
	if(kpages > ((ulong)-KZERO)/BY2PG)
		kpages = ((ulong)-KZERO)/BY2PG;
	return kpages;
}

void
confinit(void)
{
	char *p;
	int i, userpcnt;
	ulong kpages, npages, npage;
	Confmem *cm;

	/* count pages */
	conf.npage = 0;
	for(i=0; i<nelem(conf.mem); i++) {
		cm = &conf.mem[i];
		npage = cm->npage;
		conf.npage += npage;
		if (npage >= Kmesgpages)
			kmsgbase = (uchar *)cm->base + BY2PG*(npage - Kmesgpages);
	}
	/* omit top pages for kmesg buffer */
	npages = conf.npage - Kmesgpages;

	conf.nproc = 100 + ((conf.npage*BY2PG)/MB)*5;
	if(cpuserver)
		conf.nproc *= 3;
	/* a 4GB cpu server will have nproc around 54,000 here */
	if(conf.nproc > 3000)
		conf.nproc = 3000;
	conf.nimage = 200;
	conf.nswap = conf.nproc*80;
	conf.nswppo = 4096;

	/* decide user/kernel split of memory */
	userpcnt = 0;
	if(p = getconf("*kernelpercent"))
		userpcnt = 100 - strtol(p, 0, 0);
	if(userpcnt < 10)
		if(cpuserver)
			userpcnt = 70;
		else
			userpcnt = conf.npage*BY2PG < 16*MB? 40: 60;
	kpages = kernelpages(npages, userpcnt);

	conf.upages = npages - kpages;
	conf.ialloc = (kpages/2)*BY2PG;

	/*
	 * Guess how much is taken by the large permanent
	 * datastructures. Mntcache and Mntrpc are not accounted for
	 * (probably ~300KB).
	 */
	kpages *= BY2PG;
	kpages -= conf.upages*sizeof(Page)	/* palloc.pages in pageinit */
		+ conf.nproc*sizeof(Proc)  /* procalloc.free in procinit0 */
		+ conf.nimage*sizeof(Image)	/* imagealloc.free in initseg */
		+ conf.nswap		/* swapalloc.swmap in swapinit */
		+ conf.nswppo*sizeof(Page*);	/* iolist in swapinit */

	mainmem->maxsize = kpages;
	if(!cpuserver)
		/*
		 * give terminals lots of image memory, too; the dynamic
		 * allocation will balance the load properly, hopefully.
		 * be careful with 32-bit overflow.
		 */
		imagmem->maxsize = kpages;
}

/*
 *  set up floating point for a new process
 */
void
procsetup(Proc*p)
{
	p->fpstate = FPinit;
	fpoff();
}

/* called from sched() */
void
procrestore(Proc *p)
{
	uvlong t;

	if(p->kp)
		return;
	cycles(&t);
	p->pcycles -= t;
	lockwake();			/* other runnable procs? */
	coherence();
}

/*
 *  Save the mach dependent part of the process state.
 */
void
procsave(Proc *p)
{
	uvlong t;

	cycles(&t);
	p->pcycles += t;
	procfpusave(p);

	/*
	 * While this processor is in the scheduler, the process could run
	 * on another processor and exit, returning the page tables to
	 * the free list where they could be reallocated and overwritten.
	 * When this processor eventually has to get an entry from the
	 * trashed page tables it will crash.
	 *
	 * If there's only one processor, this can't happen.
	 * You might think it would be a win not to do this in that case,
	 * especially on VMware, but it turns out not to matter.
	 */
	mmuflushtlb(PADDR(m->pdb));
	coherence();
}

static void
drainuart(void)
{
	int i;

	if (!islo()) {
		iprint("drainuart: called splhi\n");
		delay(100);
		return;
	}
	for (i = 300; i > 0 && consactive(); i--)
		delay(10);
}

/* shutdown this cpu. */
static void
shutdown(int ispanic)
{
	int ms, once;

	lock(&active);
	if(ispanic)
		active.ispanic = ispanic;
	else if(m->machno == 0 && !iscpuactive(m->machno))
		active.ispanic = 0;
	once = iscpuactive(m->machno);
	/*
	 * setting exiting will make hzclock() on each processor call exit(0),
	 * which calls shutdown(0) and arch->reset(), which on mp systems is
	 * mpshutdown, which idles non-bootstrap cpus and returns on bootstrap
	 * processors (to permit a reboot).  clearing our bit in active.machsmap
	 * avoids calling exit(0) from hzclock() on this processor.
	 */
	cpuinactive(m->machno);
	active.exiting = 1;
	unlock(&active);

	if(once) {
		iprint("cpu%d exiting...", m->machno);
		delay(10);
	}

	/* wait for any other processors to shutdown */
	spllo();
	if (!ispanic && active.rebooting)
		return;

	if (m->machno == 0)
		for(ms = 5*1000; ms > 0; ms -= TK2MS(2)){
			delay(TK2MS(2));
			if(active.nmachs == 0 && consactive() == 0)
				break;
		}

	if(!active.ispanic)
		delay(1000);
	else if(!cpuserver)
		for(;;)
			halt();
	else if(getconf("*debug"))
		delay(5*60*1000);
	else
		delay(10000);
}

static int
okkernel(int magic)
{
	/* we can load amd64 plan 9 kernels too */
	return magic == I_MAGIC || magic == S_MAGIC;
}

int (*isokkernel)(int) = okkernel;

/*
 * if we have to reschedule, up must be set (i.e., we must be in a user
 * process).
 */
void
runoncpu(int cpu)
{
	if (m->machno == cpu)
		return;			/* done! */
	if (up == nil)
		panic("runoncpu: nil up");
	procwired(up, cpu);
	sched();
	if (m->machno != cpu)
		iprint("cpu%d: can't switch to cpu%d\n", m->machno, cpu);
}

static void
shutothercpus(void)
{
	/*
	 * the boot processor is cpu0.  execute this process on it
	 * so that the new kernel has the same cpu0.  this only matters
	 * because the hardware has a notion of which processor was the
	 * boot processor and we look at it at start up.
	 */
	if (m->machno != 0 && up)
		runoncpu(0);

	/*
	 * the other cpus could be holding locks that will never get
	 * released (e.g., in the print path) if we put them into
	 * reset now, so ask them to shutdown gracefully, then force
	 * them into reset.  once active.rebooting is set, any or all
	 * of the other cpus may be idling but not servicing interrupts.
	 */
	lock(&active);
	active.rebooting = 1;	/* request other cpus shutdown */
	unlock(&active);

	shutdown(Shutreboot);

	delay(100);	/* let other cpus shut down gracefully */
	if (active.nmachs > 1) {
		iprint("%d cpus still active\n", active.nmachs);
		delay(20);
	}

	/* any intrs to these cpus will not be delivered hereafter */
	if(arch->resetothers) {
		arch->resetothers();
		delay(20);
	}
	iprint("\nother cpus in reset...");
	delay(20);
}

/*
 * shutdown this kernel, copy another into place via trampoline code,
 * jump to the new kernel.
 */
void
reboot(void *phyentry, void *code, ulong size)
{
	int i;
	void (*tramp)(ulong, ulong, ulong);
	ulong *pdb;

	writeconf();
	drainuart();

	/*
	 * interrupts (including uart) may be routed to any or all cpus, so
	 * shutdown devices, other cpus, and interrupts (rely upon iprint
	 * hereafter).
	 */
	chandevshutdown();
	drainuart();			/* before stopping cpus & interrupts */

	if (conf.nmach > 1)
		shutothercpus();
	/*
	 * should be the only processor running now.
	 * any intrs to other cpus will not be delivered hereafter.
	 */
	memset(active.machsmap, 0, sizeof active.machsmap);

	serialoq = nil;			/* turn off buffered serial console */
	splhi();
	arch->introff();
	pcireset();			/* disable bus masters & intrs */

	/*
	 * Modify the machine page table to directly map low memory
	 * This allows the reboot code to turn off the page mapping
	 */
	pdb = m->pdb;
	for (i = 0; i < LOWPTEPAGES; i++)
		pdb[PDX(i*4*MB)] = pdb[PDX(KZERO + i*4*MB)];
	mmuflushtlb(PADDR(pdb));

	/* setup reboot trampoline function */
	tramp = (void*)REBOOTADDR;
	memmove(tramp, rebootcode, sizeof(rebootcode));

	mkmultiboot();
	iprint("starting new kernel at %#p...\n", phyentry);

	/* off we go - never to return */
	coherence();
	(*tramp)((ulong)phyentry, PADDR(code), size);
}


void
exit(int ispanic)
{
	shutdown(ispanic);
	arch->reset();			/* mpshutdown or archreset */
}

int
isaconfig(char *class, int ctlrno, ISAConf *isa)
{
	char cc[32], *p;
	int i;

	snprint(cc, sizeof cc, "%s%d", class, ctlrno);
	p = getconf(cc);
	if(p == nil)
		return 0;

	isa->type = "";
	isa->nopt = tokenize(p, isa->opt, NISAOPT);
	for(i = 0; i < isa->nopt; i++){
		p = isa->opt[i];
		if(cistrncmp(p, "type=", 5) == 0)
			isa->type = p + 5;
		else if(cistrncmp(p, "port=", 5) == 0)
			isa->port = strtoul(p+5, &p, 0);
		else if(cistrncmp(p, "irq=", 4) == 0)
			isa->irq = strtoul(p+4, &p, 0);
		else if(cistrncmp(p, "dma=", 4) == 0)
			isa->dma = strtoul(p+4, &p, 0);
		else if(cistrncmp(p, "mem=", 4) == 0)
			isa->mem = strtoul(p+4, &p, 0);
		else if(cistrncmp(p, "size=", 5) == 0)
			isa->size = strtoul(p+5, &p, 0);
		else if(cistrncmp(p, "freq=", 5) == 0)
			isa->freq = strtoul(p+5, &p, 0);
	}
	return 1;
}
