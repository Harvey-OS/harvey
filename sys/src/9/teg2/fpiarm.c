/*
 * this doesn't attempt to implement ARM floating-point properties
 * that aren't visible in the Inferno environment.
 * all arithmetic is done in double precision.
 * the FP trap status isn't updated.
 *
 * this will emulate old 7500 FPA instructions or new VFP ones,
 * even intermixed within a program.  code marked `unused' pertains
 * to instructions not generated by 5l, whose implementations are often
 * shunted to the _notyet subdirectory.
 */
#include	"u.h"
#include	"../port/lib.h"
#include	"mem.h"
#include	"dat.h"
#include	"fns.h"
#include	"ureg.h"
#include	"arm.h"
#include	"../port/fpi.h"

enum {
	Fpaemudebug = 0,
	Vfpemudebug = 0,
	fpemudebug = Fpaemudebug | Vfpemudebug,

	Nfparegs = 8,		/* old pre-VFP ARM7500FE FPA */
	Fparegmask = Nfparegs - 1,

	/* only use the guaranteed 16 of a possible 32 for portability */
	Nvfpregs = 16,
	Vfpregmask = Nvfpregs - 1,
};

/*
 * instruction decoding
 */
#define FPAOP(inst)	(((inst)>>20) & MASK(4))	/* fpa operation */
#define FPAREGN(inst)	(((inst)>>16) & Fparegmask)	/* Fn */
#define FPAREGD(inst)	(((inst)>>12) & Fparegmask)	/* Fd */

#define VFPOP(inst)	(((inst)>>20) & MASK(4))	/* vfp operation 1 */
#define VFPOP2(inst)	(((inst)>>16) & MASK(4))	/* vfp operation 2 */
#define VFPOP3(inst)	(((inst)>>6) & MASK(2))		/* vfp operation 3 */
#define VFPOP4(inst)	(((inst)>>0) & MASK(4))		/* low immediate bits */

/*
 * undef this if correct kernel r13 isn't in Ureg;
 * check calculation in fpiarm below
 */
#define	REG(ur, x)	(*(long*)(((char*)(ur)) + roff[(x)]))
#define	FPAR(ufp, x)	((ufp)->regs[(x) & Fparegmask].Internal)
#define	VFPR(ufp, x)	((ufp)->regs[(x) & Vfpregmask].Internal)

#ifdef MEASURE
#define count(l) ainc(l)

typedef struct Vfpstats Vfpstats;
struct Vfpstats {
	long	arith;
	long	loadd;			/* opcode 0xd */
	long	stored;
	long	cmp;
	long	cvtfix;
	long	cvtflt;
	long	movfix;
	long	fploads;
	long	fpstores;
	long	movreg;
	long	unimp;
};
static Vfpstats stats;
#else
#define count(l)
#endif					/* MEASURE */

typedef struct FP2 FP2;
typedef struct FP1 FP1;

struct FP2 {
	char*	name;
	void	(*f)(Internal, Internal, Internal*);
};

struct FP1 {
	char*	name;
	void	(*f)(Internal*, Internal*);
};

enum {
	N = 1<<31,		/* these match Psr[NZCV] in arm.h */
	Z = 1<<30,
	C = 1<<29,
	V = 1<<28,
	REGPC = 15,
};

#define	OFR(memb) offsetof(Ureg, memb)

static	int	roff[] = {
	OFR(r0), OFR(r1), OFR(r2), OFR(r3), OFR(r4), OFR(r5), OFR(r6), OFR(r7),
	OFR(r8), OFR(r9), OFR(r10), OFR(r11), OFR(r12), OFR(r13), OFR(r14),
	OFR(pc),
};

static Internal fpconst[8] = {	/* indexed by inst&Fparegmask (ARM 7500 FPA) */
	/* s, e, l, h */
	{0, 0x1,   0, 0x00000000},	/* 0.0 */
	{0, 0x3FF, 0, 0x08000000},	/* 1.0 */
	{0, 0x400, 0, 0x08000000},	/* 2.0 */
	{0, 0x400, 0, 0x0C000000},	/* 3.0 */
	{0, 0x401, 0, 0x08000000},	/* 4.0 */
	{0, 0x401, 0, 0x0A000000},	/* 5.0 */
	{0, 0x3FE, 0, 0x08000000},	/* 0.5 */
	{0, 0x402, 0, 0x0A000000},	/* 10.0 */
};

/*
 * arm binary operations
 */

static void
fadd(Internal m, Internal n, Internal *d)
{
	(m.s == n.s? fpiadd: fpisub)(&m, &n, d);
}

static void
fsub(Internal m, Internal n, Internal *d)
{
	m.s ^= 1;
	(m.s == n.s? fpiadd: fpisub)(&m, &n, d);
}

static void
fsubr(Internal m, Internal n, Internal *d)
{
	n.s ^= 1;
	(n.s == m.s? fpiadd: fpisub)(&n, &m, d);
}

static void
fmul(Internal m, Internal n, Internal *d)
{
	fpimul(&m, &n, d);
}

static void
fdiv(Internal m, Internal n, Internal *d)
{
	fpidiv(&m, &n, d);
}

static void
fdivr(Internal m, Internal n, Internal *d)
{
	fpidiv(&n, &m, d);
}

/*
 * arm unary operations
 */

static void
fmov(Internal *m, Internal *d)
{
	*d = *m;
	count(&stats.movreg);
}

static void
fmovn(Internal *m, Internal *d)
{
	*d = *m;
	d->s ^= 1;
}

static void
fabsf(Internal *m, Internal *d)
{
	*d = *m;
	d->s = 0;
}

static void
frnd(Internal *m, Internal *d)
{
	short e;

	(m->s? fsub: fadd)(fpconst[6], *m, d);	/* fpconst[6] is 0.5 */
	if(IsWeird(d))
		return;
	fpiround(d);
	e = (d->e - ExpBias) + 1;
	if(e <= 0)
		SetZero(d);
	else if(e > FractBits){
		if(e < 2*FractBits)
			d->l &= ~((1<<(2*FractBits - e))-1);
	}else{
		d->l = 0;
		if(e < FractBits)
			d->h &= ~((1<<(FractBits-e))-1);
	}
}

static ulong
fcmp(Internal *n, Internal *m)
{
	int i;
	Internal rm, rn;

	if(IsWeird(m) || IsWeird(n)){
		/* BUG: should trap if not masked */
		return V|C;
	}
	rn = *n;
	rm = *m;
	fpiround(&rn);
	fpiround(&rm);
	i = fpicmp(&rn, &rm);
	if(i > 0)
		return C;
	else if(i == 0)
		return C|Z;
	else
		return N;
}

int
condok(int cc, int c)	/* cc is a psr; c is the arm condition to test */
{
	switch(c){
	case 0:	/* Z set */
		return cc&Z;
	case 1:	/* Z clear */
		return (cc&Z) == 0;
	case 2:	/* C set */
		return cc&C;
	case 3:	/* C clear */
		return (cc&C) == 0;
	case 4:	/* N set */
		return cc&N;
	case 5:	/* N clear */
		return (cc&N) == 0;
	case 6:	/* V set */
		return cc&V;
	case 7:	/* V clear */
		return (cc&V) == 0;
	case 8:	/* C set and Z clear */
		return cc&C && (cc&Z) == 0;
	case 9:	/* C clear or Z set */
		return (cc&C) == 0 || cc&Z;
	case 10:	/* N set and V set, or N clear and V clear */
		return (~cc&(N|V))==0 || (cc&(N|V)) == 0;
	case 11:	/* N set and V clear, or N clear and V set */
		return (cc&(N|V))==N || (cc&(N|V))==V;
	case 12:	/* Z clear, and either N set and V set or N clear and V clear */
		return (cc&Z) == 0 && ((~cc&(N|V))==0 || (cc&(N|V))==0);
	case 13:	/* Z set, or N set and V clear or N clear and V set */
		return (cc&Z) || (cc&(N|V))==N || (cc&(N|V))==V;
	case 14:	/* always */
		return 1;
	case 15:	/* never (reserved) */
		return 0;
	}
	return 0;	/* not reached */
}

static void
unimp(uintptr pc, Inst op)
{
	char buf[70];

	snprint(buf, sizeof buf, "sys: fp: pc=%p unimp fp %#.8lux", pc, op);
	if(fpemudebug)
		print("FPE: %s\n", buf);
	count(&stats.unimp);
	error(buf);
	/* no return */
}

/*
 * ARM 7500 FPA emulation
 */

enum {					/* ARM 7500 instructions */
	/* load and store instruction bits */
	Fpapreidx= 1<<24,
	Fpaup	= 1<<23,
	Fpat1	= 1<<22,
	Fpawb	= 1<<21,		/* write-back */
	Fpaload	= 1<<20,
	Fpadbl	= 1<<15,		/* t0 bit */

	/* other instruction bits */
	Fpamonadic = 1<<15,
	Fpaxfer	= 1<<4,
	Fpaimmed= 1<<3,
};

/* understands FPA instruction layout for ARM 7500 loads & stores */
static void
fpaemuldst(Ureg *ur, Inst inst)
{
	int rn, rd, dbl;
	long off;
	uintptr ea;
	Internal i;

	/*
	 * LDF, STF; ARM7500FE manual §10.1.1
	 */
	if(inst & Fpat1)
		unimp(ur->pc, inst);	/* packed or extended */

	off = (inst & MASK(8)) << 2;	/* convert words to bytes */
	if(!(inst & Fpaup))
		off = -off;

	rn = CPUREGN(inst);
	ea = REG(ur, rn);
	if(rn == REGPC)
		ea += 8;		/* §A2.3 */
	if(inst & Fpapreidx)
		ea += off;		/* pre-increment */

	rd = FPAREGD(inst);
	dbl = inst & Fpadbl;
	if(inst & Fpaload) {
		(*(dbl? fpid2i: fpis2i))(&FPAR(&up->fpsave, rd), (void *)ea);
		if(Fpaemudebug)
			print("MOV%c\t#%p, F%d\n", dbl? 'D': 'F', ea, rd);
	} else {
		if(Fpaemudebug)
			print("MOV%c\tF%d, #%p\n", dbl? 'D': 'F', rd, ea);
		i = FPAR(&up->fpsave, rd);
		(*(dbl? fpii2d: fpii2s))((void *)ea, &i);
	}

	if(!(inst & Fpapreidx))
		ea += off;		/* post-increment */
	if(inst & Fpawb)
		REG(ur, rn) = ea;
}

static Internal *
fpafmoperand(Inst inst)
{
	int rm;

	rm = inst & Fparegmask;
	if(inst & Fpaimmed)		/* `immediate': constant from table */
		return &fpconst[rm];
	else
		return &FPAR(&up->fpsave, rm);
}

/*
 * understands FPA instruction layout for ARM 7500 compares, conversions &
 * register transfers.
 */
static void
fpaemuxfer(Ureg *ur, Inst inst)
{
	int rm, rn, rd, fpop;
	Internal tmp, *fn;
	FPsave *ufp;

	/*
	 * CPRT/transfer, §10.3
	 */
	rd = CPUREGD(inst);
	fpop = FPAOP(inst);
	ufp = &up->fpsave;

	/*
	 * compare, §10.3.1
	 */
	if(rd == REGPC && inst & Fpaload){
		rn = FPAREGN(inst);
		fn = &FPAR(ufp, rn);
		tmp = *fpafmoperand(inst);
		switch(fpop >> 1){
		default:
			unimp(ur->pc, inst);
		case 5:		/* CNF: Fn :: -Fm */
		case 7:		/* CNFE: Fn :: -Fm (with exception) */
			tmp.s ^= 1;
			/* fall through */
		case 4:		/* CMF: Fn :: Fm */
		case 6:		/* CMFE: Fn :: Fm (with exception) */
			ur->psr &= ~(N|C|Z|V);
			ur->psr |= fcmp(fn, &tmp);
			break;
		}
		if(Fpaemudebug)
			print("CMPF\t%c%d,F%ld =%#lux\n",
				(inst&Fpaimmed? 'C': 'F'), rn, inst&Fparegmask,
				ur->psr>>28);
		return;
	}

	/*
	 * conversions, csr access, §10.3
	 */
	switch(fpop){
	default:
		unimp(ur->pc, inst);
	case 0:				/* FLT Fn := Rd */
		rn = FPAREGN(inst);
		fpiw2i(&FPAR(ufp, rn), &REG(ur, rd));
		if(Fpaemudebug)
			print("MOVW[FD]\tR%d, F%d\n", rd, rn);
		break;
	case 1:				/* FIX Rd := Fm */
		if(inst & Fpaimmed)
			unimp(ur->pc, inst);	/* disallowed; pointless */
		rm = inst & Fparegmask;
		tmp = FPAR(ufp, rm);
		fpii2w(&REG(ur, rd), &tmp);
		if(Fpaemudebug)
			print("MOV[FD]W\tF%d, R%d =%ld\n", rm, rd, REG(ur, rd));
		break;
	case 2:				/* FPSR := Rd */
		ufp->status = REG(ur, rd);
		if(Fpaemudebug)
			print("MOVW\tR%d, FPSR\n", rd);
		break;
	case 3:				/* Rd := FPSR */
		REG(ur, rd) = ufp->status;
		if(Fpaemudebug)
			print("MOVW\tFPSR, R%d\n", rd);
		break;
	case 4:				/* FPCR := Rd (kernel only) */
		ufp->control = REG(ur, rd);
		if(Fpaemudebug)
			print("MOVW\tR%d, FPCR\n", rd);
		break;
	case 5:				/* Rd := FPCR (kernel only) */
		REG(ur, rd) = ufp->control;
		if(Fpaemudebug)
			print("MOVW\tFPCR, R%d\n", rd);
		break;
	}
}

/*
 * ARM 7500 FPA opcode -> function map.
 * the functions called know nothing of the instruction format.
 */

static	FP1 fpaops1[16] = {	/* Fd := OP Fm */
[0]	{"MOVF",	fmov},
[1]	{"NEGF",	fmovn},
[2]	{"ABSF",	fabsf},
[3]	{"RNDF",	frnd},
[4]	{"SQTF",	/*fsqt*/0},
/* LOG, LGN, EXP, SIN, COS, TAN, ASN, ACS, ATN all `deprecated' */
/* URD and NRM aren't implemented */
};

static	FP2 fpaops2[16] = {	/* Fd := Fn OP Fm */
[0]	{"ADDF",	fadd},
[1]	{"MULF",	fmul},
[2]	{"SUBF",	fsub},
[3]	{"RSUBF",	fsubr},
[4]	{"DIVF",	fdiv},
[5]	{"RDIVF",	fdivr},
/* POW, RPW deprecated */
[8]	{"REMF",	/*frem*/0},
[9]	{"FMF",		fmul},	/* fast multiply */
[10]	{"FDV",		fdiv},	/* fast divide */
[11]	{"FRD",		fdivr},	/* fast reverse divide */
/* POL deprecated */
};

/*
 * only called to emulate FPA instructions; makes assumptions about unexamined
 * instruction bits.  understands FPA instruction layout for ARM 7500.
 */
static void
fpaemu(Ureg *ur, Fpinst *fpin)
{
	int rm, rn, rd, fpop;
	Inst inst;
	FPsave *ufp;
	Internal *fm;

	/* note: would update fault status here if we noted numeric exceptions */
	inst = fpin->inst;
	if(Fpaemudebug)
		print("%#p: fpa %#8.8lux ", ur->pc, inst);
	if ((fpin->op >> 1) == 6) {
		fpaemuldst(ur, inst);
		return;
	}
	if(inst & Fpaxfer){
		fpaemuxfer(ur, inst);
		return;
	}

	/*
	 * arithmetic, §10.2
	 */

	if (Fpaemudebug)
		rm = inst & Fparegmask;
	ufp = &up->fpsave;
	fm = fpafmoperand(inst);
	rd = FPAREGD(inst);
	fpop = FPAOP(inst);
	if(inst & Fpamonadic){
		FP1 *fp;
		fp = &fpaops1[fpop];
		if(fp->f == nil)
			unimp(ur->pc, inst);
		if(Fpaemudebug)
			print("%s\t%c%d,F%d\n", fp->name,
				(inst&Fpaimmed? 'C': 'F'), rm, rd);
		(*fp->f)(fm, &FPAR(ufp, rd));
	} else {
		FP2 *fp;
		fp = &fpaops2[fpop];
		if(fp->f == nil)
			unimp(ur->pc, inst);
		rn = FPAREGN(inst);
		if(Fpaemudebug)
			print("%s\t%c%d,F%d,F%d\n", fp->name,
				(inst&Fpaimmed? 'C': 'F'), rm, rn, rd);
		(*fp->f)(*fm, FPAR(ufp, rn), &FPAR(ufp, rd));
	}
}

/*
 * VFP emulation
 */

enum {					/* VFP instructions */
	/* coproc op-codes for vfp */
	Vfpxfer64=0xc,
	Vfpldst	= 0xd,
	Vfparith= 0xe,

	/* load and store instruction bits */
	Vfpup	= 1<<23,
	Vfpload	= 1<<20,		/* also, fpu to cpu for vmov */
	Vfptocpu= 1<<4,

	/* other instruction bits */
	Vfpnproc= 1<<4,			/* not arithmetic */
};

/*
 * VFP opcode -> function map.
 * the functions called via this mapping know nothing of the instruction format.
 */

#define VFPDYADOP(op1, op3) ((((op1)&010) >> 1 | (op1)&3) << 1 | (op3)&1)

static	FP2 vfpops2[] = {	/* Fd := Fn OP Fm */
[4]	{"MULF",	fmul},
[6]	{"ADDF",	fadd},
[7]	{"SUBF",	fsub},
[8]	{"DIVF",	fdiv},
/* 016 and 017 are monadic */
};

static Internal *
vfpfmregop(Inst inst)
{
	return &VFPR(&up->fpsave, inst & Vfpregmask);
}

/* understands VFP instruction layout for loads & stores */
static void
vfpemuldst(Ureg *ur, Fpinst *fpin)
{
	int rn, dbl;
	long off;
	uintptr ea;
	Fprepr *fprp;
	Inst inst;
	Internal tmp;

	/*
	 * VLDR, VSTR; ARM v7 arch manual §A7.6, §A8.8.333
	 */
	inst = fpin->inst;
	off = (inst & MASK(8)) * BY2WD;
	if(!(inst & Vfpup))
		off = -off;

	rn = CPUREGN(inst);
	ea = REG(ur, rn) + off;
	if(rn == REGPC)	
		ea += 8;		/* §A2.3 */

	dbl = fpin->coproc == CpDFP;
	fprp = &up->fpsave.regs[fpin->vd];
	if(inst & Vfpload) {
		(*(dbl? fpid2i: fpis2i))(&fprp->Internal, (void *)ea);
		fprp->useirepr = 0;
		fprp->irepr = 0;
		if(Vfpemudebug)
			print("MOV%c\t#%p, F%d\n", dbl? 'D': 'F', ea, fpin->vd);
		count(&stats.loadd);
	} else {
		tmp = fprp->Internal;
		(*(dbl? fpii2d: fpii2s))((void *)ea, &tmp);
		if(Vfpemudebug)
			print("MOV%c\tF%d, #%p\n", dbl? 'D': 'F', fpin->vd, ea);
		count(&stats.stored);
	}
}


/*
 * understands VFP instruction layout for comparisons.
 * operands are all (Internal) VFP registers.
 */
static void
vfpemucmp(Fpinst *fpin)
{
	FPsave *ufp = &up->fpsave;
	Inst inst;
	Internal tmp;

	/*
	 * VCMP; ARM v7 arch manual §A8.8.303.
	 * sets only Fpscr condition bits, not the cpu's psr bits.
	 */
	/* op2&1 means compare with 0.0, not rm */
	inst = fpin->inst;
	if (VFPOP2(inst) & 1)
		tmp = fpconst[0];
	else
		tmp = *vfpfmregop(inst);
	/* CMP[FD]:  Fd :: Fm */
	/* CMP[FD]E: Fd :: Fm (with exception); VFPOP3(inst)&2 is the E bit */
	ufp->status &= ~(N|C|Z|V);
	ufp->status |= fcmp(&VFPR(&up->fpsave, fpin->vd), &tmp);
	if(Vfpemudebug)
		print("CMPF\tF%d,F%ld =%#lux\n", fpin->vd, inst & Vfpregmask,
			ufp->status>>28);
	count(&stats.cmp);
}

enum {
	Cvtfix = 1<<2,
};

static void
vfpmovreg(FPsave *ufp, int vd, int vm)
{
	ufp->regs[vd] = ufp->regs[vm];
	count(&stats.movreg);
	if(Vfpemudebug)
		print("MOV[FD]\tF%d, F%d\n", vm, vd);
}

/*
 * understands VFP instruction layout for conversions.
 * operands are mostly (Internal) VFP registers.
 *
 * some forms of VMOV take a CPU register & an FP register for fixing and
 * floating.  fixing is a §306 VCVT to a non-IEEE integer bit pattern in an
 * FP register and a §343 VMOV from that FP register to a CPU register.
 * floating is a §343 VMOV of a non-IEEE integer bit pattern into an FP
 * register and a §306 VCVT of that bit pattern to IEEE FP.  the corresponding
 * Internal representation is set to NaN when an integer is stored in an FP
 * register, the integer is stored in fprp->irepr and fprp->useirepr is set to 1.
 */
static void
vfpemucvt(Ureg *ur, Fpinst *fpin, int op2, int op3)
{
	int vm, vd;
	long l;
	Inst inst;
	Fprepr *fprp;
	FPsave *ufp;
	Internal tmp;

	ufp = &up->fpsave;
	inst = fpin->inst;
	vm = inst & Vfpregmask;
	vd = fpin->vd;
	fprp = &ufp->regs[vd];
	/* op2 is bits 16-19, op3 is bits 6 & 7 */
	switch (op2) {
	case 0:				/* MOV[FD] Fm, Fd */
		/*
		 * VMOV immediate & register.
		 * ARM v7 arch manual §A8.8.339-340.
		 */
		if ((op3 & 1) == 0) {		/* vmov immediate? unused */
#ifdef notyet					/* see _notyet/vfpimmed.c */
			fprp->Internal = vfpfmimmedop(inst);
			fprp->useirepr = 0;
			fprp->irepr = 0;
			if(Vfpemudebug)
				print("MOV[FD]\tC, F%d\n", vd);
#endif
			unimp(ur->pc, inst);
		} else if (op3 == 1)
			vfpmovreg(ufp, vd, vm);
		else
			unimp(ur->pc, inst);
		break;
	case 7:				/* MOVFD, MOVDF */
		/*
		 * VCVT double/single conv.s;
		 * ARM v7 arch manual §A8.8.309.
		 */
		if (op3 == 3)
			/* ignore single precision, so just move */
			vfpmovreg(ufp, vd, vm);
		else
			unimp(ur->pc, inst);
		break;
	case 010:			/* MOVW[DF] unsigned */
		/*
		 * VCVT integer-in-FP-to-floating conv.;
		 * ARM v7 arch manual §A8.8.306.
		 */
		if (op3 != 3)
			unimp(ur->pc, inst);
		/* FLT Fd := Fm */
		/* assume irepr was set previously */
		if ((inst & (1<<7)) == 0)		/* unsigned int? */
			ufp->regs[vm].irepr &= ~0ul;	/* toss high long */
		if(Vfpemudebug)
			print("MOVW[FD]\tF%d, F%d # float %llud\n",
				vm, vd, ufp->regs[vm].irepr);
		fpiv2i(&fprp->Internal, &ufp->regs[vm].irepr);
		fprp->useirepr = 0;
		fprp->irepr = 0;
		count(&stats.cvtflt);
		break;
	case 010|Cvtfix:		/* MOV[FD]W unsigned w rounding */
	case 011|Cvtfix:		/* MOV[FD]W w rounding */
		/*
		 * VCVTR floating-to-integer-in-FP conv.;
		 * ARM v7 arch manual §A8.8.306.
		 */
		if (op3 != 3)
			unimp(ur->pc, inst);
		/* FIX Fd := Fm */
		tmp = VFPR(ufp, vm);
		if (inst & (1<<16))		/* unsigned int? */
			fpii2v(&fprp->irepr, &tmp);
		else {
			fpii2w(&l, &tmp);
			fprp->irepr = (ulong)l;
		}
		fprp->useirepr = 1;		/* Fd is an integer */
		SetQNaN(&fprp->Internal);
		if(Vfpemudebug)
			print("MOV[FD]W\tF%d, F%d =%lld # fix\n",
				vm, vd, fprp->irepr);
		count(&stats.cvtfix);
		break;
	default:
		/*
		 * instructions not generated by 5l, including vcvtb & vcvtt
		 * half-precision nonsense, vcvt floating/fixed conv.s with
		 * number of fractional bits in imm4:i.
		 */
		unimp(ur->pc, inst);
		break;
	}
}

/*
 * emulate single-precision vmov: copy between cpu & fp registers
 * without integer/fp conversion.  assumes the fp register has a
 * non-ieee integer in it (in irepr).
 */
static void
vfpemuvmovs(Ureg *ur, Inst inst)
{
	int rn, rt;
	Fprepr *fprp;
	FPsave *ufp;
	Internal tmp;
	Internal *ip;
	Single s;
	Word w;

	/* §A8.8.343; see §306 VCVT for fix/float interactions */
	rn = VFPREGN(inst);
	rt = VFPREGD(inst);
	ufp = &up->fpsave;
	ip = &VFPR(ufp, rn);
	fprp = &ufp->regs[rn];
	if (inst & Vfpload) {			/* fix Fn to Rt */
		if (fprp->useirepr) {	/* rn is integer result of VCVT fix? */
			s = fprp->irepr;
			count(&stats.movfix);
		} else {
			tmp = *ip;
			fpii2s(&s, &tmp);
		}
		REG(ur, rt) = s;
		if(Vfpemudebug)
			print("MOVF\tF%d, R%d # fix (s)->%ld\n", rn, rt, s);
		count(&stats.fploads);
	} else {				/* float Rt to Fn */
		/* assume later VCVT float will want to use Rt as an integer */
		fprp->irepr = w = REG(ur, rt);
		fprp->useirepr = 1;
		fpiw2i(ip, &w);			/* in case we're wrong */
		if(Vfpemudebug)
			print("MOVF\tR%d, F%d # float copy (s) %ld\n", rt, rn, w);
		count(&stats.fpstores);
	}
}

/* emulate VMSR and VMRS for VFP system register 1 (Fpscr) */
static void
vfpemumsr(Ureg *ur, Fpinst *fpin)
{
	int vd;
	FPsave *ufp = &up->fpsave;

	/* §A8.8.348-349 */
	vd = fpin->vd;
	switch (VFPOP(fpin->inst)) {
	case 0xe:			/* VMSR: write Fpscr */
		ufp->control = REG(ur, vd);
		ufp->status &= (N|C|Z|V);
		ufp->status |= REG(ur, vd) & ~(N|C|Z|V);
		if(Vfpemudebug)
			print("VMSR\tR%d\n", vd);
		break;
	case 0xf:			/* VMRS: read Fpscr */
		if (vd == REGPC) {
			ur->psr &= ~(N|C|Z|V);
			ur->psr |= ufp->status & (N|C|Z|V);
			if(Vfpemudebug)
				print("VMRS\tR%d\t# set cpu cond'n codes %#lo\n",
					vd, ur->psr>>28);
		} else {
			REG(ur, vd) = ufp->status;
			if(Vfpemudebug)
				print("VMRS\tR%d\n", vd);
		}
		break;
	default:
		unimp(ur->pc, fpin->inst);
		break;
	}
}

/* returns true if it recognised a VFP move instruction and emulated it. */
static int
tryvfpmove(Ureg *ur, Fpinst *fpin)
{
	int op1;
	Inst inst;

	inst = fpin->inst;
	if (!(inst & Vfpnproc))
		return 0;		/* must be arithmetic or other */
	op1 = VFPOP(inst);
	switch (fpin->coproc) {
	case CpFP:
		if ((op1 & ~1) == 0xe && VFPOP2(inst) == Fpscr)
			vfpemumsr(ur, fpin);
		else if ((op1 >> 1) == 0)
			vfpemuvmovs(ur, inst);		/* float vmov */
		else
			return 0;			/* unknown */
		break;
	case CpDFP:
		if ((op1 & 0x9) != 8) {
			/* vfpemuvmov(ur, inst);  /* vmov cpu<->vfp unused */
			unimp(ur->pc, inst);
		} else
			return 0;			/* unknown */
		break;
	default:
		return 0;				/* wrong coproc */
	}
	return 1;
}

/*
 * only called to emulate VFP instructions; may make assumptions about
 * unexamined instruction bits.  understands VFP instruction layouts.
 */
static void
vfpemu(Ureg *ur, Fpinst *fpin)
{
	int rn, rd, op, op1, op2, op3;
	uint idx;
	Inst inst;
	FPsave *ufp;
	Internal *fm;

	/* note: would update fault status here if we noted numeric exceptions */
	op = fpin->op;
	inst = fpin->inst;
	if(Vfpemudebug)
		print("%#p: vfp %#8.8lux ", ur->pc, inst);
	if (op == Vfpldst && (VFPOP(inst) & 2) == 0) {
		vfpemuldst(ur, fpin);
		return;
	}
	op1 = VFPOP(inst);
	if (op == Vfpxfer64 && (op1 >> 1) == 2){
		/* vfpemuxfer64(ur, fpin);		/* unused */
		unimp(ur->pc, inst);
	}

	/*
	 * arithmetic and some moves in vfpops[12]; conversions, comparisons,
	 * and other moves are handled separately.  ARM v7 arch manual §A7.5.
	 */
	if (op != Vfparith)
		error("sys: bad vfp arithmetic opcode");
	if (tryvfpmove(ur, fpin))
		return;

	fm = vfpfmregop(inst);		/* assume reg by default */
	rd = VFPREGD(inst);
	op2 = VFPOP2(inst);
	op3 = VFPOP3(inst);
	ufp = &up->fpsave;
	if((op1 & ~4) == 013)		/* monadic, vmov, vcvt, or vcmp? */
		if ((op3 & 1) == 0) {		/* vmov immediate? unsed */
			/* vfpemucvt(ur, fpin, op2, op3); */
			unimp(ur->pc, inst);
		} else if (inst & Vfpnproc)
			error("sys: bad vfp arithmetic opcode");
		else if (op2 >= 4 && op2 <= 5)
			vfpemucmp(fpin);
		else
			vfpemucvt(ur, fpin, op2, op3);
	else {				/* binary ops */
		FP2 *fp;
		idx = VFPDYADOP(op1, op3);
		fp = &vfpops2[idx];
		if(idx >= nelem(vfpops2) || fp->f == nil)
			unimp(ur->pc, inst);
		rn = VFPREGN(inst);
		(*fp->f)(*fm, VFPR(ufp, rn), &VFPR(ufp, rd));
		if(Vfpemudebug)
			print("%s\tF%ld,F%d,F%d\n", fp->name, inst & Vfpregmask,
				rn, rd);
		count(&stats.arith);
	}
}

static void
prstat(char *name, long val)
{
	if (val)
		print("%s:\t%ld\n", name, val);
}

static void
vfpprstats(void)
{
#ifdef MEASURE
	print("vfp emulation:\n");
	prstat("arith",		stats.arith);
	prstat("loadd",		stats.loadd);
	prstat("stored",	stats.stored);
	prstat("cmp",		stats.cmp);
	prstat("cvtfix",	stats.cvtfix);
	prstat("cvtflt",	stats.cvtflt);
	prstat("movfix",	stats.movfix);
	prstat("fploads",	stats.fploads);
	prstat("fpstores",	stats.fpstores);
	prstat("movreg",	stats.movreg);
	prstat("unimp",		stats.unimp);
#else
	print("vfp emulation not instrumented\n");
#endif
}

void (*fpprint)(void) = vfpprstats;

/*
 * VFP emulation above
 */

/*
 * called from fpuemu().  fpin is the broken-out first fp instruction;
 * we reuse it for subsequent fp instructions.
 * returns the number of FP instructions emulated.
 */
int
fpiarm(Ureg *ur, Fpinst *fpin)
{
	int n, isfpinstr;
	FPsave *ufp;

	/*
	 * because all the emulated fp state is in the proc structure,
	 * it need not be saved/restored
	 */
	switch(up->fpstate){
	case FPactive:
	case FPinactive:
		if (m->fpon && havefp())
			error("sys: illegal instruction: "
				"emulated fpu opcode in VFP mode");
		break;
	case FPinit:
		up->fpstate = FPemu;
		ufp = &up->fpsave;
		ufp->control = 0;
		ufp->status = 0x01<<28 | 1<<12; /* sw emulation, alt. C flag */
		for(n = 0; n < Maxfpregs; n++)
			FPAR(ufp, n) = fpconst[0];
		break;
	}

	/* emulate consecutive fp instructions */
	isfpinstr = 1;
	for(n = 0; isfpinstr; n++){
		if(condok(ur->psr, CONDITION(fpin->inst))) {
			if (fpin->coproc == CpOFPA)
				fpaemu(ur, fpin);
			else
				vfpemu(ur, fpin);
			if (fpemudebug)
				delay(10);		/* let uart drain */
		}
		ur->pc += sizeof(Inst);	/* pretend cpu executed the instr */

		isfpinstr = getfpinst(ur->pc, fpin);
	}
	if(fpemudebug)
		print("\n");
	return n;
}
