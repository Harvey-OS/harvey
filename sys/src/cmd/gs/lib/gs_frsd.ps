%    Copyright (C) 2000 Aladdin Enterprises.  All rights reserved.
% 
% This file is part of AFPL Ghostscript.
% 
% AFPL Ghostscript is distributed with NO WARRANTY OF ANY KIND.  No author or
% distributor accepts any responsibility for the consequences of using it, or
% for whether it serves any particular purpose or works at all, unless he or
% she says so in writing.  Refer to the Aladdin Free Public License (the
% "License") for full details.
% 
% Every copy of AFPL Ghostscript must include a copy of the License, normally
% in a plain ASCII text file named PUBLIC.  The License grants you the right
% to copy, modify and redistribute AFPL Ghostscript, but only under certain
% conditions described in the License.  Among other things, the License
% requires that the copyright notice and this notice be preserved on all
% copies.

% $Id: gs_frsd.ps,v 1.4 2000/09/19 18:29:11 lpd Exp $
% Implementation of ReusableStreamDecode filter.
% This file must be loaded after gs_lev2.ps and gs_res.ps.

level2dict begin

% ------ ReusableStreamDecode filter ------ %

/.reusablestreamdecode {	% <source> <dict> .reusablestreamdecode <file>
				% <source> .reusablestreamdecode <file>
		% Collect the filter parameters.
  dup type /dicttype eq { 2 copy } { dup 0 dict } ifelse
  dup .rsdparams
		% Construct the filter pipeline.
		% The very first filter should use the value of CloseSource
		% from the RSD dictionary; all the others should have
		% CloseSource = true.
		% Stack: source dict filters parms
  2 index /CloseSource .knownget not { false } if 5 -1 roll
		% Stack: dict filters parms CloseSource source
  0 1 5 index length 1 sub {
    4 index 1 index get
		% Stack: dict filters parms CloseSource source index filtname
    4 index null eq {
      0 dict
    } {
      4 index 2 index get dup null eq { pop } if
    } ifelse
    3 -1 roll pop exch filter
    exch pop true exch		% set CloseSource for further filters
  } for
		% If AsyncRead is true, try to create the filter directly.
		% Stack: dict filters parms CloseSource source
  4 index /AsyncRead .knownget not { false } if {
    1 index { .reusablestream } .internalstopped
  } {
    null true
  } ifelse {
    pop
		% No luck.  Read the entire contents of the stream now.
    dup type /filetype ne {
		% Make a stream from a procedure or string data source.
      0 () .subfiledecode
    } if
    10 dict exch {
		% Stack: dict filters parms CloseSource contdict file
      dup 1000 string readstring
      3 index dup length 4 -1 roll put not { exit } if
    } loop pop
		% Concatenate the contents into one big string.
		% Stack: dict filters parms CloseSource contdict
    0 1 index { length exch pop add } forall
    .bigstring exch {
		% Stack: dict filters parms CloseSource string index substring
      exch 1000 mul exch 2 index 3 1 roll putinterval
    } forall
		% Now create the stream on the string.
    1 index .reusablestream
  } if
		% We created the stream successfully: clean up.
  4 { exch pop } repeat
  1 index type /dicttype eq { exch pop } if exch pop
} odef

filterdict /ReusableStreamDecode /.reusablestreamdecode load put

end			% level2dict
