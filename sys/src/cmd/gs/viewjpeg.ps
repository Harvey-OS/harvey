%! viewjpeg.ps   Copyright (C) Thomas Merz 1994
%
% View JPEG files with Ghostscript
%
% This PostScript code relies on level 2 features.
%
% Only JPEG baseline and extended sequential 
% coded images are supported (as defined in PostScript level 2)
%
% Author's address:
% ------------------------------+
% {(pstack exec quit) = flush } |    Thomas Merz
% pstack exec quit              |    InterFace Connection GmbH
% ------------------------------+    phone: +49/89/6 10 49-211
% Leipziger Str. 16                  fax:   +49/89/6 10 49-85
% D-82008 Unterhaching, FRG          internet: thomas@ifconnection.de

/languagelevel where {pop languagelevel 2 lt}{true} ifelse {
  (JPEG needs PostScript Level 2!\n) print flush stop
} if

/JPEGdict 20 dict def
JPEGdict begin

/NoParamMarkers [	% JPEG markers without additional parameters
    16#D0 16#D1 16#D2 16#D3 16#D4 16#D5 16#D6 16#D7 16#D8 16#01
] def

/NotSupportedMarkers [ 	% JPEG markers not supported by PostScript level 2
    16#C1 16#C2 16#C3 16#C5 16#C6 16#C7 16#C8 
    16#C9 16#CA 16#CB 16#CD 16#CE 16#CF
] def

% Names of color spaces
/ColorSpaceNames << /1 /DeviceGray /3 /DeviceRGB /4 /DeviceCMYK >> def

% read one byte from file F
% - ==> int --or-- stop context
/NextByte { 
    F read not { (Read error in ViewJPEG!\n) print flush stop } if
} bind def

/SkipSegment {	% read two bytes and skip that much data
    NextByte 8 bitshift NextByte add 2 sub { NextByte pop } repeat
} bind def

% read width, height, and # of components from JPEG markers
% and store in dict
/readJPEGmarkers {	% - ==> dict --or-- stop context
    5 dict begin

    { % loop: read JPEG marker segments until we find baseline/ext. seq.
      % markers or EOF
	NextByte
	16#FF eq {				% found marker
	    /markertype NextByte def
	    % baseline or extended sequential?
	    markertype dup 16#C0 eq exch 16#C1 eq or {
		NextByte pop NextByte pop	% segment length
		NextByte 8 ne {
		    (Error: not 8 bits per component!\n) print flush stop 
		} if

		% Read crucial image parameters
		/height NextByte 8 bitshift NextByte add def
		/width NextByte 8 bitshift NextByte add def
		/colors NextByte def

		DEBUG { currentdict { exch == == } forall flush } if
		exit
	    } if

	    % detect several segment types which are not compatible with PS
	    NotSupportedMarkers {
		markertype eq {
		    (Marker ) print markertype == 
		    (not supported!\n) print flush stop
		} if 
	    } forall 

	    % Skip segment if marker has parameters associated with it
	    true NoParamMarkers { markertype eq {pop false exit} if } forall 
	    { SkipSegment } if
	} if
    } loop

    currentdict dup /markertype undef
    end
} bind def

end	% JPEGdict

% read image parameters from JPEG file and display the image
/viewJPEG {		% <file|string> ==> -
    save 
    JPEGdict begin
    /saved exch def
    /scratch 1 string def
    dup type /stringtype eq { (r) file } if
    /F exch def

    readJPEGmarkers begin
    F 0 setfileposition		% reset file pointer

    % We use the whole clipping area for the image (at least in one dimension)
    gsave clippath pathbbox grestore
    /ury exch def /urx exch def
    /lly exch def /llx exch def

    llx lly translate
    width height scale

    % use whole width or height, whichever is appropriate
    urx llx sub width div ury lly sub height div
    2 copy gt { exch } if pop		% min
    dup scale
    ColorSpaceNames colors scratch cvs get setcolorspace

    % prepare image dictionary
    << /ImageType 1
       /Width width
       /Height height
       /ImageMatrix [ width 0 0 height neg 0 height ]
       /BitsPerComponent 8
       /Decode [ colors { 0 1 } repeat ]
       /DataSource F /DCTDecode filter
    >> image

    end		% image parameter dictionary

    saved end restore
} bind def

% usage example:
(jpeg-5/testimg.jpg) viewJPEG
