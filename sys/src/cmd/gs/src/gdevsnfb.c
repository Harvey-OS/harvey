/*
 * This file is part of the UCB release of Plan 9. It is subject to the license
 * terms in the LICENSE file found in the top-level directory of this
 * distribution and at http://akaros.cs.berkeley.edu/files/Plan9License. No
 * part of the UCB release of Plan 9, including this file, may be copied,
 * modified, propagated, or distributed except according to the terms contained
 * in the LICENSE file.
 */

/* Copyright (C) 1989, 1990, 1991, 1996, 1998 Aladdin Enterprises.  All rights
  reserved.

  This software is provided AS-IS with no warranty, either express or
  implied.

  This software is distributed under license and may not be copied,
  modified or distributed except as expressly authorized under the terms
  of the license contained in the file LICENSE in this distribution.

  For more information about licensing, please refer to
  http://www.ghostscript.com/licensing/. For information on
  commercial licensing, go to http://www.artifex.com/licensing/ or
  contact Artifex Software, Inc., 101 Lucas Valley Road #110,
  San Rafael, CA  94903, U.S.A., +1(415)492-9861.
*/

/* $Id: gdevsnfb.c,v 1.5 2002/02/21 22:24:52 giles Exp $*/
/* Sony News frame buffer driver for GhostScript */
#include "gdevprn.h"
#define prn_dev ((gx_device_printer*)dev) /* needed in 5.31 et seq */
/*#include <sys/types.h> problems with ushort! */
typedef char* caddr_t;
typedef int32_t off_t;
#include <sys/uio.h>
#include <newsiop/framebuf.h>

/* The device descriptor */
private
dev_proc_open_device(sonyfb_open);
private
dev_proc_output_page(sonyfb_output_page);
private
dev_proc_close_device(sonyfb_close);
private
gx_device_procs sonyfb_procs =
    prn_procs(sonyfb_open, sonyfb_output_page, sonyfb_close);
const gx_device_printer far_data gs_sonyfb_device =
    prn_device(sonyfb_procs, "sonyfb", 102.4, /* width_10ths */
               103.2,                         /* height_10ths */
               100,                           /* x_dpi */
               100,                           /* y_dpi */
               0, 0, 0, 0,                    /* margins */
               1, 0);

private
int fb_file = -1;
sPrimRect prect;

private
int
sonyfb_open(gx_device* dev)
{
	sScrType stype;

	if(fb_file < 0)
		if((fb_file = open("/dev/fb", 2)) < 0)
			perror("open failed");
		else if(ioctl(fb_file, FBIOCGETSCRTYPE, &stype) < 0)
			perror("ioctl failed");
		else
			prect.rect = stype.visiblerect;

	return gdev_prn_open(dev);
}

private
int
sonyfb_close(gx_device* dev)
{
	if(fb_file >= 0) {
		close(fb_file);
		fb_file = -1;
	}
	return gdev_prn_close(dev);
}

#define FRAME_WIDTH 1024

/* Send the page to the printer. */
private
int
sonyfb_output_page(gx_device* dev, int num_copies, int flush)
{
	int l, i, byte_width, height;
	unsigned char* bm, *fbs, *fb;

	byte_width = (dev->width + 7) / 8;
	height = dev->height;
	bm = (typeof(bm))prn_dev->mem.base;

	prect.refPoint.x = 0;
	prect.refPoint.y = 0;
	prect.ptnRect = prect.rect;

	prect.ptnBM.type = BM_MEM;
	prect.ptnBM.depth = 1;
	prect.ptnBM.width = (byte_width + 1) / 2;
	prect.ptnBM.rect.origin.x = 0;
	prect.ptnBM.rect.origin.y = 0;
	prect.ptnBM.rect.extent.x = byte_width * 8; /* width in 16bit words */
	prect.ptnBM.rect.extent.y = height;
	prect.ptnBM.base = (typeof(prect.ptnBM.base))bm;

	prect.fore_color = 1;
	prect.aux_color = 0;
	prect.planemask = FB_PLANEALL;
	prect.transp = 0;
	prect.func = BF_S;
	prect.clip = prect.rect;
	prect.drawBM.type = BM_FB;
	prect.drawBM.depth = 1;
	prect.drawBM.width = (prect.rect.extent.x + 15) / 16;
	prect.drawBM.rect = prect.rect;
	prect.drawBM.base = 0;

	if(ioctl(fb_file, FBIOCRECTANGLE, &prect) < 0)
		perror("rect ioctl failed");

	return gx_finish_output_page(dev, num_copies, flush);
}
