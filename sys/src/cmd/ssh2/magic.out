cipher3des.c:18: uchar key[3][8];
cipher3des.c:44: "3des-cbc",
cipher3des.c:45: 8,
cipheraes.c:24: setupAESstate(&cs->state, c->s2cek, bits/8, c->s2civ);
cipheraes.c:26: setupAESstate(&cs->state, c->c2sek, bits/8, c->c2siv);
cipheraes.c:34: return initaes(c, dir, 128);
cipheraes.c:40: return initaes(c, dir, 192);
cipheraes.c:46: return initaes(c, dir, 256);
cipherblowfish.c:22: for(i = 0; i < 16; ++i)
cipherblowfish.c:25: for(i = 0; i < 16; ++i)
cipherblowfish.c:28: for(i = 0; i < 8; ++i)
cipherblowfish.c:31: for(i = 0; i < 8; ++i)
cipherblowfish.c:39: setupBFstate(&cs->state, c->s2cek, 16, c->s2civ);
cipherblowfish.c:41: setupBFstate(&cs->state, c->c2sek, 16, c->c2siv);
cipherblowfish.c:62: 8,
cipherrc4.c:21: setupRC4state(&cs->state, c->s2cek, 16);
cipherrc4.c:23: setupRC4state(&cs->state, c->c2sek, 16);
cipherrc4.c:41: 8,
dh.c:21: "29024E088A67CC74020BBEA63B139B22514A08798E3404DD"
dh.c:28: * 2048-bit MODP group (id 14) from RFC 3526
dh.c:32: "29024E088A67CC74020BBEA63B139B22514A08798E3404DD"
dh.c:37: "83655D23DCA3AD961C62F356208552BB9ED529077096966D"
dh.c:38: "670C354E4ABC9804F1746C08CA18217C32905E462E36CE3B"
dh.c:41: "15728E5A8AACAA68FFFFFFFFFFFFFFFF";
dh.c:60: two = strtomp("2", nil, 10, nil);
dh.c:61: p1 = strtomp(group1p, nil, 16, nil);
dh.c:62: p14 = strtomp(group14p, nil, 16, nil);
dh.c:103: myrsakey.pub.n = strtomp(p+3, nil, 16, nil);
dh.c:114: myrsakey.pub.ek = strtomp(p+4, nil, 16, nil);
dh.c:127: myrsakey.dk = strtomp(p+5, nil, 16, nil);
dh.c:170: mydsskey.pub.p = strtomp(p+3, nil, 16, nil);
dh.c:177: mydsskey.pub.q = strtomp(p+3, nil, 16, nil);
dh.c:184: mydsskey.pub.alpha = strtomp(p+7, nil, 16, nil);
dh.c:191: mydsskey.pub.key = strtomp(p+5, nil, 16, nil);
dh.c:202: mydsskey.secret = strtomp(p+9, nil, 16, nil);
dh.c:233: n = nb - (nelem(sha1der) + SHA1dlen) - 3;
dh.c:257: n = (nbit + 7) / 8;
dh.c:260: /* Compute s: RFC 3447 */
dh.c:276: auth_rpc(ar, "start", "role=sign proto=rsa", 19) != ARok ||
dh.c:319: n = (nbit + 7) / 8;
dh.c:321: /* Compute s: RFC 3447 */
dh.c:324: s = mpnew(1024);
dh.c:341: buf = emalloc9p(Blobsz / 2);
dh.c:343: p = (char *)get_string(nil, (uchar *)sig, buf, Blobsz / 2, nil);
dh.c:397: uchar sstr[2*SHA1dlen];
dh.c:415: auth_rpc(ar, "start", "role=sign proto=dsa", 19) != ARok ||
dh.c:427: add_block(sig, sstr, 2*SHA1dlen);
dh.c:442: return dh_server(c, pack1, p1, 1024);
dh.c:448: return dh_server(c, pack1, p14, 2048);
dh.c:465: y = mprand(nbit / 8, genrandom, nil);
dh.c:482: /* Compute H: RFC 4253 */
dh.c:561: c->e = mpnew(1024);
dh.c:566: c->x = mprand(128, genrandom, nil);
dh.c:588: keymbox.msg = smprint("b%04ld%s", strlen(newkey), newkey);
dh.c:597: keymbox.msg = smprint("%c%04ld%s", n == NoKeyFile || n == NoKey?
dh.c:607: keymbox.msg = smprint("f%04ld%s", strlen(newkey), newkey);
dh.c:633: return -2;
dh.c:679: char buf[10];
dh.c:694: q += nhgetl(q) + 4;
dh.c:697: k = mpnew(1024);
dh.c:700: /* Compute H: RFC 4253 */
dh.c:731: q += nhgetl(q) + 4;
dh.c:743: case -2:
dh.c:747: keymbox.msg = smprint("f%04ld%s", strlen(newkey), newkey);
dh.c:751: keymbox.msg = smprint("f%04ld%s", strlen(newkey), newkey);
dh.c:778: e = mpnew(2048);
dh.c:779: x = mprand(256, genrandom, nil);
dh.c:810: char buf[82], *bp, *be;			/* magic 82 */
dh.c:814: /* Compute 40 bytes (320 bits) of keys: each alg can use what it needs */
dh.c:882: for (n = 0, bp = buf; n < SHA1dlen*2; ++n)
dh.c:887: for (n = 0, bp = buf; n < SHA1dlen*2; ++n)
dh.c:892: for (n = 0, bp = buf; n < SHA1dlen*2; ++n)
dh.c:897: for (n = 0, bp = buf; n < SHA1dlen*2; ++n)
dial.c:14: Maxstring	= 128,
dial.c:15: Maxpath		= 256,
dial.c:17: Maxcsreply	= 64*80,	/* this is probably overly generous */
dial.c:22: Maxconnms	= 2*60*1000,	/* 2 minutes */
dial.c:171: char *fields[5];			/* pid + 3 times + error */
dial.c:177: if (n < 4)
dial.c:188: strncpy(conn->err, fields[4], sizeof conn->err);
dial.c:209: char exitsts[2*ERRMAX];
dial.c:384: bleft = sizeof dp->addrlist - 2;	/* 2 is room for \n\0 */
dial.thread.c:22: Defstksize	= 8192,
dial.thread.c:24: Maxstring	= 128,
dial.thread.c:25: Maxpath		= 256,
dial.thread.c:27: Maxcsreply	= 64*80,	/* this is probably overly generous */
dial.thread.c:32: Maxconnms	= 2*60*1000,	/* 2 minutes */
dial.thread.c:57: int	kidthrids[64];		/* one per addr; ought to be enough */
dial.thread.c:387: bleft = sizeof dp->addrlist - 2;	/* 2 is room for \n\0 */
netssh.c:48: PKA *pkas[3];
netssh.c:71: char uid[32];
netssh.c:173: case '9':
netssh.c:205: keymbox.mchan = chancreate(4, 0);
netssh.c:255: werrstr("bad length in 9P2000 message header");
netssh.c:279: netsshsrv.tree = alloctree(uid, uid, 0777, nil);
netssh.c:280: rootfile = createfile(netsshsrv.tree->root, "ssh", uid, 0555|DMDIR,
netssh.c:282: clonefile = createfile(rootfile, "clone", uid, 0666, (void*)Qclone);
netssh.c:283: ctlfile = createfile(rootfile, "ctl", uid, 0666, (void*)Qctl);
netssh.c:284: keysfile = createfile(rootfile, "keys", uid, 0600, (void *)Qreqrem);
netssh.c:301: d.mode = 0666;
netssh.c:326: char buf[32];
netssh.c:343: /* should use dial(2) instead of diddling /net/tcp */
netssh.c:451: /* should use dial(2) instead of diddling /net/tcp */
netssh.c:537: hnputl(p2->payload + 5, c->chans[i]->id);
netssh.c:538: hnputl(p2->payload + 9, Maxpayload);
netssh.c:539: hnputl(p2->payload + 13, Maxrpcbuf);
netssh.c:540: p2->rlength = 18;
netssh.c:587: if (sc->rwindow < 16*1024) {		/* magic.  half-way, maybe? */
netssh.c:594: hnputl(p->payload+5, Maxpayload);
netssh.c:595: p->rlength += 8;
netssh.c:687: n = pread(c->ctlfd, buf, 10, 0); // magic 10
netssh.c:721: n = pread(c->ctlfd, buf, 10, 0); /* magic 10 */
netssh.c:809: n = ioread(io, c->ctlfd, buf, 10); /* magic 10 */
netssh.c:985: * should use dial(2) instead of doing it by hand.
netssh.c:987: sshdebug(c, "tcp connect %s %s", toks[1], ntok > 3? toks[2]: "");
netssh.c:988: return fprint(c->ctlfd, "connect %s %s", toks[1], ntok > 3? toks[2]: "");
netssh.c:995: char *attrs[5];
netssh.c:998: if (ntok < 3 || ntok > 4)
netssh.c:1004: c->user = estrdup9p(toks[2]);
netssh.c:1007: if (ntok == 4 && strcmp(toks[1], "k") == 0) {
netssh.c:1014: c->password = estrdup9p(toks[3]);
netssh.c:1024: attrs[2] = smprint("user=%s", c->user);
netssh.c:1025: attrs[3] = smprint("sys=%s", c->remote);
netssh.c:1029: if (ntok == 3)
netssh.c:1030: c->authkey = factlookup(4, 2, attrs);
netssh.c:1032: attrs[4] = toks[3];
netssh.c:1033: c->authkey = factlookup(5, 2, attrs);
netssh.c:1035: free(attrs[2]);
netssh.c:1036: free(attrs[3]);
netssh.c:1076: char *tcpconn2, *buf, *toks[4];
netssh.c:1107: if (ntok < 2)
netssh.c:1114: if (ntok < 2)
netssh.c:1117: * should use dial(2) instead of doing it by hand.
netssh.c:1127: pkas[2] = nil;
netssh.c:1157: /* should use dial(2) instead of diddling /net/tcp */
netssh.c:1183: add_string(p, toks[2]);
netssh.c:1190: fprint(c->ctlfd, "reject %s %s", buf, toks[2]);
netssh.c:1267: char *cmd, *q, *buf, *toks[4];
netssh.c:1282: if (r->ifcall.count <= 10)
netssh.c:1283: buf = emalloc9p(10 + 1);
netssh.c:1353: for (n = 2; n < ntok; ++n) {
netssh.c:1392: p->rlength += 4;
netssh.c:1409: * called clunk.  But if there are no other references, a 9P Tclunk
netssh.c:1481: p->rlength += 4;
netssh.c:1600: c->dir = createfile(rootfile, buf, uid, 0555|DMDIR,
netssh.c:1602: c->clonefile = createfile(c->dir, "clone", uid, 0666,
netssh.c:1604: c->ctlfile = createfile(c->dir, "ctl", uid, 0666,
netssh.c:1606: c->datafile = createfile(c->dir, "data", uid, 0666,
netssh.c:1608: c->listenfile = createfile(c->dir, "listen", uid, 0666,
netssh.c:1610: c->localfile = createfile(c->dir, "local", uid, 0444,
netssh.c:1612: c->remotefile = createfile(c->dir, "remote", uid, 0444,
netssh.c:1614: c->statusfile = createfile(c->dir, "status", uid, 0444,
netssh.c:1616: c->tcpfile = createfile(c->dir, "tcp", uid, 0444,
netssh.c:1658: sc->dir = createfile(c->dir, buf, uid, 0555|DMDIR,
netssh.c:1660: sc->ctl = createfile(sc->dir, "ctl", uid, 0666,
netssh.c:1662: sc->data = createfile(sc->dir, "data", uid, 0666,
netssh.c:1664: sc->listen = createfile(sc->dir, "listen", uid, 0666,
netssh.c:1666: sc->request = createfile(sc->dir, "request", uid, 0666,
netssh.c:1668: sc->status = createfile(sc->dir, "status", uid, 0444,
netssh.c:1670: sc->tcp = createfile(sc->dir, "tcp", uid, 0444,
netssh.c:1685: sc->inchan = chancreate(4, 0);
netssh.c:1689: sc->reqchan = chancreate(4, 0);
netssh.c:1789: if (n < 5)		/* can't be a valid SSH id string */
netssh.c:1796: if (n < 5)		/* can't be a valid SSH id string */
netssh.c:1852: 0 && c->role == Client && strncmp(remid, "SSH-2", 5) != 0 &&
netssh.c:1853: strncmp(remid, "SSH-1.99", 8) != 0) {
netssh.c:1950: if (n < 5) {		/* can't be a valid SSH id string */
netssh.c:1958: strncmp(path, "SSH-2", 5) != 0 &&
netssh.c:1959: strncmp(path, "SSH-1.99", 8) != 0) {
netssh.c:1996: /* should use hangup in dial(2) instead of diddling /net/tcp */
netssh.c:1999: iowrite(io, fd, "hangup", 6);
netssh.c:2021: for (i = 0; i < 16; ++i)
netssh.c:2024: add_packet(c->skexinit, buf, 16);		/* cookie */
netssh.c:2060: memset(buf, 0, 5);
netssh.c:2061: add_packet(c->skexinit, buf, 5);
netssh.c:2091: get_string(p, p->payload + 5, buf, Arbbufsz, nil);
netssh.c:2101: memmove(c->c2siv, c->nc2siv, SHA1dlen*2);
netssh.c:2102: memmove(c->s2civ, c->ns2civ, SHA1dlen*2);
netssh.c:2103: memmove(c->c2sek, c->nc2sek, SHA1dlen*2);
netssh.c:2104: memmove(c->s2cek, c->ns2cek, SHA1dlen*2);
netssh.c:2105: memmove(c->c2sik, c->nc2sik, SHA1dlen*2);
netssh.c:2106: memmove(c->s2cik, c->ns2cik, SHA1dlen*2);
netssh.c:2228: add_block(p2, p->payload + 5, 4);
netssh.c:2229: hnputl(p2->payload + p2->rlength - 1, 4);
netssh.c:2230: p2->rlength += 4;
netssh.c:2253: get_string(p, p->payload + 5, buf, Arbbufsz, nil);
netssh.c:2262: get_string(p, p->payload + 2, buf, Arbbufsz, nil);
netssh.c:2296: ch->twindow = nhgetl(q+4);
netssh.c:2322: ch->otherid = nhgetl(p->payload+5);
netssh.c:2323: ch->twindow = nhgetl(p->payload+9);
netssh.c:2337: ch->twindow += nhgetl(p->payload + 5);
netssh.c:2351: pl->rem = nhgetl(p->payload + 5);
netssh.c:2352: pl->st = pl->pack->payload + 9;
netssh.c:2354: pl->rem = nhgetl(p->payload + 9);
netssh.c:2355: pl->st = pl->pack->payload + 13;
netssh.c:2383: p2->rlength += 4;
netssh.c:2408: q = get_string(p, p->payload+5, buf, Arbbufsz, nil);
netssh.c:2415: memmove(pl->pack->payload + n, q + 1, p->rlength - (11 + n-2));
netssh.c:2416: pl->rem = p->rlength - 11 + 2;
netssh.c:2455: nb = 4;
netssh.c:2474: np = ioreadn(c->rio, c->datafd, p->nlength + nb, p->rlength + 4 - nb);
netssh.c:2476: nm = ioreadn(c->rio, c->datafd, p->nlength + p->rlength + 4,
netssh.c:2477: SHA1dlen);		/* SHA1dlen was magic 20 */
netssh.c:2491: /* SHA1dlen was magic 20 */
netssh.c:2492: if (np != p->rlength + 4 - nb || c->inmac != -1 && nm != SHA1dlen) {
netssh.c:2497: p->rlength = n - 4;
netssh.c:2528: get_string(p, p->payload + 5, buf, Arbbufsz, nil);
netssh.c:2539: case -2:
netssh.c:2599: q = p->payload + 17;
netssh.c:2698: q = p->payload + 17;
netssh.c:2798: cap = emalloc9p(fromtosz + sizeof(rand)*3 + 1);
netssh.c:2799: snprint(cap, fromtosz + sizeof(rand)*3 + 1, "%s@%s", from, to);
netssh.c:2802: enc64(key, sizeof(rand)*3, rand, sizeof(rand));
netssh.c:2845: werrstr("Password mismatch 2");
netssh.c:2871: char method[32];
netssh.c:2934: char key1[DESKEYLEN], key2[DESKEYLEN], method[32];
netssh.c:3038: ek = strtomp(r+4, nil, 16, nil);
netssh.c:3039: nk = strtomp(s+3, nil, 16, nil);
netssh.c:3130: if (c->clonefile->ref <= 2 && c->ctlfile->ref <= 2 &&
netssh.c:3131: c->datafile->ref <= 2 && c->listenfile->ref <= 2 &&
netssh.c:3132: c->localfile->ref <= 2 && c->remotefile->ref <= 2 &&
netssh.c:3133: c->statusfile->ref <= 2)
pubkey.c:12: Arbsz =	256,
pubkey.c:22: n = strtoul(s, &p, 10);
pubkey.c:33: n = strtoul(s, &p, 10);
pubkey.c:79: if(parsepubkey(s, key, sp, 10) == 0 ||
pubkey.c:80: parsepubkey(s, key, sp, 16) == 0)
pubkey.c:164: Bprint(bw, "%s %d %.10M %.10M\n",
pubkey.c:169: Bprint(bw, "%s %d %.10M %.10M\n", host, mpsignif(hostkey->n),
pubkey.c:213: fd = create(keyfile, OWRITE, 0666);
pubkey.c:220: if(seek(fd, 0, 2) >= 0 &&
pubkey.c:221: fprint(fd, "%s %d %.10M %.10M\n", host, mpsignif(key->n),
rsa2ssh2.c:54: e = strtomp(ep+4, nil, 16, nil);
rsa2ssh2.c:55: n = strtomp(np+3, nil, 16, nil);
rsa2ssh2.c:61: sysfatal("base-64 encoding failed\n");
ssh.c:131: oalarm = alarm(5*1000);		/* don't get stuck here */
ssh.c:163: //		for (fd = 3; fd < 40; fd++)
ssh.c:219: if (buf[n-1] == ('u' & 037))
ssh.c:251: write(kconsfd, buf+5, n);
ssh.c:257: write(kconsfd, buf+5, n);
ssh.c:265: seek(keyfd, 0, 2);
ssh.c:266: if (readn(keyfd, buf, 5) <= 0)
ssh.c:268: buf[5] = 0;
ssh.c:269: n = strtol(buf+1, nil, 10);
ssh.c:270: n = readn(keyfd, buf+5, n);
ssh.c:273: buf[n+5] = 0;
ssh.c:278: fprint(kconsfd, "%s\n", buf+5);
ssh.c:292: if (size < 6)
ssh.c:307: n = read(keyfd, buf, 5);		/* reading /net/ssh/keys */
ssh.c:310: buf[5] = 0;
ssh.c:311: n = strtol(buf+1, nil, 10);
ssh.c:312: n = readn(keyfd, buf+5, n);
ssh.c:313: buf[n+5] = 0;
ssh.c:319: fprint(kconsfd, "%s\n", buf+5);
ssh.c:405: ds = netmkaddr(remote, dir, "22");		/* tcp port 22 is ssh */
ssh.c:578: char buf[64];
ssh.c:582: return strlen(buf) >= 9 && strcmp(buf+strlen(buf)-9, "/dev/cons") == 0;
sshsession.c:223: errfd = 2;
sshsession.c:406: q += 4;
sshsession.c:420: q += 4;
sshsession.c:470: dup(datafd, 2);
transport.c:42: p->rlength += 4;
transport.c:50: *data += 4;
transport.c:68: p->rlength += 4;
transport.c:77: uchar nn[4];
transport.c:82: memmove(q, nn, 4);
transport.c:83: memmove(q+4, s, n);
transport.c:84: p->rlength += n + 4;
transport.c:95: q += 4;
transport.c:115: n = mptobe(x, q + 4, Maxpktpay - p->rlength + 1 - 4, nil);
transport.c:116: if(q[4] & 0x80){
transport.c:117: memmove(q + 5, q + 4, n);
transport.c:118: q[4] = 0;
transport.c:122: p->rlength += n + 4;
transport.c:128: return betomp(q + 4, nhgetl(q), nil);
transport.c:139: blklen = 8;
transport.c:145: if(blklen < 8)
transport.c:146: blklen = 8;
transport.c:149: n2 = blklen - (n1 + 5) % blklen;
transport.c:150: if(n2 < 4)
transport.c:162: memmove(buf + 4, p->nlength, p->rlength + 4);
transport.c:163: hmac_sha1(buf, p->rlength + 8, c->outik, maclen, q, nil);
transport.c:167: cryptos[c->encrypt]->encrypt(c->enccs, p->nlength, p->rlength + 4);
transport.c:173: return p->rlength + 4 + maclen;
transport.c:189: nb = 4;
transport.c:193: p->rlength -= SHA1dlen;			/* was magic 20 */
transport.c:197: p->rlength + 4 - nb);
transport.c:201: memmove(buf + 4, p->nlength, nlength + 4);
transport.c:202: hmac_sha1(buf, nlength + 8, c->inik, SHA1dlen, rmac, nil);
transport.c:227: if(i % 16 == 15)
transport.c:229: if(q - buf > Copybufsz - 4){
