# This is the sam package.
# To extract it, run /bin/sh on the part below --Cut Here--
# in a directory where the directory . exists
# or can be made with mkdir.
#
#--Cut Here--
if test -d . ; then echo . exists
else echo mkdir .; mkdir . ; fi
if test -d ./doc ; then echo ./doc exists
else echo mkdir ./doc; mkdir ./doc ; fi
if test -d ./libXg ; then echo ./libXg exists
else echo mkdir ./libXg; mkdir ./libXg ; fi
if test -d ./libframe ; then echo ./libframe exists
else echo mkdir ./libframe; mkdir ./libframe ; fi
if test -d ./sam ; then echo ./sam exists
else echo mkdir ./sam; mkdir ./sam ; fi
if test -d ./samterm ; then echo ./samterm exists
else echo mkdir ./samterm; mkdir ./samterm ; fi
echo ./README
sed s/.// > ./README <<'//GO.SYSIN DD ./README'
-This is an X11 version of Rob Pike's editor, sam.  Documentation describing
-its use and construction are provided in subdirectory doc.  The file doc/sam.1
-contains the manual page; doc/sam.tut.ms is a tutorial that can be
-formatted with troff -ms.  It relies on the presence of fonts named
-CW and CS; if these fonts are not available on your system, change
-the string \f(CW on line 14 to \fB and the string \f(CS on line 19 to \fI.
-Other files in the doc directory contain manual pages for the library
-packages used by sam.
-
-Sam is composed of two programs: sam itself, which does the command processing
-and file manipulation, and samterm, which does the display and user interaction.
-It is possible to run sam on one machine and samterm on another, connected via rsh.
-
-This version of sam is based on the Plan 9 implementation.  As such, its
-design and expression reflects the functionality of the Plan 9 environment;
-most notably, character data is represented internally with 16-bit values called
-Runes.  Header file libframe/u.h and source files libframe/misc.c,
-libframe/rune.c, sam/unix.c and samterm/unix.c contain the code that insinuates
-sam into the unix world.
-
-Sam requires an ANSI/Posix-compatible C compiler and libraries.  We have
-found that some commercial compilers which claim to meet this standard are
-deficient.  For our sanity, we only port sam to the standard; it is up to
-you to modify it for non-standard aspects of your local environment.
-Hints for some non-standard systems are provided at the end of this file.
-
-The typedefs for uchar, ushort, and ulong defined in libframe/u.h, may conflict
-with definitions in system include file <sys/types.h> on some systems.
-If this occurs, remove the offending definitions from libframe/u.h.
-
-The distribution consists of five directories:
-
-	sam - The source for sam.  It loads against libframe to pick
-		up some utility routines.  Sam does not use the frame
-		software, samterm does.
-
-	samterm - The source for samterm.  It loads against libframe,
-		libXg, and your local X11 libraries.
-
-	libframe - The source for the frame library and some general utility
-		modules.  Header file u.h provides much of the interface
-		between sam and the local environment.  It is included in
-		every source file of sam and samterm.  This library is used
-		by both sam and samterm so it must be made first.
-	
-	libXg - The source code of the graphics library.  Sam's graphics
-		operations are implemented by Plan 9 libg functions.  This
-		library emulates those functions using X11 operations.
-		You might find libXg to be independently useful to tame the
-		horrors of X11 programming.  You can put it anywhere; the
-		samterm makefiles assume it is in ../libXg. libXg must
-		be made before samterm.
-
-	doc - The documentation for sam and the libraries.
-
-Each source directory contains makefiles for several typical architectures.
-The master makefile in the top directory builds the subdirectories in proper order.
-
-Most customization effort is confined to configuring the makefiles.
-You can usually minimize your work by copying the makefile for
-your architecture to Makefile and then editing a couple of lines.
-For example, to install sam on a Sun, go to each source subdirectory,
-copy Make.sun to Makefile, and customize each Makefile.
-
-Most of the time only the makefiles need configuration.  Occasionally, it may
-be necessary to twiddle some of the macros and pre-processor magic in
-libframe/u.h.  In especially unusual cases, you may have to massage
-system-dependent code in files libframe/misc.c, sam/unix.c, or samterm/unix.c.
-Finally, systems with non-standard compilers or libraries may require
-minor modifications to any or all of the source files.
-
-Variables in each makefile define most configuration-dependent parameters; each
-is explained by a comment in the makefile.  The RSAMNAME variable in
-sam/Makefile contains the name of the sam executable; this is only used when
-executing sam remotely.  If sam is stored in the same path on every machine in
-your network or you use symbolic links to make it look like it is, this variable
-should specify the full path name of the executable. If sam resides in various
-directories on different machines, you've got a problem.  The best strategy is to
-simply set the name of the file containing sam (usually, "sam") without a path
-component and rely on the users to set the directory in their PATH on the remote
-system.  Unfortunately, this fails if the Berkeley rsh is used as the remote execution
-agent because it neglects to evaluate the user's profile in some situations.
-
-After configuring the makefiles change to the top-level directory and type "make".
-Typing "make install" installs sam and samterm in their permanent homes.
-
-During testing, the path of samterm may be specified using the -t command line
-option to sam.  Similarly, the path of sam itself may be specified using the
--s command line option; this is handy for testing the remote execution feature.
-
-You may want to install Sam.ad as "Sam" in the system application
-defaults library (which will have some name like /usr/lib/X11/app-defaults)
-or your own home directory, if you don't have permission to write in app-defaults.
-Sam.ad can be edited to give default values for things like the starting height
-and width, the font, and the foreground and background colors.  Currently,
-only the -geom X11 parameter can be specified on the command line.  New X11
-parameters can be easily added by including the first character of the parameter
-in the switch statement in main() in file sam/sam.c.  Valid parameter strings
-are passed to samterm and then directly to X11 for interpretation.
-
-This distribution has been successfully made on the following configurations.
-If it works on another, please tell me.  If it needed changes, please mail me
-diffs of the changes and I'll try to incorporate them.
-
-OS			X11 Version	Makefile defs and other notes
-
-Irix 4.0.1		R5		OS=-DIRIX -ansiposix
-					RXPATH=/usr/bsd/rsh
-					RANLIB=:
-SunOs 4.1.1		R5		OS=-DSUNOS
-					RXPATH=/usr/ucb/rsh
-					XLIBS=-L/usr/openwin/lib -lXt -lX11
-					  (if not in /usr/lib/libXt.a, etc.)
-					RANLIB=ranlib
-Mips 4.5.2		Unknown		OS=-DUMIPS
-					RXPATH=/usr/ucb/rsh
-					XLIBS=-lXt -lX11 -lbsd
-
-Bob Flandrena, bobf@research.att.com
-Howard Trickey, howard@research.att.com
-
------------------------------------------------------------------------------------
-	Following are modifications necessary to paper over compiler or
-	library deficiencies in complying to the ANSI/POSIX standard.  Please
-	inform me of any other changes so I can add them to this list.
------------------------------------------------------------------------------------
-
-			SUNOS Release 4.1.1
-
-The implementation of realloc does not conform to ANSI semantics.
-Sam assumes that
-
-	realloc(0, n);
-
-is equivalent to malloc(n).  Replace each occurrence of
-
-	p = realloc(p, n);
-
-with:
-	p = ((p == 0) ? malloc(n) : realloc(p, n));
-
-or something equivalent.
------------------------------------------------------------------------------------
-
-			MIPS OS Release 4.5.2
-
-There are two major deficiencies with the Mips implemention: the use of the
-old System V implementation of varargs and a compiler bug that botches the
-parsing of a typedef parameter in the declaration of an indirect function
-member of a structure.
-
-The following changes are required:
-
-In sam/unix.c, replace function dprint with the following code:
-	void
-	dprint(char *fmt, int va_alist)
-	va_dcl
-	{
-		va_list args;
-		char buf[BLOCKSIZE];
-	
-		va_start(args);
-		vsprintf(buf, fmt, args);
-		termwrite(buf);
-		va_end(args);
-	}
-
-In libframe/misc.c, replace function fprint with the following code:
-	void
-	fprint(int fd, char *fmt, int va_alist)
-	va_dcl
-	{
-		va_list args;
-		char buf[2048];			/* pick reasonable blocksize */
-
-		va_start(args);
-		vsprintf(buf, fmt, args);
-		write(fd, buf, strlen(buf));
-		va_end(args);
-	}
-
-In samterm/flayer.h, replace the declaration of the member named
-textfn (near line 19) in structure Flayer, currently declared as:
-
- 	Rune		*(*textfn)(Flayer*, long, ulong*);
-
-with
-	Rune		*(*textfn)(Flayer*, long, unsigned long*);
-
-In sam/parse.h, replace the declaration of the member named fn
-(near line 45) in structure cmdtab, currently declared as:
-
- 	int	(*fn)(File*, Cmd*);	/* function to call with parse tree */
-with
-	int	(*fn)(File*, struct Cmd*);	/* function to call with parse tree */
-
-In sam/sam.h, replace the declaration of function dprint (near line 227) with:
-
-	void	dprint();
-
-In libframe/u.h, replace the declaration of function fprint (near line 65) with:
-
-	void	fprint();
-
-Near line 67 of samterm/samterm.h, change the declaration of function gettext from:
-
-	Rune	*gettext(Flayer*, long, ulong*);
-to
-	Rune	*gettext(Flayer*, long, unsigned long*);
-
//GO.SYSIN DD ./README
echo ./libXg/README
sed s/.// > ./libXg/README <<'//GO.SYSIN DD ./libXg/README'
-This is an implementation of Plan 9's graphics library
-under X using the Xt intrinsics. It should work for
-X11 release 3 or higher.
-
-The manual pages graphics.3, balloc.3, bitblt.3, event.3
-and rgbpix.3 describe the libg interface, with the following
-differences necessary to accommodate X:
-
-- xtbinit is used to initialize the library, instead of
-  binit
-
-- getfont is used to read a font by name, instead of
-  falloc, ffree, rdfontfile, wrfontfile
-
-- divpt is the name of libg's div (which conflicts with ANSI)
-
-- the event stuff is not optional (or bflush must be
-  called every now and then)
-
//GO.SYSIN DD ./libXg/README
echo ./doc/sam.1
sed s/.// > ./doc/sam.1 <<'//GO.SYSIN DD ./doc/sam.1'
-.ds a \fR*\ \fP
-.TH SAM 1
-.CT 1 editor
-.SH NAME
-sam \- screen editor with structural regular expressions 
-.SH SYNOPSIS
-.B sam
-[
-.I option ...
-] [
-.I files
-]
-.PP
-.B sam
-.B -r
-.I machine
-.PP
-.B sam.save
-.SH DESCRIPTION
-.I Sam
-is a multi-file editor.
-It modifies a local copy of an external file.
-The copy is here called a
-.IR file .
-The files are listed in a menu available through mouse button 3
-or the
-.B n
-command.
-Each file has an associated name, usually the name of the
-external file from which it was read, and a `modified' bit that indicates whether
-the editor's file agrees with the external file.
-The external file is not read into
-the editor's file until it first becomes the current file\(emthat to
-which editing commands apply\(emwhereupon its menu entry is printed.
-The options are
-.TP
-.B -d
-Do not download the terminal part of
-.I sam.
-Editing will be done with the command language only, as in
-.IR ed (1).
-.TP
-.BI -r " machine
-Run the host part remotely
-on the specified machine, the terminal part locally.
-.TP
-.BI -s " file
-Start the host part from the indicated file when
-doing a remote execution.  Useful for debugging.
-.TP
-.BI -t " path
-Start the terminal part from the indicated file.
-Useful for debugging.
-.TP
-.PP
-Also, the standard X11 
-.BI -geom
-toolkit option can be used,
-to select the proper geometry.
-.SS Regular expressions
-Regular expressions are as in
-.IR regexp (6)
-with the addition of
-.BR \en
-to represent newlines.
-A regular expression may never contain a literal newline character.
-The elements of regular expressions are:
-.TP
-.B .
-Match any character except newline.
-.TP
-.B \en
-Match newline.
-.TP
-.B \ex
-For any character except
-.B n
-match the character (here
-.BR x ).
-.TP
-.B [abc]
-Match any character in the square brackets.
-.B \en
-may be mentioned.
-.TP
-.B [^abc]
-Match any character not in the square brackets, but never a newline.
-Both these forms accept a range of
-.SM ASCII
-characters indicated by
-a dash, as in
-.BR a-z .
-.TP
-.B ^
-Match the null string immediately after a newline.
-.TP
-.B $
-Match the null string immediately before a newline.
-.PP
-Any other character except newline matches itself.
-.PP
-In the following,
-.I r1
-and
-.I r2
-are regular expressions.
-.TP
-.BI ( r1 )
-Match what
-.I r1
-matches.
-.TP
-.IB r1 | r2
-Match what
-.I r1
-or what
-.IR r2
-matches.
-.TP
-.IB r1 *
-Match zero or more adjacent matches
-of
-.IR r1 .
-.TP
-.IB r1 +
-Match one or more adjacent matches of
-.IR r1 .
-.TP
-.IB  r1 ?
-Match zero or one matches of
-.IR r1 .
-.PP
-The operators
-.BR * ,
-.B +
-and
-.B ?
-are highest precedence, then catenation, then
-.B |
-is lowest.
-The empty
-regular expression stands for the last complete expression encountered.
-A regular expression in
-.I sam
-matches the longest leftmost substring formally
-matched by the expression.
-Searching in the reverse direction is equivalent
-to searching backwards with the catenation operations reversed in
-the expression.
-.SS Addresses
-An address identifies a substring in a file.
-In the following, `character
-.IR n '
-means the null string
-after the
-.IR n -th
-character in the file, with 1 the
-first character in the file.
-`Line
-.IR n '
-means the
-.IR n -th
-match,
-starting at the beginning of the file, of the regular expression
-.L .*\en? .
-(The peculiar properties of a last line without a newline are
-temporarily undefined.)
-All files always have a current substring, called dot,
-that is the default address.
-.SS Simple Addresses
-.TP
-.BI # n
-The empty string after character
-.IR n ;
-.B #0
-is the beginning of the file.
-.TP
-.I n
-Line
-.IR n .
-.TP
-.BI  / regexp /
-.PD0
-.TP
-.BI ? regexp ?
-The substring that matches the regular expression,
-found by looking toward the end 
-.RB ( / )
-or beginning
-.RB ( ? )
-of the file,
-and if necessary continuing the search from the other end to the
-starting point of the search.
-The matched substring may straddle
-the starting point.
-.PD
-.TP
-.B 0
-The string before the first full line.
-This is not necessarily
-the null string; see
-.B +
-and
-.B -
-below.
-.TP
-.B $
-The null string at the end of the file.
-.TP
-.B .
-Dot.
-.TP
-.B \&'
-The mark in the file (see the
-.B k
-command below).
-.TP
-\f(CW"\f2regexp\f(CW"\f1\f1
-Preceding a simple address (default
-.BR . ),
-refers to the address evaluated in the unique file whose menu line
-matches the regular expression.
-.SS Compound Addresses
-In the following,
-.I a1
-and
-.I a2
-are addresses.
-.TP
-.IB a1 + a2
-The address
-.I a2
-evaluated starting at the end of
-.IR a1 .
-.TP
-.IB a1 - a2
-The address
-.I a2
-evaluated looking in the reverse direction
-starting at the beginning of
-.IR a1 .
-.TP
-.IB a1 , a2
-The substring from the beginning of
-.I a1
-to the end of
-.IR a2 .
-If
-.I a1
-is missing,
-.B 0
-is substituted.
-If
-.I a2
-is missing,
-.B $
-is substituted.
-.TP
-.IB  a1 ; a2
-Like
-.IB a1 , a2,
-but with
-.I a2
-evaluated at the end of, and dot set to,
-.IR a1 .
-.PP
-The operators
-.B +
-and
-.B -
-are high precedence, while
-.B ,
-and
-.B ;
-are low precedence.
-.PP
-In both
-.B +
-and
-.B -
-forms, if
-.I a2
-is a line or character address with a missing
-number, the number defaults to 1.
-If
-.I a1
-is missing,
-.L .
-is substituted.
-If both
-.I a1
-and
-.I a2
-are present and distinguishable,
-.B +
-may be elided.
-.I a2
-may be a regular
-expression; if it is delimited by
-.LR ? 's,
-the effect of the
-.B +
-or
-.B -
-is reversed.
-.PP
-It is an error for a compound address to represent a malformed substring.
-Some useful idioms: 
-.IB a1 +- 
-.RI ( a1 \&\f5-+\fP )
-selects the line containing
-the end (beginning) of a1.
-.BI 0/ regexp /
-locates the first match of the expression in the file.
-(The form
-.B 0;//
-sets dot unnecessarily.)
-.BI ./ regexp /// 
-finds the second following occurrence of the expression,
-and
-.BI .,/ regexp /
-extends dot.
-.SS Commands
-In the following, text demarcated by slashes represents text delimited
-by any printable
-.SM ASCII
-character except alphanumerics.
-Any number of
-trailing delimiters may be elided, with multiple elisions then representing
-null strings, but the first delimiter must always
-be present.
-In any delimited text,
-newline may not appear literally;
-.B \en
-may be typed for newline; and
-.B \e/
-quotes the delimiter, here 
-.LR / .
-Backslash is otherwise interpreted literally, except in
-.B s
-commands.
-.PP
-Most commands may be prefixed by an address to indicate their range
-of operation.
-Those that may not are marked with a 
-.L *
-below.
-If a command takes
-an address and none is supplied, dot is used.
-The sole exception is
-the
-.B w
-command, which defaults to
-.BR 0,$ .
-In the description, `range' is used
-to represent whatever address is supplied.
-Many commands set the
-value of dot as a side effect.
-If so, it is always set to the `result'
-of the change: the empty string for a deletion, the new text for an
-insertion, etc. (but see the
-.B s
-and
-.B e
-commands).
-.br
-.ne 1.2i
-.SS Text commands
-.PD0
-.TP
-.BI a/ text /
-.TP
-or
-.TP
-.B  a
-.TP
-.I lines of text
-.TP
-.B .
-Insert the text into the file after the range.
-Set dot.
-.TP
-.B c\fP
-.br
-.ns
-.TP
-.B i\fP
-Same as
-.BR a ,
-but
-.B c
-replaces the text, while
-.B i
-inserts
-.I before
-the range.
-.TP
-.B d
-Delete the text in the range.
-Set dot.
-.TP
-.BI s/ regexp / text /
-Substitute
-.I text
-for the first match to the regular expression in the range.
-Set dot to the modified range.
-In 
-.I text
-the character
-.B &
-stands for the string
-that matched the expression. 
-Backslash behaves as usual unless followed by
-a digit:
-.BI \e d
-stands for the string that matched the
-subexpression begun by the
-.IR d -th
-left parenthesis.
-If
-.I s
-is followed immediately by a
-number
-.IR n ,
-as in
-.BR s2/x/y/ ,
-the
-.IR n -th
-match in the range is substituted.
-If the
-command is followed by a
-.BR g ,
-as in
-.BR s/x/y/g ,
-all matches in the range
-are substituted.
-.TP
-.BI m " a1
-.br
-.ns
-.TP
-.BI t " a1
-Move the range to after
-.I a1
-.RB ( m ),
-or copy it
-.RB ( t ).
-Set dot.
-.SS Display commands
-.TP
-.B p
-Print the text in the range.
-Set dot.
-.TP
-.B =
-Print the line address and character address of the range.
-.TP
-.B =#
-Print just the character address of the range.
-.SS File commands
-.TP
-.BI \*ab " file-list
-Set the current file to the first file named in the list
-that
-.I sam
-also has in its menu.
-The list may be expressed
-.BI < "shell command"
-in which case the file names are taken as words (in the shell sense)
-generated by the shell command.
-.TP
-.BI \*aB " file-list
-Same as
-.BR b ,
-except that file names not in the menu are entered there,
-and all file names in the list are examined.
-.TP
-.B \*an
-Print a menu of files.
-The format is:
-.RS
-.TP \w'\ \ or\ blank\ \'u
-.BR ' " or blank
-indicating the file is modified or clean,
-.TP
-.BR - " or \&" +
-indicating the the file is unread or has been read
-(in the terminal,
-.B *
-means more than one window is open),
-.TP
-.BR . " or blank
-indicating the current file,
-.TP
-a blank,
-.TP
-and the file name.
-.RE
-.TP 0
-.BI \*aD " file-list
-Delete the named files from the menu.
-If no files are named, the current file is deleted.
-It is an error to
-.B D
-a modified file, but a subsequent
-.B D
-will delete such a file.
-.SS I/O Commands
-.TP
-.BI \*ae " filename
-Replace the file by the contents of the named external file.
-Set dot to the beginning of the file.
-.TP
-.BI r " filename
-Replace the text in the range by the contents of the named external file.
-Set dot.
-.TP
-.BI w " filename
-Write the range (default
-.BR 0,$ )
-to the named external file.
-.TP
-.BI \*af " filename
-Set the file name and print the resulting menu entry.
-.PP
-If the file name is absent from any of these, the current file name is used.
-.B e
-always sets the file name,
-.B r
-and
-.B w
-do so if the file has no name.
-.TP
-.BI < " shell-command
-Replace the range by the standard output of the
-shell command.
-.TP
-.BI > " shell-command
-Sends the range to the standard input of the
-shell command.
-.TP
-.BI | " shell-command
-Send the range to the standard input, and replace it by
-the standard output, of the
-shell command.
-.TP
-.BI \*a! " shell-command
-Run the
-shell command.
-.TP
-.BI \*acd " directory
-Change working directory.
-If no directory is specified,
-.B $HOME
-is used.
-.PP
-In any of
-.BR < ,
-.BR > ,
-.B |
-or
-.BR ! ,
-if the
-.I shell command
-is omitted the last
-.I shell command
-(of any type) is substituted.
-If
-.I sam
-is downloaded,
-.B !
-sets standard input to
-.FR /dev/null ,
-and otherwise
-unassigned output
-.RB ( stdout
-for
-.B !
-and
-.BR > ,
-.B stderr
-for all) is placed in
-.F $HOME/sam.err
-and the first few lines are printed.
-.SS Loops and Conditionals
-.TP
-.BI x/ regexp / " command
-For each match of the regular expression in the range, run the command
-with dot set to the match.
-Set dot to the last match.
-If the regular
-expression and its slashes are omitted, 
-.L /.*\en/
-is assumed.
-Null string matches potentially occur before every character
-of the range and at the end of the range.
-.TP
-.BI y/ regexp / " command
-Like
-.B x,
-but run the command for each substring that lies before, between,
-or after
-the matches that would be generated by
-.BR x .
-There is no default behavior.
-Null substrings potentially occur before every character
-in the range.
-.TP
-.BI \*aX/ regexp / " command
-For each file whose menu entry matches the regular expression,
-run the command.
-If the expression is omitted, the command is run
-in every file.
-.TP
-.BI \*aY/ regexp / " command
-Same as
-.BR X ,
-but for files that do not match the regular expression,
-and the expression is required.
-.TP
-.BI g/ regexp / " command
-.br
-.ns
-.TP
-.BI v/ regexp / " command
-If the range contains
-.RB ( g )
-or does not contain
-.RB ( v )
-a match for the expression,
-set dot to the range and run the command.
-.PP
-These may be nested arbitrarily deeply, but only one instance of either
-.B X
-or
-.B Y
-may appear in a \%single command.
-An empty command in an
-.B x
-or
-.B y
-defaults to
-.BR p ;
-an empty command in
-.B X
-or
-.B Y
-defaults to
-.BR f .
-.B g
-and
-.B v
-do not have defaults.
-.SS Miscellany
-.TP
-.B k
-Set the current file's mark to the range.  Does not set dot.
-.TP
-.B \*aq
-Quit.
-It is an error to quit with modified files, but a second
-.B q
-will succeed.
-.TP
-.BI \*au " n
-Undo the last
-.I n
-(default 1)
-top-level commands that changed the contents or name of the
-current file, and any other file whose most recent change was simultaneous
-with the current file's change.
-Successive
-.BR u 's
-move further back in time.
-The only commands for which u is ineffective are
-.BR cd ,
-.BR u ,
-.BR q ,
-.B w
-and
-.BR D .
-.TP
-(empty)
-If the range is explicit, set dot to the range.
-If
-.I sam
-is downloaded, the resulting dot is selected on the screen;
-otherwise it is printed.
-If no address is specified (the
-command is a newline) dot is extended in either direction to
-line boundaries and printed.
-If dot is thereby unchanged, it is set to
-.B .+1 
-and printed.
-.PD
-.SS Grouping and multiple changes
-Commands may be grouped by enclosing them in braces
-.BR {} .
-Commands within the braces must appear on separate lines (no backslashes are
-required between commands).
-Semantically, an opening brace is like a command:
-it takes an (optional) address and sets dot for each sub-command.
-Commands within the braces are executed sequentially, but changes made
-by one command are not visible to other commands (see the next section
-of this manual).
-Braces may be nested arbitrarily.
-.PP
-When a command makes a number of changes to a file, as in
-.BR x/re/c/text/ ,
-the addresses of all changes to the file are computed in the original file.
-If the changes are in sequence,
-they are applied to the file.
-Successive insertions at the same address are catenated into a single
-insertion composed of the several insertions in the order applied.
-.SS The terminal
-What follows refers to behavior of
-.I sam
-when downloaded, that is, when
-operating as a display editor on a bitmap display.
-This is the default
-behavior; invoking
-.I sam
-with the
-.B -d
-(no download) option provides access
-to the command language only.
-.PP
-Each file may have zero or more windows open.
-Each window is equivalent
-and is updated simultaneously with changes in other windows on the same file.
-Each window has an independent value of dot, indicated by a highlighted
-substring on the display.
-Dot may be in a region not within
-the window.
-There is usually a `current window',
-marked with a dark border, to which typed text and editing
-commands apply.
-.PP
-The button 3 menu controls window operations.
-The top of the menu
-provides the following operators, each of which uses one or
-more cursors to prompt for selection of a window or sweeping
-of a rectangle.
-.TF reshape
-.TP 
-.B new
-Create a new, empty file:
-Depress button 3 where one corner of the new rectangle should
-appear (box cursor), and move the mouse while holding down button 3 to the
-diagonally opposite corner.
-`Sweeping' a null rectangle gets a large window, disjoint
-from the command window or the whole sam window, depending on
-where the null rectangle is.
-.TP
-.B xerox
-Create a copy of an existing window.
-After selecting the window to copy with button 1,
-sweep out the window for the copy.
-.TP
-.B reshape
-Change the size and location of a window.
-First click button 3 in the window to be changed
-(gunsight cursor).
-Then sweep out a window as for the
-.B new
-menu selection.
-.TP
-.B close
-Delete the window.
-In the last window of a file,
-.B close
-is equivalent to a
-.B D
-for the file.
-.TP
-.B write
-Equivalent to a
-.B w
-for the file.
-.PD
-.PP
-Below these operators is a list of available files, starting with
-.BR ~~sam~~ ,
-the command window.
-Selecting a file from the list makes the most recently
-used window on that file current, unless it is already current, in which
-case selections cycle through the open windows.
-If no windows are open
-on the file, the user is prompted to open one.
-Files other than
-.B ~~sam~~
-are marked with one of the characters
-.B -+*
-according as zero, one, or more windows
-are open on the file.
-A further mark
-.L .
-appears on the file in the current window and
-a single quote,
-.BR ' ,
-on a file modified since last write.
-.PP
-Nothing can be done without a command window, for which
-.I sam
-prompts initially.
-The command window is an ordinary window except that text typed to it
-is interpreted as commands for the editor rather than passive text,
-and text printed by editor commands appears in it.
-There is an `output point' that separates commands being typed from
-previous output.
-Commands typed in the command window apply to the
-current open file\(emthe file in the most recently
-current window.
-.SS Manipulating text
-Typed characters replace the current selection (dot) in the current
-window.
-Backspace deletes the previous character.
-Escape selects (sets dot to) everything typed since the last mouse hit.
-.PP
-Button 1 changes selection.
-Pointing to a non-current window with button 1 makes it current;
-within the current window, button 1 selects text, thus setting dot.
-Double-clicking selects text to the boundaries of words, lines,
-quoted strings or bracketed strings, depending on the text at the click.
-.PP
-Button 2 provides a menu of editing commands:
-.PD0
-.TP
-.B cut
-Delete dot and save the deleted text in the snarf buffer.
-.TP
-.B paste
-Replace the text in dot by the contents of the snarf buffer.
-.TP
-.B snarf
-Save the text in dot in the snarf buffer.
-.TP
-.B look
-Search forward for the next occurrence of the literal text in dot.
-If dot is the null string, the text in the snarf buffer is
-used.
-The snarf buffer is unaffected.
-.TP
-.B <exch>
-Exchange the snarf buffer with the current selection in another X11 window.
-.TP
-.BI / regexp
-Search forward for the next match of the last regular expression
-typed in a command.
-(Not in command window.)
-.TP
-.B send
-Send the text in dot, or the snarf buffer if
-dot is the null string, as if it were typed to the command window.
-Saves the sent text in the snarf buffer.
-(Command window only.) 
-.PD
-.SS X11 resources
-Various attributes of
-.I sam
-can be set by giving values to X11 resources for the class
-.B Sam.
-There are various ways to do this; one is to have a file
-called
-.B Sam
-in your home directory, with entries in it like:
-.CW
-.nf
-    Sam*width: 500
-    Sam*height: 600
-    Sam*font: fixed
-    Sam*scrollForwardR: true
-.fi
-.PP
-In addition to the usual X11 toolkit resources, the
-.B scrollForwardR
-resource says where the right button (button 3) scrolls
-forward or backward in the file.
-.SS Abnormal termination
-If
-.I sam
-terminates other than by a
-.B q
-command (by hangup, deleting its window, etc.), modified
-files are saved in an
-executable file,
-.FR $HOME/sam.save .
-This program, when executed, asks whether to write
-each file back to a external file.
-The answer
-.L y
-causes writing; anything else skips the file.
-If the machine crashes in such a way that no
-.F sam.save
-file is created, all changes are lost.
-If an editing session is difficult to replicate,
-you should write your changed files often.
-.SH FILES
-.F $HOME/sam.save
-.br
-.F $HOME/sam.err
-.SH SEE ALSO
-.IR ed (1),
-.IR regexp (6)
-.SH BUGS
-The
-.B u
-command undoes the typing of characters and backspaces
-in unpredictable increments.
-.PP
-When a sam window is resized, the command window may have the wrong size.
//GO.SYSIN DD ./doc/sam.1
echo ./doc/sam.tut.ms
sed s/.// > ./doc/sam.tut.ms <<'//GO.SYSIN DD ./doc/sam.tut.ms'
-.de P1
-.KS
-.DS
-.ft CW
-.ta 5n 10n 15n 20n 25n 30n 35n 40n 45n 50n 55n 60n 65n 70n 75n 80n
-..
-.de P2
-.ft 1
-.DE
-.KE
-..
-.de CW
-.lg 0
-\%\&\\$3\f(CW\\$1\fP\&\\$2
-.lg
-..
-.de WC
-.lg 0
-\%\&\\$3\f(CS\\$1\fP\&\\$2
-.lg
-..
-.TL
-A tutorial for the
-.CW sam
-.B
-command language
-.AU
-Rob Pike
-.AI
-.MH
-.AB
-.CW sam
-is an interactive text editor with a command language that makes heavy use
-of regular expressions.
-Although the language is syntactically similar to
-.CW ed (1),
-the details are interestingly different.
-This tutorial introduces the command language, but does not discuss
-the screen and mouse interface.
-With apologies to those unfamiliar with the Ninth Edition Blit software,
-it is assumed that the similarity of
-.CW sam
-to
-.CW mux (9)
-at this level makes
-.CW sam 's
-mouse language easy to learn.
-.PP
-The
-.CW sam
-command language applies identically to two environments:
-when running
-.CW sam
-on an ordinary terminal
-(\f2via\f1\f1
-.CW sam\ -d ),
-and in the command window of a
-.I downloaded
-.CW sam ,
-that is, one using the bitmap display and mouse.
-.AE
-.SH
-Introduction
-.PP
-This tutorial describes the command language of
-.CW sam ,
-an interactive text editor that runs on Blits and
-some computers with bitmap displays.
-For most editing tasks, the mouse-based editing features
-are sufficient, and they are easy to use and to learn.
-.PP
-The command language is often useful, however, particularly
-when making global changes.
-Unlike the commands in
-.CW ed ,
-which are necessary to make changes,
-.CW sam
-commands tend to be used
-only for complicated or repetitive editing tasks.
-It is in these more involved uses that
-the differences between
-.CW sam
-and other text editors are most evident.
-.PP
-.CW sam 's
-language makes it easy to do some things that other editors,
-including programs like
-.CW sed
-and
-.CW awk ,
-do not handle gracefully, so this tutorial serves partly as a
-lesson in
-.CW sam 's
-manner of manipulating text.
-The examples below therefore concentrate entirely on the language,
-assuming that facility with the use of the mouse in
-.CW sam
-is at worst easy to pick up.
-In fact,
-.CW sam
-can be run without the mouse at all (not
-.I downloaded ),
-by specifying the
-.CW -d
-flag, and it is this domain that the tutorial
-occupies; the command language in these modes
-are identical.
-.PP
-A word to the Unix adept:
-although
-.CW sam
-is syntactically very similar to
-.CW ed ,
-it is fundamentally and deliberately different in design and detailed semantics.
-You might use knowledge of
-.CW ed
-to predict how the substitute command works,
-but you'd only be right if you had used some understanding of
-.CW sam 's
-workings to influence your prediction.
-Be particularly careful about idioms.
-Idioms form in curious nooks of languages and depend on
-undependable peculiarities.
-.CW ed
-idioms simply don't work in
-.CW sam :
-.CW 1,$s/a/b/
-makes one substitution in the whole file, not one per line.
-.CW sam
-has its own idioms.
-Much of the purpose of this tutorial is to publish them
-and make fluency in
-.CW sam
-a matter of learning, not cunning.
-.PP
-The tutorial depends on familiarity with regular expressions, although
-some experience with a more traditional Unix editor may be helpful.
-To aid readers familiar with
-.CW ed ,
-I have pointed out in square brackets [] some of
-the relevant differences between
-.CW ed
-and
-.CW sam .
-Read these comments only if you wish
-to understand the differences; the lesson is about
-.CW sam ,
-not
-.CW sam
-.I vs.
-.CW ed .
-Another typographic convention is that output appears in
-.CW "this font,
-while typed input appears as
-.WC "slanty text.
-.PP
-Nomenclature:
-.CW sam
-keeps a copy of the text it is editing.
-This copy is called a
-.I file .
-To avoid confusion, I have called the permanent storage on disc a
-.I
-Unix file.
-.R
-.SH
-Text
-.PP
-To get started, we need some text to play with.
-Any text will do; try something from
-James Gosling's Emacs manual:
-.P1
-$ \f(CSsam -d
-a
-This manual is organized in a rather haphazard manner.  The first
-several sections were written hastily in an attempt to provide a
-general introduction to the commands in Emacs and to try to show
-the method in the madness that is the Emacs command structure.
-\&.
-.ft
-.P2
-.WC "sam -d
-starts
-.CW sam
-running.
-The
-.CW a
-command adds text until a line containing just a period, and sets the
-.I
-current text
-.R
-(also called
-.I dot )
-to what was typed \(em everything between the
-.CW a
-and the period.
-.CW ed "" [
-would leave dot set to only the last line.]
-The
-.CW p
-command prints the current text:
-.P1
-.WC p
-This manual is organized in a rather haphazard manner.  The first
-several sections were written hastily in an attempt to provide a
-general introduction to the commands in Emacs and to try to show
-the method in the madness that is the Emacs command structure.
-.P2
-[Again,
-.CW ed
-would print only the last line.]
-The
-.CW a
-command adds its text
-.I after
-dot; the
-.CW i
-command is like
-.CW a,
-but adds the text
-.I before
-dot.
-.P1
-.ft CS
-i
-Introduction
-\&.
-p
-.ft
-Introduction
-.P2
-There is also a
-.CW c
-command that changes (replaces) the current text,
-and
-.CW d
-that deletes it; these are illustrated below.
-.PP
-To see all the text, we can specify what text to print;
-for the moment, suffice it to say that
-.WC 0,$
-specifies the entire file.
-.CW ed "" [
-users would probably type
-.WC 1,$ ,
-which in practice is the same thing, but see below.]
-.P1
-.WC 0,$p
-Introduction
-This manual is organized in a rather haphazard manner.  The first
-several sections were written hastily in an attempt to provide a
-general introduction to the commands in Emacs and to try to show
-the method in the madness that is the Emacs command structure.
-.P2
-Except for the
-.CW w
-command described below,
-.I all
-commands,
-including
-.CW p ,
-set dot to the text they touch.
-Thus,
-.CW a
-and
-.CW i
-set dot to the new text,
-.CW p
-to the text printed, and so on.
-Similarly, all commands
-(except
-.CW w )
-by default operate on the current
-text [unlike
-.CW ed ,
-for which some commands (such as
-.CW g )
-default to the entire file].
-.PP
-Things are not going to get very interesting until we can
-set dot arbitrarily.
-This is done by
-.I addresses ,
-which specify a piece of the file.
-The address
-.CW 1 ,
-for example, sets dot to the first line of the file.
-.P1
-.WC 1p
-Introduction
-.WC c
-.WC Preamble
-.WC .
-.P2
-The
-.CW c
-command didn't need to specify dot; the
-.CW p
-left it on line one.
-It's therefore easy to delete the first line utterly;
-the last command left dot set to line one:
-.P1
-.WC d
-.WC 1p
-This manual is organized in a rather haphazard manner.  The first
-.P2
-(Line numbers change
-to reflect changes to the file.)
-.PP
-The address \f(CW/\f2text\f(CW/\f1
-sets dot to the first appearance of
-.I text ,
-after dot.
-.CW ed "" [
-matches the first line containing
-.I text .]
-If
-.I text
-is not found, the search restarts at the beginning of the file
-and continues until dot.
-.P1
-.WC /Emacs/p
-Emacs
-.P2
-It's difficult to indicate typographically, but in this example no newline appears
-after
-.CW Emacs :
-the text to be printed is the string
-.CW Emacs ', `
-exactly.
-(The final
-.CW p
-may be left off \(em it is the default command.
-When downloaded, however, the default is instead to select the text,
-to highlight it,
-and to make it visible by moving the window on the file if necessary.
-Thus,
-.CW /Emacs/
-indicates on the display the next occurrence of the text.)
-.PP
-Imagine we wanted to change the word
-.CW haphazard
-to
-.CW thoughtless .
-Obviously, what's needed is another
-.CW c
-command, but the method used so far to insert text includes a newline.
-The syntax for including text without newlines is to surround the
-text with slashes (which is the same as the syntax for
-text searches, but what is going on should be clear from context).
-The text must appear immediately after the
-.CW c
-(or
-.CW a
-or
-.CW i ).
-Given this, it is easy to make the required change:
-.P1
-.WC /haphazard/c/thoughtless/
-1p
-This manual is organized in a rather thoughtless manner.  The first
-.P2
-[Changes can always be done with a
-.CW c
-command, even if the text is smaller than a line].
-You'll find that this way of providing text to commands is much
-more common than is the multiple-lines syntax.
-If you want to include a slash
-.CW /
-in the text, just precede it with a backslash
-.CW \e ,
-and use a backslash to protect a backslash itself.
-.P1
-.WC /Emacs/c/Emacs\e\e360/
-.WC 4p
-general introduction to the commands in Emacs\e360 and to try to show
-.P2
-We could also make this particular change by
-.P1
-.WC /Emacs/a/\e\e360/
-.P2
-.PP
-This is as good a place as any to introduce the
-.CW u
-command, which undoes the last command.
-A second
-.CW u
-will undo the penultimate command, and so on.
-.P1
-.WC u
-.WC 4p
-general introduction to the commands in Emacs and to try to show
-.WC u
-.WC 3p
-This manual is organized in a rather haphazard manner.  The first
-.P2
-Undoing can only back up; there is no way to undo a previous
-.CW u .
-.SH
-Addresses
-.PP
-We've seen the simplest forms of addresses, but there is more
-to learn before we can get too much further.
-An address selects a region in the file \(em a substring \(em
-and therefore must define the beginning and the end of a region.
-Thus, the address
-.CW 13
-selects from the beginning of line thirteen to the end of line thirteen, and
-.CW /Emacs/
-selects from the beginning of the word
-.CW Emacs ' `
-to the end.
-.PP
-Addresses may be combined with a comma:
-.P1
-13,15
-.P2
-selects lines thirteen through fifteen.  The definition of the comma
-operator is to select from the beginning of the left hand address (the
-beginning of line 13) to the end of the right hand address (the
-end of line 15).
-.PP
-A few special simple addresses come in handy:
-.CW .
-(a period) represents dot, the current text,
-.CW 0
-(line zero) selects the null string at the beginning of the file, and
-.CW $
-selects the null string at the end of the file
-[not the last line of the file].
-Therefore,
-.P1
-0,13
-.P2
-selects from the beginning of the file to the end of line thirteen,
-.P1
-\&.,$
-.P2
-selects from the beginning of the current text to the end of the file, and
-.P1
-0,$
-.P2
-selects the whole file [that is, a single string containing the whole file,
-not a list of all the lines in the file].
-.PP
-These are all
-.I absolute
-addresses: they refer to specific places in the file.
-.CW sam
-also has relative addresses, which depend
-on the value of dot,
-and in fact we have already seen one form:
-.CW /Emacs/
-finds the first occurrence of
-.CW Emacs
-searching forwards from dot.
-Which occurrence of
-.CW Emacs
-it finds depends on the value of dot.
-What if you wanted the first occurrence
-.CW before
-dot?  Just precede the pattern with a minus sign, which reverses the direction
-of the search:
-.P1
--/Emacs/
-.P2
-In fact, the complete syntax for forward searching is
-.P1
-+/Emacs/
-.P2
-but the plus sign is the default, and in practice is rarely used.
-Here is an example that includes it for clarity:
-.P1
-0+/Emacs/
-.P2
-selects the first occurrence of
-.CW Emacs
-in the file; read it as ``go to line 0, then search forwards for
-.CW Emacs .''
-Since the
-.CW +
-is optional, this can be written
-.CW 0/Emacs/ .
-Similarly,
-.P1
-$-/Emacs/
-.P2
-finds the last occurrence in the file, so
-.P1
-0/Emacs/,$-/Emacs/
-.P2
-selects the text from the first to last
-.CW Emacs ,
-inclusive.
-Slightly more interesting:
-.P1
-/Emacs/+/Emacs/
-.P2
-(there is an implicit
-.CW .+
-at the beginning) selects the second
-.CW Emacs
-following dot.
-.PP
-Line numbers may also be relative.
-.P1
--2
-.P2
-selects the second previous line, and
-.P1
-+5
-.P2
-selects the fifth following line (here the plus sign is obligatory).
-.PP
-Since addresses may select (and dot may be) more than one line,
-we need a definition of `previous' and `following:'
-`previous' means
-.I
-before the beginning
-.R
-of dot, and `following'
-means
-.I
-after the end
-.R
-of dot.
-For example, if the file contains \f(CWA\f(CSAA\f(CWA\f1,
-with dot set to the middle two
-.CW A 's
-(the slanting characters),
-.CW -/A/
-sets dot to the first
-.CW A ,
-and
-.CW +/A/
-sets dot to the last
-.CW A .
-Except under odd circumstances (such as when the only occurrence of the
-text in the file is already the current text), the text selected by a
-search will be disjoint from dot.
-.PP
-To select the
-.CW "troff -ms
-paragraph containing dot, however long it is, use
-.P1
--/.PP/,/.PP/-1
-.P2
-which will include the
-.CW .PP
-that begins the paragraph, and exclude the one that ends it.
-.PP
-When typing relative line number addresses, the default number is
-.CW 1 ,
-so the above could be written slightly more simply:
-.P1
--/.PP/,/.PP/-
-.P2
-.PP
-What does the address
-.CW +1-1
-or the equivalent
-.CW +-
-mean?  It looks like it does nothing, but recall that dot need not be a
-complete line of text.
-.CW +1
-selects the line after the end of the current text, and
-.CW -1
-selects the line before the beginning.  Therefore
-.CW +1-1
-selects the line before the line after the end of dot, that is,
-the complete line containing the end of dot.
-We can use this construction to expand a selection to include a complete line,
-say the first line in the file containing
-.CW Emacs :
-.P1
-.WC 0/Emacs/+-p
-general introduction to the commands in Emacs and to try to show
-.P2
-The address
-.CW +-
-is an idiom.
-.SH
-Loops
-.PP
-Above, we changed one occurrence of
-.CW Emacs
-to
-.CW Emacs\e360 ,
-but if the name of the editor is really changing, it would be useful
-to change
-.I all
-instances of the name in a single command.
-.CW sam
-provides a command,
-.CW x
-(extract), for just that job.
-The syntax is
-\f(CWx/\f2pattern\f(CW/\f2command\f1.
-For each occurrence of the pattern in the selected text,
-.CW x
-sets dot to the occurrence and runs command.
-For example, to change
-.CW Emacs
-to
-.CW vi,
-.P1
-.WC 0,$x/Emacs/c/vi/
-.WC 0,$p
-This manual is organized in a rather haphazard manner.  The first
-several sections were written hastily in an attempt to provide a
-general introduction to the commands in vi and to try to show
-the method in the madness that is the vi command structure.
-.P2
-This
-works by subdividing the current text
-.CW 0,$ "" (
-\(em the whole file) into appearances of its textual argument
-.CW Emacs ), (
-and then running the command that follows
-.CW c/vi/ ) (
-with dot set to the text.
-We can read this example as, ``find all occurrences of
-.CW Emacs
-in the file, and for each one,
-set the current text to the occurrence and run the command
-.CW c/vi/ ,
-which will replace the current text by
-.CW vi. ''
-[This command is somewhat similar to
-.CW ed 's
-.CW g
-command.  The differences will develop below, but note that the
-default address, as always, is dot rather than the whole file.]
-.PP
-A single
-.CW u
-command is sufficient to undo an
-.CW x
-command, regardless of how many individual changes the
-.CW x
-makes.
-.P1
-.WC u
-.WC 0,$p
-This manual is organized in a rather haphazard manner.  The first
-several sections were written hastily in an attempt to provide a
-general introduction to the commands in Emacs and to try to show
-the method in the madness that is the Emacs command structure.
-.P2
-.PP
-Of course,
-.CW c
-is not the only command
-.CW x
-can run.  An
-.CW a
-command can be used to put proprietary markings on
-.CW Emacs :
-.P1
-.WC 0,$x/Emacs/a/{TM}/
-.WC /Emacs/+-p
-general introduction to the commands in Emacs{TM} and to try to show
-.P2
-[There is no way to see the changes as they happen, as in
-.CW ed 's
-.CW g/Emacs/s//&{TM}/p ;
-see the section on Multiple Changes, below.]
-.PP
-The
-.CW p
-command is also useful when driven by an
-.CW x ,
-but be careful that you say what you mean;
-.P1
-.WC 0,$x/Emacs/p
-EmacsEmacs
-.P2
-since
-.CW x
-sets dot to the text in the slashes, printing only that text
-is not going to be very
-informative.  But the command that
-.CW x
-runs can contain addresses.  For example, if we want to print all
-lines containing
-.CW Emacs ,
-just use
-.CW +- :
-.P1
-.WC 0,$x/Emacs/+-p
-general introduction to the commands in Emacs{TM} and to try to show
-the method in the madness that is the Emacs{TM} command structure.
-.P2
-Finally, let's restore the state of the file with another
-.CW x
-command, and make use of a handy shorthand:
-a comma in an address has its left side default to
-.CW 0 ,
-and its right side default to
-.CW $ ,
-so the easy-to-type address
-.CW ,
-refers to the whole file:
-.P1
-.WC ",x/Emacs/ /{TM}/d
-.WC ,p
-This manual is organized in a rather haphazard manner.  The first
-several sections were written hastily in an attempt to provide a
-general introduction to the commands in Emacs and to try to show
-the method in the madness that is the Emacs command structure.
-.P2
-Notice what this
-.CW x
-does: for each occurrence of Emacs,
-find the
-.CW {TM}
-that follows, and delete it.
-.PP
-The `text'
-.CW sam
-accepts
-for searches in addresses and in
-.CW x
-commands is not simple text, but rather
-.I regular\ expressions.
-Unix has several distinct interpretations of regular expressions.
-The form used by
-.CW sam
-is that of
-.CW egrep (1),
-including parentheses
-.CW ()
-for grouping and an `or' operator
-.CW |
-for matching strings in parallel.
-.CW sam
-makes two extensions:
-although
-.CW .
-(the most overloaded character in Unix) matches any character
-.I except
-newline, the regular expression
-.CW @
-(think of it as a big dot) matches any character, even newlines;
-and the character sequence
-.CW \en
-matches a newline character.
-Replacement text, such as used in the
-.CW a
-and
-.CW c
-commands, is still plain text, but the sequence
-.CW \en
-represents newline in that context, too.
-.PP
-Here is an example.  Say we wanted to double space the document, that is,
-turn every newline into two newlines.
-The following all do the job:
-.P1
-.WC ",x/\en/ a/\en/
-.WC ",x/\en/ c/\en\en/
-.WC ",x/$/ a/\en/
-.WC ",x/^/ i/\en/
-.P2
-The last example is slightly different, because it puts a newline
-.I before
-each line; the other examples place it after.
-The first two examples manipulate newlines directly
-[something outside
-.CW ed 's
-ken]; the last two
-use regular expressions:
-.CW $
-is the empty string at the end of a line, while
-.CW ^
-is the empty string at the beginning.
-.PP
-These solutions all have a possible drawback: if there is already a blank line
-(that is, two consecutive newlines), they make it much larger (four
-consecutive newlines).
-A better method is to extend every group of newlines by one:
-.P1
-.WC ",x/\en+/ a/\en/
-.P2
-The regular expression operator
-.CW +
-means `one or more;'
-.CW \en+
-is identical to
-.CW \en\en* .
-Thus, this example
-takes every sequence of newlines and adds another
-to the end.
-.PP
-A more common example is indenting a block of text by a tab stop.
-The following all work,
-although the first is arguably the cleanest (the blank text in slashes is a tab):
-.P1
-.WC ",x/^/a/	 /
-.WC ",x/^/c/	 /
-.WC ",x/.*\en/i/	 /
-.P2
-The last example uses the pattern (idiom, really)
-.CW .*\en
-to match lines:
-.CW .*
-matches the longest possible string of non-newline characters.
-Taking initial tabs away is just as easy:
-.P1
-.WC ",x/^    /d
-.P2
-In these examples I have specified an address (the whole file), but
-in practice commands like these are more likely to be run without
-an address, using the value of dot set by selecting text with the mouse.
-.SH
-Conditionals
-.PP
-The
-.CW x
-command is a looping construct:
-for each match of a regular expression,
-it extracts (sets dot to) the match and runs a command.
-.CW sam
-also has a conditional,
-.CW g :
-\f(CWg/\f2pattern\f(CW/\f2command\f1
-runs the command if dot contains a match of the pattern
-.I
-without changing the value of dot.
-.R
-The inverse,
-.CW v ,
-runs the command if dot does
-.I not
-contain a match of the pattern.
-(The letters
-.CW g
-and
-.CW v
-are historical and have no mnemonic significance.  You might
-think of
-.CW g
-as `guard.')
-.CW ed "" [
-users should read the above definitions very carefully; the
-.CW g
-command in
-.CW sam
-is fundamentally different from that in
-.CW ed .]
-Here is an example of the difference between
-.CW x
-and
-.CW g:
-.P1
-,x/Emacs/c/vi/
-.P2
-changes each occurrence of the word
-.CW Emacs
-in the file to the word
-.CW vi ,
-but
-.P1
-,g/Emacs/c/vi/
-.P2
-changes the
-.I "whole file
-to
-.CW vi
-if there is the word
-.CW Emacs
-anywhere in the file.
-.PP
-Neither of these commands is particularly interesting in isolation,
-but they are valuable when combined with
-.CW x
-and with themselves.
-.SH
-Composition
-.PP
-One way to think about the
-.CW x
-command is that, given a selection (a value of dot)
-it iterates through interesting subselections (values of dot within).
-In other words, it takes a piece of text and cuts it into smaller pieces.
-But the text that it cuts up may already be a piece cut by a previous
-.CW x
-command or selected by a
-.CW g .
-.CW sam 's
-most interesting property is the ability to define a sequence of commands
-to perform a particular task.\(dg
-.FS
-\(dg
-The obvious analogy with shell pipelines is only partially valid,
-because the individual
-.CW sam
-commands are all working on the same text; it is only how the text is
-sliced up that is changing.
-.FE
-A simple example is to change all occurrences of
-.CW Emacs
-to
-.CW emacs ;
-certainly the command
-.P1
-.WC ",x/Emacs/ c/emacs/
-.P2
-will work, but we can use an
-.CW x
-command to save retyping most of the word
-.CW Emacs :
-.P1
-.WC ",x/Emacs/ x/E/ c/e/
-.P2
-(Blanks can be used
-to separate commands on a line to make them easier to read.)
-What this command does is find all occurrences of
-.CW Emacs
-.CW ,x/Emacs/ ), (
-and then
-.I
-with dot set to that text,
-.R
-find all occurrences of the letter
-.CW E
-.CW x/E/ ), (
-and then
-.I
-with dot set to that text,
-.R
-run the command
-.CW c/e/
-to change the character to lower case.
-Note that the address for the command \(em the whole file, specified by a comma
-\(em is only given to the leftmost
-piece of the command; the rest of the pieces have dot set for them by
-the execution of the pieces to their left.
-.PP
-As another simple example, consider a problem
-solved above: printing all lines in the file containing the word
-.CW Emacs:
-.P1
-.WC ",x/.*\en/ g/Emacs/p
-general introduction to the commands in Emacs and to try to show
-the method in the madness that is the Emacs command structure.
-.P2
-This command says to break the file into lines
-.CW ,x/.*\en/ ), (
-and for each line that contains the string
-.CW Emacs
-.CW g/Emacs/ ), (
-run the command
-.CW p
-with dot set to the line (not the match of
-.CW Emacs ),
-which prints the line.
-To save typing, because
-.CW .*\en
-is a common pattern in
-.CW x
-commands,
-if the
-.CW x
-is followed immediately by a space, the pattern
-.CW .*\en
-is assumed.
-Therefore, the above could be written more succinctly:
-.P1
-.WC ",x g/Emacs/p
-.P2
-The solution we used before was
-.P1
-.WC ,x/Emacs/+-p
-.P2
-which runs the command
-.CW +-p
-with dot set to each match of
-.CW Emacs
-in the file (recall that the idiom
-.CW +-p
-prints the line containing the end of dot).
-.PP
-The two commands usually produce the same result
-(the
-.CW +-p
-form will print a line twice if it contains
-.CW Emacs
-twice).  Which is better?
-.CW ,x/Emacs/+-p
-is easier to type and will be much faster if the file is large and
-there are few occurrences of the string, but it is really an odd special case.
-.CW ",x/.*\en/ g/Emacs/p
-is slower \(em it breaks each line out separately, then examines
-it for a match \(em but is conceptually cleaner, and generalizes more easily.
-For example, consider the following piece of the Emacs manual:
-.P1
-command name="append-to-file", key="[unbound]"
-Takes the contents of the current buffer and appends it to the
-named file. If the files doesn't exist, it will be created.
-
-command name="apropos", key="ESC-?"
-Prompts for a keyword and then prints a list of those commands
-whose short description contains that keyword.  For example,
-if you forget which commands deal with windows, just type
-"@b[ESC-?]@t[window]@b[ESC]".
-
-\&\f2and so on\f(CW
-.P2
-This text consists of groups of non-empty lines, with a simple format
-for the text within each group.
-Imagine that we wanted to find the description of the `apropos'
-command.
-The problem is to break the file into individual descriptions,
-and then to find the description of `apropos' and to print it.
-The solution is straightforward:
-.P1
-.WC ,x/(.+\en)+/\ g/command\ name="apropos"/p
-command name="apropos", key="ESC-?"
-Prompts for a keyword and then prints a list of those commands
-whose short description contains that keyword.  For example,
-if you forget which commands deal with windows, just type
-"@b[ESC-?]@t[window]@b[ESC]".
-.P2
-The regular expression
-.CW (.+\en)+
-matches one or more lines with one or more characters each, that is,
-the text between blank lines, so
-.CW ,x/(.+\en)+/
-extracts each description; then
-.CW g/command\ name="apropos"/
-selects the description for `apropos' and
-.CW p
-prints it.
-.PP
-Imagine that we had a C program containing the variable
-.CW n ,
-but we wanted to change it to
-.CW num .
-This command is a first cut:
-.P1
-.WC ",x/n/ c/num/
-.P2
-but is obviously flawed: it will change all
-.CW n 's
-in the file, not just the
-.I identifier
-.CW n .
-A better solution is to use an
-.CW x
-command to extract the identifiers, and then use
-.CW g
-to find the
-.CW n 's:
-.P1
-.WC ",x/[a-zA-Z_][a-zA-Z_0-9]*/ g/n/ v/../ c/num/
-.P2
-It looks awful, but it's fairly easy to understand when read
-left to right.
-A C identifier is an alphabetic or underscore followed by zero or more
-alphanumerics or underscores, that is, matches of the regular expression
-.CW [a-zA-Z_][a-zA-Z_0-9]* .
-The
-.CW g
-command selects those identifiers containing
-.CW n ,
-and the
-.CW v
-is a trick: it rejects those identifiers containing more than one
-character.  Hence the
-.CW c/num/
-applies only to free-standing
-.CW n 's.
-.PP
-There is still a problem here:
-we don't want to change
-.CW n 's
-that are part of the character constant
-.CW \en .
-There is a command
-.CW y ,
-complementary to
-.CW x ,
-that is just what we need:
-\f(CWy/\f2pattern\f(CW/\f2command\f1
-runs the command on the pieces of text
-.I between
-matches of the pattern;
-if
-.CW x
-selects,
-.CW y
-rejects.
-Here is the final command:
-.P1
-.WC ",y/\e\en/ x/[a-zA-Z_][a-zA-Z_0-9]*/ g/n/ v/../ c/num/
-.P2
-The
-.CW y/\e\en/
-(with backslash doubled to make it a literal character)
-removes the two-character sequence
-.CW \en
-from consideration, so the rest of the command will not touch it.
-There is more we could do here; for example, another
-.CW y
-could be prefixed to protect comments in the code.
-I won't elaborate the example any further, but you should have
-an idea of the way in which the looping and conditional commands
-in
-.CW sam
-may be composed to do interesting things.
-.SH
-Grouping
-.PP
-There is another way to arrange commands.
-By enclosing them in brace brackets
-.CW {} ,
-commands may be applied in parallel.
-This example uses the
-.CW =
-command, which reports the line and character numbers of dot,
-together with
-.CW p ,
-to report on appearances of
-.CW Emacs
-in our original file:
-.P1
-.WC ,p
-This manual is organized in a rather haphazard manner.  The first
-several sections were written hastily in an attempt to provide a
-general introduction to the commands in Emacs and to try to show
-the method in the madness that is the Emacs command structure.
-.ft CS
-,x/Emacs/{
-	=
-	+-p
-}
-.ft
-3; #171,#176
-general introduction to the commands in Emacs and to try to show
-4; #234,#239
-the method in the madness that is the Emacs command structure.
-.P2
-(The number before the semicolon is the line number;
-the numbers beginning with
-.CW #
-are character numbers.)
-As a more interesting example, consider changing all occurrences of
-.CW Emacs
-to
-.CW vi
-and vice versa.  We can type
-.P1
-.ft CS
-,x/Emacs|vi/{
-	g/Emacs/ c/vi/
-	g/vi/ c/Emacs/
-}
-.ft
-.P2
-or even
-.P1
-.ft CS
-,x/[a-zA-Z]+/{
-	g/Emacs/ v/....../ c/vi/
-	g/vi/ v/.../ c/Emacs/
-}
-.ft
-.P2
-to make sure we don't change strings embedded in words.
-.SH
-Multiple Changes
-.PP
-You might wonder why, once
-.CW Emacs
-has been changed to
-.CW vi
-in the above example,
-the second command in the braces doesn't put it back again.
-The reason is that the commands are run in parallel:
-within any top-level
-.CW sam
-command, all changes to the file refer to the state of the file
-before any of the changes in that command are made.
-After all the changes have been determined, they are all applied
-simultaneously.
-.PP
-This means, as mentioned, that commands within a compound
-command see the state of the file before any of the changes apply.
-This method of evaluation makes some things easier (such as the exchange of
-.CW Emacs
-and
-.CW vi ),
-and some things harder.
-For instance, it is impossible to use a
-.CW p
-command to print the changes as they happen,
-because they haven't happened when the
-.CW p
-is executed.
-An indirect ramification is that changes must occur in forward
-order through the file,
-and must not overlap.
-.SH
-Unix
-.PP
-.CW sam
-has a few commands to connect to Unix processes.
-The simplest is
-.CW ! ,
-which runs the command with input and output connected to the terminal.
-.P1
-.WC !date
-Wed May 28 23:25:21 EDT 1986
-!
-.P2
-(When downloaded, the input is connected to
-.CW /dev/null
-and only the first few lines of output are printed;
-any overflow is stored in
-.CW $HOME/sam.err .)
-The final
-.CW !
-is a prompt to indicate when the command completes.
-.PP
-Slightly more interesting is
-.CW > ,
-which provides the current text as standard input to the Unix command:
-.P1
-.WC "1,2 >wc
-      2       22      131
-!
-.P2
-The complement of
-.CW >
-is, naturally,
-.CW < :
-it replaces the current text with the standard output of the Unix command:
-.P1
-.WC "1 <date
-!
-.WC 1p
-Wed May 28 23:26:44 EDT 1986
-.P2
-The last command is
-.CW | ,
-which is a combination of
-.CW <
-and
-.CW > :
-the current text is provided as standard input to the Unix command,
-and the Unix command's standard output is collected and used to
-replace the original text.
-For example,
-.P1
-.WC ",| sort
-.P2
-runs
-.CW sort (1)
-on the file, sorting the lines of the text lexicographically.
-Note that
-.CW < ,
-.CW >
-and
-.CW |
-are
-.CW sam
-commands, not Unix shell operators.
-.PP
-The next example converts all appearances of
-.CW Emacs
-to upper case using
-.CW tr (1):
-.P1
-.WC ",x/Emacs/ | tr a-z A-Z
-.P2
-.CW tr
-is run once for each occurrence of
-.CW Emacs .
-Of course, you could do this example more efficiently with a simple
-.CW c
-command, but here's a trickier one:
-given a Unix mail box as input,
-convert all the
-.CW Subject
-headers to distinct fortunes:
-.P1
-.WC ",x/^Subject:.*\en/ x/[^:]*\en/ < /usr/games/fortune
-.P2
-(The regular expression
-.CW [^:]
-refers to any character
-.I except
-.CW :
-and newline; the negation operator
-.CW ^
-excludes newline from the list of characters.) 
-Again,
-.CW /usr/games/fortune
-is run once for each
-.CW Subject
-line, so each
-.CW Subject
-line is changed to a different fortune.
-.SH
-A few other text commands
-.PP
-For completeness, I should mention three other commands that
-manipulate text.  The
-.CW m
-command moves the current text to after the text specified by the
-(obligatory) address after the command.
-Thus
-.P1
-.WC "/Emacs/+- m 0
-.P2
-moves the next line containing
-.CW Emacs
-to the beginning of the file.
-Similarly,
-.CW t
-(another historic character) copies the text:
-.P1
-.WC "/Emacs/+- t 0
-.P2
-would make, at the beginning of the file, a copy of the next line
-containing
-.CW Emacs .
-.PP
-The third command is more interesting: it makes substitutions.
-Its syntax is
-\f(CWs/\f2pattern\f(CW/\f2replacement\f(CW/\f1.
-Within the current text, it finds the first occurrence of
-the pattern and replaces it by the replacement text,
-leaving dot set to the entire address of the substitution.
-.P1
-.WC 1p
-This manual is organized in a rather haphazard manner.  The first
-.WC s/haphazard/thoughtless/
-.WC p
-This manual is organized in a rather thoughtless manner.  The first
-.P2
-Occurrences of the character
-.CW &
-in the replacement text stand for the text matching the pattern.
-.P1
-.WC s/T/"&&&&"/
-.WC p
-"TTTT"his manual is organized in a rather thoughtless manner.  The first
-.P2
-There are two variants.  The first is that a number may be specified
-after the
-.CW s ,
-to indicate which occurrence of the pattern to substitute; the default
-is the first.
-.P1
-.WC s2/is/was/
-.WC p
-"TTTT"his manual was organized in a rather thoughtless manner.  The first
-.P2
-The second is that suffixing a
-.CW g
-(global) causes replacement of all occurrences, not just the first.
-.P1
-.WC s/[a-zA-Z]/x/g
-.WC p
-"xxxx"xxx xxxxxx xxx xxxxxxxxx xx x xxxxxx xxxxxxxxxxx xxxxxxx  xxx xxxxx
-.P2
-Notice that in all these examples
-dot is left
-set to the entire line.
-.PP
-[The substitute command is vital to
-.CW ed,
-because it is the only way to make changes within a line.
-It is less valuable in
-.CW sam ,
-in which the concept of a line is much less important.
-For example, many
-.CW ed
-substitution idioms are handled well by
-.CW sam 's
-basic commands. Consider the commands
-.P1
-s/good/bad/
-s/good//
-s/good/& bye/
-.P2
-which are equivalent in
-.CW sam
-to
-.P1
-/good/c/bad/
-/good/d
-/good/a/ bye/
-.P2
-and for which the context search is likely unnecessary because the desired
-text is already dot.
-Also, beware this
-.CW ed
-idiom:
-.P1
-1,$s/good/bad/
-.P2
-which changes the first
-.CW good
-on each line; the same command in
-.CW sam
-will only change the first one in the whole file.
-The correct
-.CW sam
-version is
-.P1
-,x s/good/bad/
-.P2
-but what is more likely meant is
-.P1
-,x/good/ c/bad/
-.P2
-.CW sam
-operates under different rules.]
-.SH
-Files
-.PP
-So far, we have only been working with a single file,
-but
-.CW sam
-is a multi-file editor.
-Only one file may be edited at a time, but
-it is easy to change which file is the `current' file for editing.
-To see how to do this, we need a
-.CW sam
-with a few files;
-the easiest way to do this is to start it
-with a list of Unix file names to edit.
-.P1
-$ \f(CSecho *.ms\f(CW
-conquest.ms death.ms emacs.ms famine.ms slaughter.ms
-$ \f(CSsam -d *.ms\f(CW
- -. conquest.ms
-.P2
-(I'm sorry the Horsemen don't appear in liturgical order.)
-The line printed by
-.CW sam
-is an indication that the Unix file
-.CW conquest.ms
-has been read, and is now the current file.
-.CW sam
-does not read the Unix file until
-the associated
-.CW sam
-file becomes current.
-.PP
-The
-.CW n
-command prints the names of all the files:
-.P1
-.WC n
- -. conquest.ms
- -  death.ms
- -  emacs.ms
- -  famine.ms
- -  slaughter.ms
-.P2
-This list is also available in the menu on mouse button 3.
-The command
-.CW f
-tells the name of just the current file:
-.P1
-.WC f
- -. conquest.ms
-.P2
-The characters to the left of the file name encode helpful information about
-the file.
-The minus sign becomes a plus sign if the file has a window open, and an
-asterisk if more than one is open.
-The period (another meaning of dot) identifies the current file.
-The leading blank changes to an apostrophe if the file is different
-from the contents of the associated Unix file, as far as
-.CW sam
-knows.
-This becomes evident if we make a change.
-.P1
-.WC 1d
-.WC f
-\&'-. conquest.ms
-.P2
-If the file is restored by an undo command, the apostrophe disappears.
-.P1
-.WC u
-.WC f
- -. conquest.ms
-.P2
-The file name may be changed by providing a new name with the
-.CW f
-command:
-.P1
-.CW "f pestilence.ms
-\&'-. pestilence.ms
-.P2
-.WC f
-prints the new status of the file,
-that is, it changes the name if one is provided, and prints the
-name regardless.
-A file name change may also be undone.
-.P1
-.WC u
-.WC f
- -. conquest.ms
-.P2
-.PP
-When
-.CW sam
-is downloaded, the current file may be changed simply by selecting
-the desired file from the menu (selecting the same file subsequently
-cycles through the windows opened on the file).
-Otherwise, the
-.CW b
-command can be used to choose the desired file:\(dg
-.FS
-\(dg A bug prevents the
-.CW b
-command from working when downloaded.
-Because the menu is more convenient anyway, and
-because the method
-of choosing files from the command language is slated to change,
-the bug hasn't been fixed.
-.FE
-.P1
-.WC "b emacs.ms
- -. emacs.ms
-.P2
-Again,
-.CW sam
-prints the name (actually, executes an implicit
-.CW f
-command) because the Unix file
-.CW emacs.ms
-is being read for the first time.
-It is an error to ask for a file
-.CW sam
-doesn't know about, but the
-.CW B
-command will prime
-.CW sam 's
-menu with a new file, and make it current.
-.P1
-.WC "b flood.pic
-?no such file `flood.pic'
-.WC "B flood.pic
- -. flood.pic
-.WC n
- -  conquest.ms
- -  death.ms
- -  emacs.ms
- -  famine.ms
- -. flood.pic
- -  slaughter.ms
-.P2
-Both
-.CW b
-and
-.CW B
-will accept a list of file names.
-.CW b
-simply takes the first file in the list, but
-.CW B
-loads them all.
-The list may be typed on one line \(em
-.P1
-.WC "B devil.tex satan.tex 666.tex emacs.tex
-.P2
-\(em or generated by a Unix command \(em
-.P1
-.WC "B <echo *.tex
-.P2
-The latter form requires a Unix command;
-.CW sam
-does not understand the shell file name metacharacters, so
-.CW "B *.tex
-attempts to load a single file named
-.CW *.tex .
-(The
-.CW <
-form is of course derived from
-.CW sam 's
-.CW <
-command.)
-.CW echo
-is not the only useful command to run subservient to
-.CW B ;
-for example,
-.P1
-.WC "B <grep -l Emacs *
-.P2
-will load only those files containing the string
-.CW Emacs .
-Finally, a special case: a
-.CW B
-with no arguments creates an empty, nameless file within
-.CW sam .
-.PP
-The complement of
-.CW B
-is
-.CW D :
-.P1
-.WC "D devil.tex satan.tex 666.tex emacs.tex
-.P2
-eradicates the files from
-.CW sam 's
-memory (not from the Unix machine's disc).
-.CW D
-without any file names removes the current file from
-.CW sam .
-.PP
-There are three other commands that relate the current file
-to Unix files.
-The
-.CW w
-command writes the file to disc;
-without arguments, it writes the entire file to the Unix file associated
-with the current file in
-.CW sam
-(it is the only command whose default address is not dot).
-Of course, you can specify an address to be written,
-and a different file name, with the obvious syntax:
-.P1
-.WC "1,2w /tmp/revelations
-/tmp/revelations: #44
-.P2
-.CW sam
-responds with the file name and the number of characters written to the file.
-The
-.CW write
-command on the button 3 menu is identical in function to an unadorned
-.CW w
-command.
-.PP
-The other two commands,
-.CW e
-and
-.CW r ,
-read data from Unix files.
-The
-.CW e
-command clears out the current file,
-reads the data from the named file (or uses the current file's old name if
-none is explicitly provided), and sets the file name.
-It's much like a
-.CW B
-command, but puts the information in the current file instead of a new one.
-.CW e
-without any file name is therefore an easy way to refresh
-.CW sam 's
-copy of a Unix file.
-[Unlike in
-.CW ed ,
-.CW e
-doesn't complain if the file is modified.  The principle is not
-to protect against things that can be undone if wrong.]
-Since its job is to replace the whole text,
-.CW e
-never takes an address.
-.PP
-The
-.CW r
-command is like
-.CW e ,
-but it doesn't clear the file:
-the text in the Unix file replaces dot, or the specified text if an
-address is given.
-.P1
-.WC "r emacs.ms
-.P2
-has essentially the effect of
-.P1
-.WC "<cat emacs.ms
-.P2
-The commands
-.CW r
-and
-.CW w
-will set the name of the file if the current file has no name already defined;
-.CW e
-sets the name even if the file already has one.
-.PP
-There is a command, analogous to
-.CW x ,
-that iterates over files instead of pieces of text:
-.CW X
-(capital
-.CW x ).
-The syntax is easy; it's just like that of
-.CW x
-\(em \f(CWX/\f2pattern\f(CW/\f2command\f1.
-(The complementary command is
-.CW Y ,
-analogous to
-.CW y .)
-The effect is to run the command in each file whose menu entry
-(that is, whose line printed by an
-.CW f
-command) matches the pattern.
-For example, since an apostrophe identifies modified files,
-.P1
-.WC "X/'/ w
-.P2
-writes the changed files out to disc.
-Here is a longer example: find all uses of a particular variable
-in the C source files:
-.P1
-.WC "X/\e.c$/ ,x/variable/+-p
-.P2
-We can use an
-.CW f
-command to identify which file the variable appears in:
-.P1
-.ft CS
-X/\e.c$/ ,g/variable/ {
-	f
-	,x/variable/+-{
-		=
-		p
-	}
-}
-.ft
-.P2
-Here, the
-.CW g
-command guarantees that only the names of files containing the variable
-will be printed (but beware that
-.CW sam
-may confuse matters by printing the names of files it reads in during
-the command).
-The
-.CW =
-command shows where in the file the variable appears, and the
-.CW p
-command prints the line.
-.PP
-The
-.CW D
-command is handy as the target of an
-.CW X .
-This example deletes from the menu all C files that do not contain
-a particular variable:
-.P1
-.WC "X/\e.c$/ ,v/variable/ D
-.P2
-If no pattern is provided for the
-.CW X ,
-the command (which defaults to
-.CW f )
-is run in all files, so
-.P1
-.WC "X D
-.P2
-cleans
-.CW sam
-up for a fresh start.
-.PP
-But rather than working any further, let's stop now:
-.P1
-.WC q
-$
-.P2
-.fi
-.PP
-Some of the file manipulating commands can be undone:
-undoing a
-.CW f ,
-.CW e ,
-or
-.CW r
-restores the previous state of the file,
-but
-.CW w ,
-.CW B
-and
-.CW D
-are irrevocable.
-And, of course, so is
-.CW q .
//GO.SYSIN DD ./doc/sam.tut.ms
echo ./doc/Sam.ad
sed s/.// > ./doc/Sam.ad <<'//GO.SYSIN DD ./doc/Sam.ad'
-*width: 500
-*height: 600
-*font: fixed
-*scrollForwardR: true
//GO.SYSIN DD ./doc/Sam.ad
echo ./doc/frame.2
sed s/.// > ./doc/frame.2 <<'//GO.SYSIN DD ./doc/frame.2'
-.TH FRAME 2X
-.SH NAME
-frinit, frsetrects, frclear, frcharofpt, frptofchar, frinsert, frdelete, frselect, frselectp, frselectf, frgetmouse \- frames of text
-.SH SYNOPSIS
-.nf
-.B
-#include <u.h>
-.B
-#include <libc.h>
-.B
-#include <libg.h>
-.B
-#include <frame.h>
-.PP
-.B
-void  frinit(Frame *f, Rectangle r, Font *ft, Bitmap *b);
-.PP
-.B
-void  frsetrects(Frame *f, Rectangle r, Bitmap *b);
-.PP
-.B
-void  frclear(Frame *f);
-.PP
-.B
-ulong frcharofpt(Frame *f, Point pt);
-.PP
-.B
-Point frptofchar(Frame *f, ulong p);
-.PP
-.B
-void  frinsert(Frame *f, Rune *r0, Rune *r1, ulong p);
-.PP
-.B
-int   frdelete(Frame *f, ulong p0, ulong p1);
-.PP
-.B
-void  frselect(Frame *f, Mouse *m);
-.PP
-.B
-void  frselectp(Frame *f, Fcode fc);
-.PP
-.B
-void  frselectf(Frame *f, Point p0, Point p1, Fcode c);
-.PP
-.B
-extern void frgetmouse(void);
-.fi
-.SH DESCRIPTION
-This library supports
-.I frames
-of editable text in a single font on bitmap displays, such as in
-.IR sam (1)
-and
-.IR 8 (1).
-Frames may hold any character except NUL (0).
-Long lines are folded and tabs are at fixed intervals.
-.PP
-The user-visible data structure, a
-.BR Frame ,
-is defined in
-.BR <frame.h> :
-.IP
-.EX
-.ta 6n +\w'Rectangle 'u +\w'lastlinefull;   'u
-typedef struct Frame Frame;
-struct Frame
-{
-	Font	*font;	/* of chars in the frame */
-	Bitmap	*b;	/* on which frame appears */
-	Rectangle	r;	/* in which text appears */
-	Rectangle	entire;	/* of full frame */
-	Frbox	*box;
-	ulong	p0, p1;	/* selection */
-	short	left;	/* left edge of text */
-	ushort	nbox, nalloc;
-	ushort	maxtab;	/* max size of tab, in pixels */
-	ushort	nchars;	/* # runes in frame */
-	ushort	nlines;	/* # lines with text */
-	ushort	maxlines;	/* total # lines in frame */
-	ushort	lastlinefull;	/* last line fills frame */
-	ushort	modified;	/* changed since frselect() */
-};
-.EE
-.PP
-.B Frbox
-is an internal type and is not used by the interface.
-.B P0
-and
-.B p1
-may be changed by the application provided the selection routines are called
-afterwards to maintain a consistent display.
-.I Maxtab
-determines the size of tab stops.
-.I Frinit
-sets it to 8 times the width of a
-.B 0
-(zero)
-character in the font;
-it may be changed before any text is added to the frame.
-The other elements of the structure are maintained by the library and
-should not be modified directly.
-.PP
-The text within frames
-is not directly addressable;
-instead frames are designed to work alongside
-another structure that holds the text.
-The typical application is to display a section of a longer document such
-as a text file or terminal session.
-Usually the application will keep its own copy of the
-text in the window (probably as
-an array of
-.BR Runes )
-and pass components of this text to the frame routines to
-display the visible portion.
-Only the text that is visible is held by the
-.BR Frame ;
-the application must check
-.BR maxlines ,
-.BR nlines ,
-and
-.B lastlinefull
-to determine, for example, whether new text needs to be appended
-at the end of the
-.B Frame
-after calling
-.I frdelete
-(q.v.). 
-.PP
-There are no routines in the library to allocate
-.BR Frames ;
-instead the interface assumes that
-.B Frames
-will be components of larger structures.
-.I Frinit
-prepares the
-.B Frame
-.I f
-so characters drawn in it will appear
-in the single
-.B Font
-.I ft.
-It then calls
-.B frsetrects
-to initialize the geometry for the
-.B Frame.
-The
-.B Bitmap
-.I b
-is where the
-.B Frame
-is to be drawn;
-.B Rectangle
-.I r
-defines the limit of the portion of the
-.B Bitmap
-the text will occupy.
-The
-.B Bitmap
-pointer
-may be null, allowing the other routines to be called to maintain the
-associated data structure in, for example, an obscured window.
-.PP
-.I Frclear
-frees the internal structures associated with
-.I f,
-permitting another
-.I frinit
-or
-.I frsetrects
-on the
-.BR Frame .
-If
-.I f
-is to be deallocated, the associated
-.B Font
-and
-.B Bitmap
-must be freed separately.
-.PP
-To reshape a
-.BR Frame ,
-use
-.I frclear
-and
-.I frinit
-and then
-.I frinsert
-(q.v.) to recreate the display.
-If a
-.B Frame
-is being moved but not reshaped, that is, if the shape of its containing
-rectangle is unchanged, it is sufficient to
-.IR bitblt (2)
-the containing rectangle from the old to the new location and then call
-.I frsetrects
-to establish the new geometry.
-No redrawing is necessary.
-.PP
-.B Frames
-hold text as runes,
-not as bytes.
-.I Frptofchar
-returns the location of the upper left corner of the
-.I p'th
-rune in the
-.B Frame
-.I f.
-If
-.I f
-holds fewer than
-.I p
-runes,
-.I frptofchar
-returns the location of the upper right corner of the last character in
-.I f.
-.I Frcharofpt
-is the inverse: it
-returns the index of the closest rune whose image's upper left corner
-is up and to the left of
-.I pt.
-.PP
-.I Frinsert
-inserts into
-.B Frame
-.I f
-starting at rune index
-.I p
-the runes between
-.I r0
-and
-.I r1.
-If a NUL (0) character
-is inserted, chaos will ensue.
-Tabs and newlines
-are handled by the library, but all other characters,
-including control characters, are just displayed.
-For example, backspaces are printed; to erase
-a character, use
-.I frdelete.
-.PP
-.I Frdelete
-deletes from the
-.B Frame
-the text between
-.I p0
-and
-.IR p1 ;
-.I p1
-points at the first rune beyond the deletion.
-.PP
-.I Frselect
-tracks the mouse to select a contiguous string of text in the
-.BR Frame .
-When called, mouse button 1 should be depressed.
-It will return when the button is released and will set
-.IB f ->p0
-and
-.IB f ->p1
-to the selected range of text.
-.I Frselectf
-and
-.I Frselectp
-modify the display of the selected text.
-.I Frselectf
-highlights the text between
-.I p0
-and
-.I p1
-(which must have been returned by
-.IR frptofochar )
-using
-.B bitblt
-in mode
-.I c.
-.I Frselectp
-is similar but highlights the text from
-.IB f ->p0
-to
-.IB f ->p1 .
-Neither
-.I frselectf
-nor
-.I frselectp
-modifies
-.IB f ->p0
-or
-.IB f ->p1 .
-.PP
-Upon return from
-.I frinsert
-or
-.I frdelete,
-the display will be consistent but
-.IB f ->p0
-and
-.IB f ->p1
-may not point to the desired selection.
-It may be necessary to adjust the selection and use
-.I frselectf
-or
-.I frselectp
-to fix the display.
-.PP
-.I Frgetmouse
-must be provided by the application;
-.I frselect
-calls it to get mouse updates.
-Each call to
-.I frgetmouse
-should update
-the
-.B Mouse
-structure pointed to by
-.I frselect's
-argument
-.I m.
-.I Frgetmouse
-should block until the mouse status has changed.
-.SH SEE ALSO
-.IR graphics (2),
-.IR bitblt (2),
-.IR cachechars (2).
//GO.SYSIN DD ./doc/frame.2
echo ./doc/rune.2
sed s/.// > ./doc/rune.2 <<'//GO.SYSIN DD ./doc/rune.2'
-.TH RUNE 2
-.SH NAME
-runetochar, chartorune, runelen, fullrune, utflen, utfrune, utfrrune, utfutf \- rune/UTF conversion
-.SH SYNOPSIS
-.B
-int	runetochar(char *s, Rune *r)
-.PP
-.B
-int	chartorune(Rune *r, char *s)
-.PP
-.B
-int	runelen(long r)
-.PP
-.B
-int	fullrune(char *s, int n)
-.PP
-.B
-int	utflen(char *s)
-.PP
-.B
-char*	utfrune(char *s, long c)
-.PP
-.B
-char*	utfrrune(char *s, long c)
-.PP
-.B
-char*	utfutf(char *s1, char *s2)
-.SH DESCRIPTION
-These routines convert to and from a
-.SM UTF
-byte stream and runes.
-.PP
-.I Runetochar
-copies one rune at
-.I r
-to at most
-.B UTFmax
-characters starting at
-.I s
-and returns the number of characters copied.
-.BR UTFmax ,
-defined as
-.B 3
-in
-.BR <libc.h> ,
-is the maximum number of bytes required to represent a rune.
-.PP
-.I Chartorune
-copies at most
-.B UTFmax
-characters starting at
-.I s
-to one rune at
-.I r
-and returns the number of characters copied.
-If the characters are not exactly in
-.SM UTF
-format,
-.I chartorune
-will convert to 0x80 and return 1.
-.PP
-.I Runelen
-returns the number of characters
-required to convert
-.I r
-into
-.SM UTF.
-.PP
-.I Fullrune
-returns 1 if the string
-.I s
-of length
-.I n
-is long enough to be decoded by
-.I chartorune
-and 0 otherwise.
-This does not guarantee that the string
-contains a legal
-.SM UTF
-encoding.
-This routine is used by programs that
-obtain input a character at
-a time and need to know when a full rune
-has arrived.
-.PP
-The following routines are analogous to the
-corresponding string routines with
-.B utf
-substituted for
-.B str
-and
-.B rune
-substituted for
-.BR chr .
-.PP
-.I Utflen
-returns the number of runes that
-are represented by the
-.SM UTF
-string
-.IR s .
-.PP
-.I Utfrune
-.RI ( utfrrune )
-returns a pointer to the first (last)
-occurrence of rune
-.I c
-in the
-.SM UTF
-string
-.IR s ,
-or 0 if
-.I c
-does not occur in the string.
-The NUL character terminating a string is considered to
-be part of the string
-.IR s .
-.PP
-.I Utfutf
-returns a pointer to the first occurrence of
-the
-.SM UTF
-string
-.I s2
-as a
-.SM UTF
-substring of
-.IR s1 ,
-or 0 if there is none.
-If
-.I s2
-is the null string,
-.I utfutf
-returns
-.IR s1 .
-.SH SEE ALSO
-.IR utf (6),
-.IR tcs (1),
//GO.SYSIN DD ./doc/rune.2
echo ./doc/regexp.6
sed s/.// > ./doc/regexp.6 <<'//GO.SYSIN DD ./doc/regexp.6'
-.TH REGEXP 6
-.SH NAME
-regexp \- regular expression notation
-.SH DESCRIPTION
-A 
-.I "regular expression"
-specifies
-a set of strings of characters.
-A member of this set of strings is said to be
-.I matched
-by the regular expression.  In many applications
-a delimiter character, commonly
-.LR / ,
-bounds a regular expression.
-In the following specification for regular expressions
-the word `character' means any character (rune) but newline.
-.PP
-The syntax for a regular expression
-.B e0
-is
-.IP
-.EX
-e3:  literal | charclass | '.' | '^' | '$' | '(' e0 ')'
-
-e2:  e3
-  |  e2 REP
-REP: '*' | '+' | '?'
-
-e1:  e2
-  |  e1 e2
-
-e0:  e1
-  |  e0 '|' e1
-.EE
-.PP
-A
-.B literal
-is any non-metacharacter or a metacharacter
-(one of
-.BR .*+?[]()|\e^$ )
-or the delimiter
-preceded by 
-.LR \e .
-.PP
-A
-.B charclass
-is a nonempty string
-.I s
-bracketed
-.BI [ \|s\| ]
-(or
-.BI [^ s\| ]\fR);
-it matches any character in (or not in)
-.I s.
-A negated character class never
-matches newline.
-A substring 
-.IB a - b ,
-with
-.I a
-and
-.I b
-in ascending
-order, stands for the inclusive
-range of
-characters between
-.I a
-and
-.IR b .
-In 
-.I s,
-the metacharacters
-.LR - ,
-.LR ] ,
-an initial
-.LR ^ ,
-and the regular expression delimiter
-must be preceded by a
-.LR \e ;
-other metacharacters 
-have no special meaning and
-may appear unescaped.
-.PP
-A 
-.L .
-matches any character.
-.PP
-A
-.L ^
-matches the beginning of a line;
-.L $
-matches the end of the line.
-.PP
-The 
-.B REP
-operators match zero or more
-.RB ( * ),
-one or more
-.RB ( + ),
-zero or one
-.RB ( ? ),
-instances respectively of the preceding regular expression 
-.BR e2 .
-.PP
-A concatenated regular expression,
-.BR "e1\|e2" ,
-matches a match to 
-.B e1
-followed by a match to
-.BR e2 .
-.PP
-An alternative regular expression,
-.BR "e0\||\|e1" ,
-matches either a match to
-.B e0
-or a match to
-.BR e1 .
-.PP
-A match to any part of a regular expression
-extends as far as possible without preventing
-a match to the remainder of the regular expression.
-.SH "SEE ALSO"
-.IR awk (1),
-.IR ed (1),
-.IR sam (1), 
-.IR sed (1),
-.IR regexp (2)
//GO.SYSIN DD ./doc/regexp.6
echo ./doc/utf.6
sed s/.// > ./doc/utf.6 <<'//GO.SYSIN DD ./doc/utf.6'
-.TH UTF 6
-.SH NAME
-UTF, Unicode, ASCII, rune \- character set and format
-.SH DESCRIPTION
-The Plan 9 character set and representation are
-based on Unicode and on a proposed X-Open multibyte
-.SM FSS-UCS-TF
-(File System Safe Universal Character
-Set Transformation Format) encoding.
-Unicode represents its characters in 16
-bits;
-.SM FSS-UCS-TF,
-or just
-.SM UTF,
-represent such
-values in an 8-bit byte stream.
-.PP
-In Plan 9, a
-.I rune
-is a 16-bit quantity representing a Unicode character.
-Internally, programs may store characters as runes.
-However, any external manifestation of textual information,
-in files or at the interface between programs, uses a
-machine-independent, byte-stream encoding called
-.SM UTF.
-.PP
-.SM UTF
-is designed so the 7-bit
-.SM ASCII
-set (values hexadecimal 00 to 7F),
-appear only as themselves
-in the encoding.
-Runes with values above 7F appear as sequences of two or more
-bytes with values only from 80 to FF.
-.PP
-The
-.SM UTF
-encoding of Unicode is backward compatible with
-.SM ASCII\c
-:
-programs presented only with
-.SM ASCII
-work on Plan 9
-even if not written to deal with
-.SM UTF,
-as do
-programs that deal with uninterpreted byte streams.
-However, programs that perform semantic processing on
-.SM ASCII
-graphic
-characters must convert from
-.SM UTF
-to runes
-in order to work properly with non-\c
-.SM ASCII
-input.
-See
-.IR rune (2).
-.PP
-Letting numbers be binary,
-a rune x is converted to a multibyte
-.SM UTF
-sequence
-as follows:
-.PP
-01. x in [00000000.0bbbbbbb]  0bbbbbbb
-.br
-10. x in [00000bbb.bbbbbbbb]  110bbbbb, 10bbbbbb
-.br
-11. x in [bbbbbbbb.bbbbbbbb]  1110bbbb, 10bbbbbb, 10bbbbbb
-.br
-.PP
-Conversion 01 provides a one-byte sequence that spans the
-.SM ASCII
-character set in a compatible way.
-Conversions 10 and 11 represent higher-valued characters
-as sequences of two or three bytes with the high bit set.
-Plan 9 does not support the 4, 5, and 6 byte sequences proposed by X-Open.
-When there are multiple ways to encode a value, for example rune 0,
-the shortest encoding is used.
-.PP
-In the inverse mapping,
-any sequence except those described above
-is incorrect and is converted to rune 0080.
-.SH FILES
-.TF /lib/unicode
-.TP
-.B /lib/unicode
-table of characters and descriptions, suitable for
-.IR look (1).
-.SH "SEE ALSO"
-.IR ascii (1),
-.IR tcs (1),
-.IR rune (2),
-.IR keyboard (6),
-.IR "The Unicode Standard" .
//GO.SYSIN DD ./doc/utf.6
echo ./doc/add.3
sed s/.// > ./doc/add.3 <<'//GO.SYSIN DD ./doc/add.3'
-.TH ADD 3G
-.SH NAME
-add, sub, mul, divpt, raddp, rsubp, rmul, rdiv, rshift, inset, rcanon, eqpt, eqrect, ptinrect, rectXrect, rectclip, Dx, Dy, Pt, Rect, Rpt \- arithmetic on points and rectangles
-.SH SYNOPSIS
-.B #include "libg.h"
-.PP
-.B
-.ta 12n +12n +12n +12n +12n
-Point	add(Point p, Point q)
-.PP
-.B
-Point	sub(Point p, Point q)
-.PP
-.B
-Point	mul(Point p, int a)
-.PP
-.B
-Point	divpt(Point p, int a)
-.PP
-.B
-Rectangle	raddp(Rectangle r, Point p)
-.PP
-.B
-Rectangle	rsubp(Rectangle r, Point p)
-.PP
-.B
-Rectangle	rmul(Rectangle r, int a)
-.PP
-.B
-Rectangle	rdiv(Rectangle r, int a)
-.PP
-.B
-Rectangle	rshift(Rectangle r, int a)
-.PP
-.B
-Rectangle	inset(Rectangle r, int n)
-.PP
-.B
-Rectangle	rcanon(Rectangle r)
-.PP
-.B
-int	eqpt(Point p, Point q)
-.PP
-.B
-int	eqrect(Rectangle r, Rectangle s)
-.PP
-.B
-int	ptinrect(Point p, Rectangle r)
-.PP
-.B
-int	rectXrect(Rectangle r, Rectangle s)
-.PP
-.B
-int	rectclip(Rectangle *rp, Rectangle b)
-.PP
-.B
-int	Dx(Rectangle r);
-.PP
-.B
-int	Dy(Rectangle r);
-.PP
-.B
-Point	Pt(int x, int y)
-.PP
-.B
-Rectangle	Rect(int x0, int y0, int x1, int y1)
-.PP
-.B
-Rectangle	Rpt(Point p, Point q)
-.SH DESCRIPTION
-The functions
-.IR Pt ,
-.I Rect
-and
-.I Rpt
-construct geometrical data types from their components.
-These are implemented as macros.
-.PP
-.I Add
-returns the Point
-sum of its arguments:
-.BI Pt( p .x+ q .x,
-.IB p .y+ q .y).
-.I Sub
-returns the Point
-difference of its arguments:
-.BI Pt( p .x- q .x,
-.IB p .y- q .y).
-.I Mul
-returns the Point
-.BI Pt( p .x* a ,
-.IB p .y* a ).
-.I Divpt
-returns the Point
-.BI Pt( p .x/ a ,
-.IB p .y/ a ).
-.PP
-.I Raddp
-returns the Rectangle
-.BI Rect(add( r .min,
-.IB p ),
-.BI add( r .max,
-.IB p ))\fR;
-.I rsubp
-returns the Rectangle
-.BI Rpt(sub( r .min,
-.IB p ),
-.BI sub( r .max,
-.IB p ))\fR.
-.I Rmul
-returns the Rectangle
-.BI Rpt(mul( r .min, a ),
-.BI mul( r .max, a ))\fR;
-.I Rdiv
-returns the Rectangle
-.BI Rpt(div( r .min, a ),
-.BI div( r .max, a ))\fR.
-.PP
-.I Rshift
-returns the rectangle
-.I r
-with all coordinates either left-shifted or right-shifted by
-.IR a ,
-depending on whether
-.I a
-is positive or negative, respectively.
-.PP
-.I Inset
-returns the Rectangle
-.BI Rect( r .min.x+ n ,
-.IB r .min.y+ n ,
-.IB r .max.x- n ,
-.IB r .max.y- n ) .
-.PP
-.I Rcanon
-returns a rectangle with the same extent as
-.IR r ,
-canonicalized so that
-.B min.x
-.if t \(<=
-.if n <=
-.BR max.x ,
-and
-.B min.y
-.if t \(<=
-.if n <=
-.BR max.y .
-.PP
-.I Eqpt
-compares its argument Points and returns
-0 if unequal,
-1 if equal.
-.I Eqrect
-does the same for its argument Rectangles.
-.PP
-.I Ptinrect
-returns 1 if
-.I p
-is a point within
-.IR r ,
-and 0 otherwise.
-.PP
-.I RectXrect
-returns 1 if
-.I r
-and
-.I s
-share any point, and 0 otherwise.
-.PP
-.I Rectclip
-clips in place
-the Rectangle pointed to by
-.I rp
-so that it is completely contained within
-.IR b .
-The return value is 1 if any part of
-.RI * rp
-is within
-.IR b .
-Otherwise, the return value is 0 and
-.RI * rp
-is unchanged.
-.PP
-The functions
-.I Dx
-and
-.I Dy
-give the width (delta x) and height (delta y) of a Rectangle.
-They are implemented as macros.
-.SH SEE ALSO
-.IR graphics (3)
//GO.SYSIN DD ./doc/add.3
echo ./doc/balloc.3
sed s/.// > ./doc/balloc.3 <<'//GO.SYSIN DD ./doc/balloc.3'
-.TH BALLOC 3G
-.SH NAME
-balloc, bfree, rdbitmap, wrbitmap, rdbitmapfile, wrbitmapfile \- allocating, freeing, reading, writing bitmaps
-.SH SYNOPSIS
-.nf
-.PP
-.B
-#include "libg.h"
-.PP
-.ta \w'\fLBitmap 'u
-.B
-Bitmap	*balloc(Rectangle r, int ldepth)
-.PP
-.B
-void	bfree(Bitmap *b)
-.PP
-.B
-void	rdbitmap(Bitmap *b, int miny, int maxy, uchar *data)
-.PP
-.B
-void	wrbitmap(Bitmap *b, int miny, int maxy, uchar *data)
-.PP
-.B
-Bitmap	*rdbitmapfile(int fd)
-.PP
-.B
-void	wrbitmapfile(int fd, Bitmap *b)
-.SH DESCRIPTION
-A new bitmap is allocated with
-.BR balloc ;
-it will have the extent and depth given by its arguments,
-and will be filled with zeros. The
-.I id
-field will have been set to the identifying number used by
-.F /dev/bitblt
-(see
-.IR bit (5)),
-and the
-.I cache
-field will be zero.
-.I Balloc
-returns 0 if the server has run out of bitmap resources.
-.B Bfree
-frees the resources used by its argument bitmap.
-.PP
-The remaining functions deal with moving groups of pixel
-values between bitmaps and user space or external files.
-There is a fixed format for the bitmap data in user space or on
-external files.
-A pixel with x-coordinate =
-.I x
-in a bitmap with
-.B ldepth
-=
-.I l
-will appear as
-.if t \fIw\fP = 2\u\s8\fIl\fP\s10\d
-.if n w = 2^l
-contiguous bits in a byte, with the pixel's high order bit
-starting at the byte's bit number
-.if t \fIw\fP\(mu(\fIx\fP mod 8/\fIw\fP),
-.if n w*(x mod 8/w),
-where bits within a byte are numbered 0 to 7 from the
-high order to the low order bit.
-If
-.I w
-is greater than 8, it is a multiple of 8, so
-pixel values take up an integral number of bytes.
-A
-.I row
-of bitmap
-.I b
-consists of the byte containing pixel
-.IB b .r.min.x
-and all the bytes up to and including the byte containing pixel
-.IB b .r.min.x\fR\(mi1.
-.PP
-.I Rdbitmap
-reads rows of pixels from bitmap
-.I b
-into
-.IR data .
-The rows read have
-.IR y = ymin , ymin "+1, ... "
-.IR ymax \(mi1.
-Those rows must be within the range allowed by
-.IB b .r.
-.PP
-.B Wrbitmap
-replaces the specified rows of pixels in bitmap
-.I b
-with
-.IR data .
-.PP
-.I Rdbitmapfile
-creates a bitmap from data contained an external file;
-.I fd
-should be a file descriptor obtained by opening such a file for reading.
-The external file should start with 5 ASCII integers:
-.BR ldepth ,
-.BR r.min.x ,
-.BR r.min.y ,
-.BR r.max.x ,
-and
-.BR r.max.y .
-Each number is right-justified in 11 characters, followed by a blank.
-The rows of bitmap data, formatted as described above,
-follow the header.
-The returned bitmap is allocated using
-.I balloc .
-.I Rdbitmapfile
-returns 0 if the server has run out of bitmap resources.
-.PP
-.I Wrbitmapfile
-writes bitmap
-.I b
-onto file descriptor
-.IR fd ,
-which should be open for writing.
-The format is as just described for
-.IR rdbitmapfile .
-.PP
-.I Rdbitmapfile
-and
-.I wrbitmapfile
-don't close
-.IR fd .
-.PP
-.SH DIAGNOSTICS
-Some errors can occur when accessing the internal bitmaps,
-when trying to malloc, or when trying to read or write the
-argument file descriptors;
-the graphics error function (see
-.IR graphics (2))
-is called when this happens.
-.SH "SEE ALSO"
-.IR graphics (3),
-.IR bitblt (3).
//GO.SYSIN DD ./doc/balloc.3
echo ./doc/bitblt.3
sed s/.// > ./doc/bitblt.3 <<'//GO.SYSIN DD ./doc/bitblt.3'
-.TH BITBLT 3G
-.SH NAME
-bitblt, bitbltclip, point, segment, circle, disc, ellipse, texture, border, string, strsize, strwidth, Fcode \- graphics functions
-.SH SYNOPSIS
-.nf
-.B #include "libg.h"
-.PP
-.ta \w'\fLPoint 'u
-.B
-void	bitblt(Bitmap *db, Point dp, Bitmap *sb,
-.B
-	    Rectangle sr, Fcode f)
-.PP
-.B
-void	bitbltclip(void *)
-.PP
-.B
-void	point(Bitmap *b, Point p, int v, Fcode f);
-.PP
-.B
-void	segment(Bitmap *b, Point p, Point q, int v, Fcode f)
-.PP
-.B
-void	circle(Bitmap *b, Point p, int r, int v, Fcode f);
-.PP
-.B
-void	disc(Bitmap *b, Point p, int r, int v, Fcode);
-.PP
-.B
-void	ellipse(Bitmap *b, Point p, int a, int b, int v, Fcode f);
-.PP
-.B
-void	texture(Bitmap *b, Rectangle r, Bitmap *t, Fcode f)
-.PP
-.B
-void	border(Bitmap *b, Rectangle r, int w, Fcode f)
-.PP
-.B
-Point	string(Bitmap *b, Point p, Font *ft, char *s, Fcode f)
-.PP
-.B
-Point	strsize(Font *ft, char *s)
-.PP
-.B
-long	strwidth(Font *ft, char *s)
-.PP
-.ft L
-.ta 8n +\w'xxxxxxxxxx'u +\w'xxxxxxxxxx'u +\w'xxxxxxxxxx'u +\w'xxxxxxxxxx'u
-enum Fcode {
-	Zero,	DnorS,	DandnotS,	notS,
-	notDandS,	notD,	DxorS,	DnandS,
-	DandS,	DxnorS,	D,	DornotS,
-	S,	notDorS,	DorS,	F
-} Fcode;
-.ft P
-.fi
-.SH DESCRIPTION
-.I Bitblt
-(bit-block transfer)
-takes bits from rectangle
-.I sr
-in the
-.I source
-Bitmap,
-.IR sb,
-and overlays them on a congruent rectangle with the
-.B min
-corner at point
-.B dp
-in the
-.I destination
-bitmap,
-.IR db .
-The
-.I f
-parameter says how to compute each destination pixel
-as a function of the source and destination pixels.
-The first sixteen codes in 
-.B Fcode
-give all possible boolean operations
-on the source,
-.B S 
-and destination
-.BR D .
-The code values have been arranged so that they may be expressed as
-boolean operations on the values
-.B S
-and
-.BR D.
-So, for example,
-.B D|S
-computes the result as the logical
-.I or
-of the destination pixel's old value and the overlaying source pixel's value.
-If pixels are more than one bit deep, the operations are bitwise.
-The
-.B Zero
-and
-.B F
-codes result in new pixel values that are all zeros or all ones, respectively.
-.PP
-If the source and destination bitmaps have different depths,
-the source rectangle is first converted to have the same depth as the
-destination, as follows:
-conversion to a smaller number of bits per pixel is accomplished by
-taking the desired number of high order bits;
-conversion to a larger number of bits per pixel is accomplished by
-putting the small value into the high order bits, and replicating it as many times
-as necessary to fill the lower order bits.
-.PP
-All of the drawing graphics functions clip the rectangle against the
-source and destination bitmaps, so that only
-pixels within the destination bitmap are changed, and none are changed
-that would have come from areas outside the source bitmap.
-.I Bitbltclip
-takes a pointer to the first argument of a
-.I bitblt
-argument list, and modifies
-.I dp
-and
-.I sr
-so that no more clipping is needed.
-.PP
-.I Point
-changes the value of the destination point
-.I p
-in bitmap
-.I b
-according to function code
-.IR f .
-The source is a pixel with
-value
-.IR v .
-.PP
-.IR Segment ,
-.IR circle ,
-.IR disc ,
-and
-.I ellipse
-all draw in bitmap
-.I b
-with function code
-.I f
-and a source pixel with value
-.IR v.
-.I Segment
-draws a line segment in bitmap
-.I b
-from point
-.I p
-to
-.IR q .
-The segment is half-open:
-.I p
-is the first point of the segment and
-.I q
-is the first point beyond the segment,
-so adjacent segments sharing endpoints abut.
-.I Circle
-draws a circle with radius
-.I r
-and center at point
-.IR p .
-.I Disc
-is the same except that it fills the circle.
-.I Ellipse
-draws an ellipse with horizontal semi-axis
-.I a
-and vertical semi-axis
-.IR b.
-.PP
-.I Border
-draws, with function
-.I f
-in bitmap
-.IR b ,
-the rectangular outline with lines of width
-.IR w ,
-fitting just inside rectangle
-.IR r .
-.PP
-.I Texture
-draws, with function
-.I f
-in bitmap
-.IR b ,
-a texture using the
-bitmap specified by
-.IR t .
-The texture bitmap is aligned on
-.IR b 's
-coordinate system so that (0,0) in both coordinate systems coincide,
-and then
-.I t
-is replicated to form a tiling of
-.IR b .
-The tiling is clipped to rectangle
-.I r
-in
-.IR b ,
-and then transferred to
-.I b
-using the specified function.
-.PP
-.I String
-draws the text characters given by the null-terminated string
-.I s
-into bitmap
-.IR b ,
-using font
-.IR ft.
-The upper left corner of the first character (i.e., a point
-that is
-.IB ft ->ascent
-above the baseline) is placed at point
-.IR p ,
-and subsequent characters are placed on the same baseline, displaced to
-the right by the previous character's
-.BR width .
-The individual characters are
-.IR bitblt 'ed
-into the destination, using drawing function
-.IR f .
-.I String
-returns the point in the destination bitmap after the final character of
-.I s
-(or where the final character would be drawn, assuming no clipping;
-the returned value might be outside the destination bitmap).
-.PP
-The bounding box for text to be drawn with
-.I string
-in font
-.I ft
-can be found with
-.IR strsize ;
-it returns the
-.B max
-point of the bounding box, assuming a
-.B min
-point of (0,0).
-.I Strwidth
-returns the
-.IR x -component
-of the
-.B max
-point.
-.SH SEE ALSO
-.IR graphics (3)
//GO.SYSIN DD ./doc/bitblt.3
echo ./doc/event.3
sed s/.// > ./doc/event.3 <<'//GO.SYSIN DD ./doc/event.3'
-.TH EVENT 3G
-.SH NAME
-event, einit, estart, eread, emouse, ekbd, ecanread, ecanmouse, ecankbd, ereshaped, getrect, menuhit, Event, Mouse, Menu \- graphics events
-.SH SYNOPSIS
-.nf
-.PP
-.B
-#include	"libg.h"
-.ta \w'\fLunsigned long 'u
-.PP
-.B
-void	einit(ulong keys)
-.PP
-.B
-unsigned long	event(Event *e)
-.PP
-.B
-Mouse	emouse(void)
-.PP
-.B
-int	ekbd(void)
-.PP
-.B
-int	ecanmouse(void)
-.PP
-.B
-int	ecankbd(void)
-.PP
-.B
-unsigned long	estart(ulong key, int fd, int n)
-.PP
-.B
-unsigned long	etimer(ulong key, int n)
-.PP
-.B
-unsigned long	eread(ulong keys, Event *e)
-.PP
-.B
-int	ecanread(ulong keys)
-.PP
-.B
-void	ereshaped(Rectangle r)
-.PP
-.B
-Rectangle	getrect(int but, Mouse *m)
-.PP
-.B
-int	menuhit(int but, Mouse *m, Menu *menu)
-.PP
-.B
-enum{
-	Emouse = 1,
-	Ekeyboard = 2,
-}
-.fi
-.SH DESCRIPTION
-These routines provide an interface to multiple sources of input.
-To use them,
-.I einit
-must be called.
-If the argument to
-.I enit
-has the Emouse and Ekeyboard bits set,
-the mouse and keyboard events will be enabled;
-in this case,
-.IR xtbinit
-(see
-.IR graphics (3))
-must have already been called.
-The user must provide a function called
-.IR ereshaped ,
-which will be called whenever the window in which the process
-is running has been reshaped; the argument will be the Rectangle
-for the new window shape, including the border.
-.PP
-As characters are typed on the keyboard, they are read by the
-event mechanism and put in a queue.
-.I Ekbd
-returns the next character from the queue, blocking until the
-queue is non-empty.
-The characters are read by the event mechanism from the keyboard
-so they are available as soon as they are typed.
-.PP
-When the mouse moves or a mouse button is depressed or released,
-a new mouse event is queued by the event mechanism.
-.I Emouse
-returns the next mouse event from the queue, blocking until the
-queue is non-empty.
-.I Emouse
-returns a
-.B Mouse
-structure:
-.IP
-.EX
-.ta 6n +\w'unsigned long 'u
-struct Mouse
-{
-	int	buttons;
-	Point	xy;
-	unsigned long	msec;
-};
-.EE
-.PP
-.B Buttons
-is a bit field;
-.B buttons&1
-is set when the left mouse button is depressed,
-.B buttons&2
-when the middle button is depressed,
-and
-.B buttons&4
-when the right button is depressed.
-The current mouse position is always returned in
-.BR xy .
-.B Msec
-is a millisecond-resolution timestamp.
-.PP
-.I Ecankbd
-and
-.I ecanmouse
-return non-zero when there are keyboard or mouse events to available
-to be read.
-.PP
-.I Estart
-can be used to register additional file descriptors.
-It takes as arguments the file descriptor to register,
-the maximum length of an event message on that descriptor,
-and a key to be used in accessing the event.
-The key must be a power of 2 and must not confilict with any previous keys.
-If a zero key is given, one which is not used will be chosen and returned.
-.B
-Ekeyboard
-and
-.B Emouse
-are the mouse and keyboard event keys.
-.PP
-.I Etimer
-starts a timer with a period of n milliseconds (default 1 second).
-Only one timer can be started.
-Extra timer events are not queued and the timer channel has no associated data.
-.PP
-.I Eread
-waits for the next event specified by the mask
-.B keys
-of event keys submitted to estart.
-It fills in the appropriate field of the argument
-.B Event
-structure, which looks like:
-.IP
-.EX
-struct Event
-{
-	int	kbdc;
-	Mouse	mouse;
-	int	n;
-	uchar	data[EMAXMSG];
-}
-.EE
-.PP
-.B Data
-is an array which is large enough to hold a plan 9 protocol message.
-.I Eread
-returns the key for the event which was chosen.
-For example, if a mouse event was read,
-.I Emouse
-will be returned.
-.PP
-.I Event
-waits for the next event of any kind.
-The return is the same as for
-.IR eread .
-.PP
-As described in
-.IR graphics (3),
-the graphics functions are buffered.
-.IR Event ,
-.IR eread ,
-.IR emouse ,
-and
-.I ekbd
-all cause a buffer flush unless there is an event of the
-appropriate type ready to return.
-.PP
-.I Getrect
-is used to prompt the user to sweep a rectangle.
-It should be called with
-.I m
-holding the mouse event that triggered the
-.I getrect
-(or, if none, a
-.B Mouse
-with
-.B buttons
-set to 7).
-It changes to the sweep cursor,
-waits for the buttons to all go up,
-and then waits for button number
-.I but
-to be depressed, marking the initial corner.
-If another button is depressed instead,
-.I getrect
-returns a rectangle
-with zero for both corners, after
-waiting for all the buttons to be released.
-Otherwise,
-.I getrect
-continually draws the swept rectangle
-until the button is released again, and returns the swept rectangle.
-The mouse structure pointed to by
-.I m
-will contain the final mouse event.
-.PP
-.I Menuhit
-displays a menu and returns a seleced menu item number.
-It should be called with
-.I m
-holding the mouse event that triggered the
-.I menuhit .
-A
-.B Menu
-is a structure:
-.IP
-.EX
-struct Menu
-{
-	char	**item;
-	char	*(*gen)(int);
-	int	lasthit;
-}
-.EE
-.PP
-If
-.B item
-is nonzero, it should be a null-terminated array of the character strings
-to be displayed as menu items.
-Otherwise,
-.B gen
-should be a function that, given an item number, returns the character
-string for that item, or zero if the number is past the end of the list.
-Items are numbered starting at zero.
-.I Menuhit
-waits until
-.I but
-is released, and then returns the number of the selection,
-or \(mi1 for no selection.
-The
-.I m
-argument is filled in with the final mouse event.
-.SH "SEE ALSO"
-.IR graphics (3)
//GO.SYSIN DD ./doc/event.3
echo ./doc/graphics.3
sed s/.// > ./doc/graphics.3 <<'//GO.SYSIN DD ./doc/graphics.3'
-.TH GRAPHICS 3G
-.SH NAME
-Point, Rectangle, Bitmap, Font, Fontchar, Cursor, xtbinit, bclose, berror, bscreenrect, bflush, cursorswitch, cursorset, getfont \- graphics
-.SH SYNOPSIS
-.nf
-.PP
-.ft L
-#include "libg.h"
-.ft P
-.PP
-.ta \w'\fLextern Bitmap 'u
-.B
-void	xtbinit(void (*errfun)(char *), char *font, int *pargc, char **argv)
-.PP
-.B
-void	bclose(void)
-.PP
-.B
-void	berror(char *msg)
-.PP
-.B
-Rectangle	bscreenrect(Rectangle *clipr)
-.PP
-.B
-void	bflush(void)
-.PP
-.B
-int	clipr(Bitmap *b, Rectangle cr)
-.PP
-.B
-void	cursorswitch(Cursor *curs)
-.PP
-.B
-void	cursorset(Point p)
-.PP
-.B
-Font	getfont(char *name)
-.PP
-.B
-extern Bitmap	screen
-.PP
-.B
-extern Font	*font
-.fi
-.SH DESCRIPTION
-A
-.B Point
-is a location in a bitmap
-(see below),
-such as the screen, and is defined as:
-.IP
-.EX
-.ta 6n
-typedef
-struct Point {
-	int x;
-	int y;
-} Point;
-.EE
-.PP
-The coordinate system has
-.I x
-increasing to the right and
-.I y
-increasing down.
-.PP
-A
-.B Rectangle
-is a rectangular area in a bitmap.
-.IP
-.EX
-.ta 6n
-typedef
-struct Rectangle {
-	Point min;      /* upper left */
-	Point max;      /* lower right */
-} Rectangle;
-.EE
-.PP
-By definition,
-.B min.x <= max.x
-and
-.BR "min.y <= max.y" .
-By convention, the right (maximum
-.IR x )
-and bottom (maximum
-.IR y )
-edges are
-excluded from the represented rectangle, so abutting rectangles have no
-points in common.
-Thus,
-.B max
-contains the coordinates of the first point beyond the rectangle.
-.PP
-A 
-.B Bitmap
-holds a rectangular image.
-.IP
-.EX
-.ta 6n +\w'Rectangle 'u +\w'ldepth;     'u
-typedef
-struct Bitmap {
-	Rectangle	r;	/* rectangle in data area, local coords */
-	Rectangle	clipr;	/* clipping region */
-	int	ldepth;	/* log base 2 of number of bits per pixel */
-	int	id;	/* id as known in /dev/bitblt */
-	Bitmap*	cache;	/* zero; distinguishes bitmap from layer */
-} Bitmap;
-.EE
-.PP
-.B R.min
-is the location in the bitmap
-of the upper-leftmost point in the image.
-There are
-.if t .I 2\u\s8ldepth\s10\d
-.if n 2^ldepth
-contiguous bits for each pixel of the image;
-the bits form a binary number giving the pixel value.
-.B Clipr
-is the clipping region; typically it is the same as
-.B r
-except in a window, where it is inset by the width of
-the border.
-.I Clipr
-sets the clipping rectangle of
-.B b
-to
-.BR cr ;
-it returns 0 (and does nothing) if
-.I cr
-does not intersect
-.B b->r ;
-otherwise it returns 1.
-.PP
-A
-.I Font
-is  a character set.
-The
-.B Font
-structure contains two important fields for a font user:
-.LR ascent ,
-the distance from the top of the highest character to the baseline,
-and
-.LR height ,
-the distance from the top of the highest character to the bottom of
-the lowest character (and hence, the interline spacing).
-The width of any particular character
-.L r
-in a font is returned by
-.IR charwidth.
-The width is defined as the amount to add to the horizontal position
-after drawing the character.
-.PP
-A
-.I Cursor
-is put in this structure:
-.IP
-.EX
-.ta 6n +\w'unsigned char 'u
-struct	Cursor
-{
-	Point	offset;
-	unsigned char	clr[2*16];
-	unsigned char	set[2*16];
-};
-.EE
-.PP
-The arrays are to be arranged in rows, two characters per row, to give 16 rows
-of 16 bits each.
-A cursor is displayed on the screen by adding
-.B offset
-to the current mouse position, using
-.B clr
-as a mask to zero the pixels where
-.B clr
-is 1, and then setting all pixels to ones where
-.B set
-is one.
-.PP
-The function
-.I xtbinit
-should be called before using any graphics operations.
-The
-.I errfun
-argument is a function that will be called with an error message
-argument when the graphics functions detect an error;
-such an error function should not return.
-A zero for the
-.I errfun
-argument means use
-.IR berror ,
-which prints the message and exits.
-The
-.I class
-argument is the name of the class of X application, or zero for to
-use the capitalized version of the program name.
-The
-.I pargc
-and
-.I argv
-arguments should be a pointer to the main program's
-.I argc
-and
-.IR argv ;
-any standard toolkit options in the argument list will be used
-to initialize the window's options, and after
-.I xtbinit
-returns, those options will have been removed fromthe argument list.
-.B Xtbinit
-sets up the global
-.I screen
-to be a bitmap describing the area of the screen that the program
-can use.
-.I Xtbinit
-also initializes the global default
-.IR font .
-.PP
-.I Bclose
-releases the resources allocated by
-.I xtbinit
-and the other graphics functions.
-It usually isn't necessary, since the resources will be released
-on program exit.
-.PP
-The
-.IB screen .r
-field is not maintained across `reshape' events; use
-.I bscreenrect
-to discover the current size
-(see
-.IR event (3));
-a non-null
-.B cr
-will be filled in with the screen's clip rectangle.
-.PP
-The mouse cursor is always displayed.
-The initial cursor is an arrow.
-.I Cursorswitch
-causes the argument cursor to be displayed instead.
-A zero argument causes a switch back to the arrow cursor.
-.I Cursorset
-moves the mouse cursor to position
-.I p ,
-provided (if in a window) that the requesting program is
-executing in the current window and the mouse is within
-the window boundaries; otherwise
-.I cursorset
-is a no-op.
-.PP
-The graphics functions described in
-.IR bitblt (3)
-and
-.IR balloc (3)
-are implemented by writing commands to the X server;
-the writes are buffered, so the functions may not take effect immediately.
-.I Bflush
-flushes the buffer, doing all pending graphics operations.
-.I Xtbinit
-arranges that
-.I bflush
-will be called on exit,
-and the following graphics functions all cause a flush:
-.IR balloc ,
-.IR bfree ,
-.IR bscreenrect ,
-.IR cursorset ,
-.IR cursorswitch ,
-.IR ecankbd ,
-.IR ecanmouse ,
-.IR ekbd ,
-.IR emouse ,
-.IR event ,
-.IR rdbitmap ,
-and
-.IR wrbitmap .
-.PP
-.I Getfont
-attempts to load the X font given by
-.IR name ;
-it returns a pointer to a
-.B Font
-struct if it succeeds, zero otherwise.
-.SH "SEE ALSO"
-.IR add (3),
-.IR balloc (3),
-.IR bitblt (3),
-.IR event (3)
//GO.SYSIN DD ./doc/graphics.3
echo ./doc/rgbpix.3
sed s/.// > ./doc/rgbpix.3 <<'//GO.SYSIN DD ./doc/rgbpix.3'
-.TH RGBPIX 3G
-.SH NAME
-RGB, rgbpix, rdcolmap, wrcolmap
-.SH SYNOPSIS
-.nf
-.PP
-.ft L
-#include "libg.h"
-.ft P
-.PP
-.ta \w'\fLunsigned long 'u
-.B
-unsigned long	rgbpix(Bitmap *b, RGB rgb)
-.PP
-.B
-void	rdcolmap(Bitmap *b, RGB *map)
-.PP
-.B
-void	wrcolmap(Bitmap *b, RGB *map)
-.fi
-.SH DESCRIPTION
-Colors are described by the red, green, and blue
-light intensities, in an
-.B RGB
-datum:
-.IP
-.EX
-.ta 6n
-typedef
-struct RGB {
-	unsigned long red;
-	unsigned long green;
-	unsigned long blue;
-} RGB;
-.EE
-.PP
-Zero intensity means there is no component of the given color;
-hence, black is represented by zero in all three positions and
-white has the maximum unsigned long value in all three positions.
-.PP
-Some of the graphics functions, such as
-.I point
-(see
-.IR bitblt (3)),
-take a
-.I pixel value
-argument, which is a single unsigned long.
-For a given bitmap,
-.I rgbpix
-returns the pixel value with a color closest to
-the color represented by the
-.I rgb
-argument.
-.PP
-There is a
-.I colormap
-associated with each Bitmap.  A colormap is an array of
-.BR RGB s,
-of length
-.if t 2\u\s82\u\s6\fIldepth\fP\d\d\s10,
-.if n 2^(2^\fIldepth\fP),
-giving the colors for pixels 0, 1, 2, etc.
-.PP
-.I Rdcolormap
-reads the colormap for the given bitmap into the provided
-.IR map ,
-which must have enough space to hold it.
-.I Wrcolormap
-associates the given colormap with the given bitmap, if possible.
-(The hardware might not allow this.)
-.SH BUGS
-These functions only work for the screen bitmap.
-This interface will have to be refined for screens with
-ldepth > 3.
-.SH "SEE ALSO"
-.IR graphics (3)
//GO.SYSIN DD ./doc/rgbpix.3
echo ./Makefile
sed s/.// > ./Makefile <<'//GO.SYSIN DD ./Makefile'
-#
-#	master makefile for sam.  configure sub-makefiles first.
-#
-
-all:	lXg lframe samdir samtermdir
-
-lXg:
-	cd libXg; make
-lframe:
-	cd libframe; make
-
-samdir:
-	cd sam; make
-
-samtermdir:
-	cd samterm; make
-
-install:
-	cd libXg; make clean
-	cd libframe; make clean
-	cd sam; make clean
-	cd samterm; make clean
-
-clean:
-	cd libXg; make clean
-	cd libframe; make clean
-	cd sam; make clean
-	cd samterm; make clean
//GO.SYSIN DD ./Makefile
echo ./sam/Makefile
sed s/.// > ./sam/Makefile <<'//GO.SYSIN DD ./sam/Makefile'
-#
-#	define operating system.  ONE of: -DIRIX -DSUNOS -DUMIPS -DSYSVR3
-#	
-#	Additionally, -D_POSIX_SOURCE (or its equivalent) may be specified
-#	if your compiler supports posix-compatible compilation
-OS=-DIRIX -ansiposix
-
-#	add -Iincludedir for any include directories that need to be searched
-#	for posix header files (for UMIPS, add -I/usr/include/posix)
-INCS=-I../libframe
-
-#	Set the name of the environment variable containing the user's home directory
-HOMEDIR=HOME
-
-#	RSAMNAME and TERMNAME contain the names of the files containing the
-#	sam and samterm executables, respectively.  SAMDIR is the directory
-#	where sam is to be installed.
-RSAMNAME=sam
-TERMNAME=/v/bin/samterm
-SAMDIR=/usr/bin
-
-#	Set TMP to a good place for tmp files (with lots of room)
-TMP=/usr/tmp
-
-#	Set SHELLNAME and SHELLPATH to the name of a shell and the pathname
-#	of its executable
-SHELLNAME=sh
-SHELLPATH=/bin/sh
-
-#	Set RXNAME and RXPATHNAME to the name of the remote execution command
-#	and the pathname of its executable
-RXNAME=rsh
-RXPATHNAME=/usr/bsd/rsh
-
-CFLAGS=$(OS) -D_LIBXG_EXTENSION $(INCS)
-
-SYSFLAGS=  -DHOMEDIR=\"$(HOMEDIR)\" -DRSAMNAME=\"$(RSAMNAME)\" \
-		-DTERMNAME=\"$(TERMNAME)\" -DTMP=\"$(TMP)\" \
-		-DSHELLNAME=\"$(SHELLNAME)\" -DSHELLPATH=\"$(SHELLPATH)\" \
-		-DRXNAME=\"$(RXNAME)\" -DRXPATHNAME=\"$(RXPATHNAME)\" 
-
-LIB=../libframe/libframe.a
-CC=cc
-
-OBJ=sam.o address.o buffer.o cmd.o disc.o error.o file.o io.o \
-	list.o mesg.o moveto.o multi.o rasp.o regexp.o shell.o \
-	string.o sys.o unix.o xec.o
-
-all:    sam
-
-sam:	$(OBJ) $(LIB)
-	$(CC) -o sam $(OBJ) $(LIB)
-
-clean:
-	rm -f *.o core
-
-install:	sam 
-	cp sam $(SAMDIR)/$(RSAMNAME)
-
-$(OBJ):	sam.h ../libframe/u.h errors.h mesg.h
-
-cmd.o:	parse.h
-xec.o:	parse.h
-
-unix.o:	sam.h ../libframe/u.h errors.h mesg.h
-	$(CC) -c $(CFLAGS) $(SYSFLAGS) unix.c
//GO.SYSIN DD ./sam/Makefile
echo ./libframe/Makefile
sed s/.// > ./libframe/Makefile <<'//GO.SYSIN DD ./libframe/Makefile'
-#
-#	define operating system.  ONE of: -DIRIX -DSUNOS -DUMIPS -DSYSVR3
-#	
-#	Additionally, -D_POSIX_SOURCE (or its equivalent) may be specified
-#	if your compiler supports posix-compatible compilation
-OS=-DIRIX -ansiposix
-
-#	add -Iincludedir for any include directories that need to be searched
-#	for posix header files (for UMIPS, add -I/usr/include/posix)
-INCS=-I. -I../libXg
-
-#	add name of library orderer - use ":" if none exists
-RANLIB=:
-
-#	add name of library
-AR=ar
-
-CFLAGS=-c $(OS) $(INCS) -D_LIBXG_EXTENSION
-
-LIB=libframe.a
-CC=cc
-
-OBJ=frbox.o frdelete.o frdraw.o frinit.o frinsert.o frptofchar.o\
-	frselect.o frstr.o frutil.o misc.o rune.o
-
-all:	$(LIB)
-
-$(LIB):	$(OBJ)
-	$(AR) rv $(LIB) $(OBJ)
-	$(RANLIB) $(LIB)
-	rm -f $(OBJ)
-
-clean:
-	rm -f *.o core
-
-install:	$(LIB)
-
-$(OBJ):	u.h frame.h
//GO.SYSIN DD ./libframe/Makefile
echo ./samterm/Makefile
sed s/.// > ./samterm/Makefile <<'//GO.SYSIN DD ./samterm/Makefile'
-#
-#	define operating system.  ONE of: -DIRIX -DSUNOS -DUMIPS -DSYSVR3
-#	
-#	Additionally, -D_POSIX_SOURCE (or its equivalent) may be specified
-#	if your compiler supports posix-compatible compilation
-OS=-DIRIX -ansiposix
-
-#	add -Iincludedir for any include directories that need to be searched
-#	for posix header files (for UMIPS, add -I/usr/include/posix)
-INCS=-I../libframe -I../libXg
-
-#	SAMTERM contains the name of the file containing the samterm
-#	executable.  SAMTERMDIR is the directory where it is installed.
-SAMTERM=samterm
-SAMTERMDIR=/bin
-
-#	set directory where libXg.a is installed and libg.h lives
-LIBXGDIR=../libXg
-
-#	set this if your X libraries are in different locations
-#	or if you need extra libraries to load with X11 applications
-XLIBS=/usr/local/X11R5/lib/libXt.a /usr/local/X11R5/lib/libX11.a
-
-CFLAGS=$(OS) $(INCS) -D_LIBXG_EXTENSION
-
-LIBS=../libframe/libframe.a $(LIBXGDIR)/libXg.a
-CC=cc
-
-OBJ=main.o flayer.o icons.o io.o menu.o mesg.o rasp.o scroll.o unix.o
-
-all:	samterm
-
-samterm:	$(OBJ) $(LIBS)
-	$(CC) -o samterm $(OBJ) $(LIBS) $(XLIBS)
-
-clean:
-	rm -f *.o core
-
-install:	samterm
-	cp samterm $(SAMTERMDIR)/$(SAMTERM)
-
-$(OBJ):	samterm.h flayer.h ../libframe/u.h ../sam/mesg.h
//GO.SYSIN DD ./samterm/Makefile
echo ./libXg/Makefile
sed s/.// > ./libXg/Makefile <<'//GO.SYSIN DD ./libXg/Makefile'
-#
-#	define operating system.  ONE of: -DIRIX -DSUNOS -DUMIPS -DSYSVR3
-#	
-#	Additionally, -D_POSIX_SOURCE (or its equivalent) may be specified
-#	if your compiler supports posix-compatible compilation
-OS=-DIRIX -ansiposix
-
-#	add -Iincludedir for any include directories that need to be searched
-INCS=
-
-#	set this if your X libraries are in different locations
-#	or if you need extra libraries to load with X11 applications
-XLIBS=/usr/local/X11R5/lib/libXt.a /usr/local/X11R5/lib/libX11.a
-
-#	add name of library orderer - use ":" if none
-RANLIB=:
-
-#	add name of librarian
-AR=ar
-
-#	the name of the library
-LIB=libXg.a
-
-CFLAGS=$(OS) -D_LIBXG_EXTENSION $(INCS) $(XCFLAGS)
-CC=cc
-
-OBJS=	arc.o arith.o balloc.o bitblt.o bitbltclip.o border.o bscreenrect.o \
-	circle.o clipline.o clipr.o cursorset.o cursorswitch.o disc.o ellipse.o\
-	gcs.o getrect.o gwin.o latin1.o menuhit.o point.o rdbitmap.o\
-	rdbitmapfile.o rectclip.o segment.o string.o strwidth.o texture.o wrbitmap.o \
-	wrbitmapfile.o xtbinit.o
-
-install:	$(LIB)
-compile:	$(LIB)
-test:	test.o
-	$(CC) -o $@ $? $(LIB) $(XLIBS) -lm
-	echo try running test
-clean:
-	rm -f *.o test
-
-nuke:	clean
-	rm -f $(LIB)
-
-$(LIB):	$(OBJS)
-	$(AR) rv $(LIB) $(OBJS)
-	$(RANLIB) $(LIB)
-	rm $(OBJS)
-
-$(LIB)(%.o): %.o
//GO.SYSIN DD ./libXg/Makefile
echo ./sam/Make.irix
sed s/.// > ./sam/Make.irix <<'//GO.SYSIN DD ./sam/Make.irix'
-#
-#	define operating system.  ONE of: -DIRIX -DSUNOS -DUMIPS -DSYSVR3
-#	
-#	Additionally, -D_POSIX_SOURCE (or its equivalent) may be specified
-#	if your compiler supports posix-compatible compilation
-OS=-DIRIX -ansiposix
-
-#	add -Iincludedir for any include directories that need to be searched
-#	for posix header files (for UMIPS, add -I/usr/include/posix)
-INCS=-I../libframe
-
-#	Set the name of the environment variable containing the user's home directory
-HOMEDIR=HOME
-
-#	RSAMNAME and TERMNAME contain the names of the files containing the
-#	sam and samterm executables, respectively.  SAMDIR is the directory
-#	where sam is to be installed.
-RSAMNAME=sam
-TERMNAME=/v/bin/samterm
-SAMDIR=/usr/bin
-
-#	Set TMP to a good place for tmp files (with lots of room)
-TMP=/usr/tmp
-
-#	Set SHELLNAME and SHELLPATH to the name of a shell and the pathname
-#	of its executable
-SHELLNAME=sh
-SHELLPATH=/bin/sh
-
-#	Set RXNAME and RXPATHNAME to the name of the remote execution command
-#	and the pathname of its executable
-RXNAME=rsh
-RXPATHNAME=/usr/bsd/rsh
-
-CFLAGS=$(OS) -D_LIBXG_EXTENSION $(INCS)
-
-SYSFLAGS=  -DHOMEDIR=\"$(HOMEDIR)\" -DRSAMNAME=\"$(RSAMNAME)\" \
-		-DTERMNAME=\"$(TERMNAME)\" -DTMP=\"$(TMP)\" \
-		-DSHELLNAME=\"$(SHELLNAME)\" -DSHELLPATH=\"$(SHELLPATH)\" \
-		-DRXNAME=\"$(RXNAME)\" -DRXPATHNAME=\"$(RXPATHNAME)\" 
-
-LIB=../libframe/libframe.a
-CC=cc
-
-OBJ=sam.o address.o buffer.o cmd.o disc.o error.o file.o io.o \
-	list.o mesg.o moveto.o multi.o rasp.o regexp.o shell.o \
-	string.o sys.o unix.o xec.o
-
-all:    sam
-
-sam:	$(OBJ) $(LIB)
-	$(CC) -o sam $(OBJ) $(LIB)
-
-clean:
-	rm -f *.o core
-
-install:	sam 
-	cp sam $(SAMDIR)/$(RSAMNAME)
-
-$(OBJ):	sam.h ../libframe/u.h errors.h mesg.h
-
-cmd.o:	parse.h
-xec.o:	parse.h
-
-unix.o:	sam.h ../libframe/u.h errors.h mesg.h
-	$(CC) -c $(CFLAGS) $(SYSFLAGS) unix.c
//GO.SYSIN DD ./sam/Make.irix
echo ./samterm/Make.irix
sed s/.// > ./samterm/Make.irix <<'//GO.SYSIN DD ./samterm/Make.irix'
-#
-#	define operating system.  ONE of: -DIRIX -DSUNOS -DUMIPS -DSYSVR3
-#	
-#	Additionally, -D_POSIX_SOURCE (or its equivalent) may be specified
-#	if your compiler supports posix-compatible compilation
-OS=-DIRIX -ansiposix
-
-#	add -Iincludedir for any include directories that need to be searched
-#	for posix header files (for UMIPS, add -I/usr/include/posix)
-INCS=-I../libframe -I../libXg
-
-#	SAMTERM contains the name of the file containing the samterm
-#	executable.  SAMTERMDIR is the directory where it is installed.
-SAMTERM=samterm
-SAMTERMDIR=/bin
-
-#	set directory where libXg.a is installed and libg.h lives
-LIBXGDIR=../libXg
-
-#	set this if your X libraries are in different locations
-#	or if you need extra libraries to load with X11 applications
-XLIBS=/usr/local/X11R5/lib/libXt.a /usr/local/X11R5/lib/libX11.a
-
-CFLAGS=$(OS) $(INCS) -D_LIBXG_EXTENSION
-
-LIBS=../libframe/libframe.a $(LIBXGDIR)/libXg.a
-CC=cc
-
-OBJ=main.o flayer.o icons.o io.o menu.o mesg.o rasp.o scroll.o unix.o
-
-all:	samterm
-
-samterm:	$(OBJ) $(LIBS)
-	$(CC) -o samterm $(OBJ) $(LIBS) $(XLIBS)
-
-clean:
-	rm -f *.o core
-
-install:	samterm
-	cp samterm $(SAMTERMDIR)/$(SAMTERM)
-
-$(OBJ):	samterm.h flayer.h ../libframe/u.h ../sam/mesg.h
//GO.SYSIN DD ./samterm/Make.irix
echo ./libframe/Make.irix
sed s/.// > ./libframe/Make.irix <<'//GO.SYSIN DD ./libframe/Make.irix'
-#
-#	define operating system.  ONE of: -DIRIX -DSUNOS -DUMIPS -DSYSVR3
-#	
-#	Additionally, -D_POSIX_SOURCE (or its equivalent) may be specified
-#	if your compiler supports posix-compatible compilation
-OS=-DIRIX -ansiposix
-
-#	add -Iincludedir for any include directories that need to be searched
-#	for posix header files (for UMIPS, add -I/usr/include/posix)
-INCS=-I. -I../libXg
-
-#	add name of library orderer - use ":" if none exists
-RANLIB=:
-
-#	add name of library
-AR=ar
-
-CFLAGS=-c $(OS) $(INCS) -D_LIBXG_EXTENSION
-
-LIB=libframe.a
-CC=cc
-
-OBJ=frbox.o frdelete.o frdraw.o frinit.o frinsert.o frptofchar.o\
-	frselect.o frstr.o frutil.o misc.o rune.o
-
-all:	$(LIB)
-
-$(LIB):	$(OBJ)
-	$(AR) rv $(LIB) $(OBJ)
-	$(RANLIB) $(LIB)
-	rm -f $(OBJ)
-
-clean:
-	rm -f *.o core
-
-install:	$(LIB)
-
-$(OBJ):	u.h frame.h
//GO.SYSIN DD ./libframe/Make.irix
echo ./libXg/Make.irix
sed s/.// > ./libXg/Make.irix <<'//GO.SYSIN DD ./libXg/Make.irix'
-#
-#	define operating system.  ONE of: -DIRIX -DSUNOS -DUMIPS -DSYSVR3
-#	
-#	Additionally, -D_POSIX_SOURCE (or its equivalent) may be specified
-#	if your compiler supports posix-compatible compilation
-OS=-DIRIX -ansiposix
-
-#	add -Iincludedir for any include directories that need to be searched
-INCS=
-
-#	set this if your X libraries are in different locations
-#	or if you need extra libraries to load with X11 applications
-XLIBS=/usr/local/X11R5/lib/libXt.a /usr/local/X11R5/lib/libX11.a
-
-#	add name of library orderer - use ":" if none
-RANLIB=:
-
-#	add name of librarian
-AR=ar
-
-#	the name of the library
-LIB=libXg.a
-
-CFLAGS=$(OS) -D_LIBXG_EXTENSION $(INCS) $(XCFLAGS)
-CC=cc
-
-OBJS=	arc.o arith.o balloc.o bitblt.o bitbltclip.o border.o bscreenrect.o \
-	circle.o clipline.o clipr.o cursorset.o cursorswitch.o disc.o ellipse.o\
-	gcs.o getrect.o gwin.o latin1.o menuhit.o point.o rdbitmap.o\
-	rdbitmapfile.o rectclip.o segment.o string.o strwidth.o texture.o wrbitmap.o \
-	wrbitmapfile.o xtbinit.o
-
-install:	$(LIB)
-compile:	$(LIB)
-test:	test.o
-	$(CC) -o $@ $? $(LIB) $(XLIBS) -lm
-	echo try running test
-clean:
-	rm -f *.o test
-
-nuke:	clean
-	rm -f $(LIB)
-
-$(LIB):	$(OBJS)
-	$(AR) rv $(LIB) $(OBJS)
-	$(RANLIB) $(LIB)
-	rm $(OBJS)
-
-$(LIB)(%.o): %.o
//GO.SYSIN DD ./libXg/Make.irix
echo ./sam/Make.sun
sed s/.// > ./sam/Make.sun <<'//GO.SYSIN DD ./sam/Make.sun'
-#
-#	define operating system.  ONE of: -DIRIX -DSUNOS -DUMIPS -DSYSVR3
-#	
-#	Additionally, -D_POSIX_SOURCE (or its equivalent) may be specified
-#	if your compiler supports posix-compatible compilation
-OS=-D_POSIX_SOURCE -DSUNOS
-
-#	add -Iincludedir for any include directories that need to be searched
-#	for posix header files (for UMIPS, add -I/usr/include/posix)
-INCS=-I../libframe
-
-#	Set the name of the environment variable containing the user's home directory
-HOMEDIR=HOME
-
-#	RSAMNAME and TERMNAME contain the names of the files containing the
-#	sam and samterm executables, respectively.  SAMDIR is the directory
-#	where sam is to be installed.
-RSAMNAME=sam
-TERMNAME=/usr/local/bin/samterm
-SAMDIR=/usr/local/bin
-
-#	Set TMP to a good place for tmp files (with lots of room)
-TMP=/usr/tmp
-
-#	Set SHELLNAME and SHELLPATH to the name of a shell and the pathname
-#	of its executable
-SHELLNAME=sh
-SHELLPATH=/bin/sh
-
-#	Set RXNAME and RXPATHNAME to the name of the remote execution command
-#	and the pathname of its executable
-RXNAME=rsh
-RXPATHNAME=/usr/ucb/rsh
-
-CFLAGS=$(OS) -fno-builtin -D_LIBXG_EXTENSION $(INCS)
-
-SYSFLAGS=  -DHOMEDIR=\"$(HOMEDIR)\" -DRSAMNAME=\"$(RSAMNAME)\" \
-		-DTERMNAME=\"$(TERMNAME)\" -DTMP=\"$(TMP)\" \
-		-DSHELLNAME=\"$(SHELLNAME)\" -DSHELLPATH=\"$(SHELLPATH)\" \
-		-DRXNAME=\"$(RXNAME)\" -DRXPATHNAME=\"$(RXPATHNAME)\" 
-
-LIB=../libframe/libframe.a
-CC=gcc
-
-OBJ=sam.o address.o buffer.o cmd.o disc.o error.o file.o io.o \
-	list.o mesg.o moveto.o multi.o rasp.o regexp.o shell.o \
-	string.o sys.o unix.o xec.o
-
-all:    sam
-
-sam:	$(OBJ)
-	$(CC) -o sam $(OBJ) $(LIB)
-
-clean:
-	rm -f *.o core
-
-install:	sam
-	cp sam $(SAMDIR)/$(RSAMNAME)
-
-$(OBJ):	sam.h ../libframe/u.h errors.h mesg.h
-
-cmd.o:	parse.h
-xec.o:	parse.h
-
-unix.o:	sam.h ../libframe/u.h errors.h mesg.h
-	$(CC) -c $(CFLAGS) $(SYSFLAGS) unix.c
//GO.SYSIN DD ./sam/Make.sun
echo ./samterm/Make.sun
sed s/.// > ./samterm/Make.sun <<'//GO.SYSIN DD ./samterm/Make.sun'
-#
-#	define operating system.  ONE of: -DIRIX -DSUNOS -DUMIPS -DSYSVR3
-#	
-#	Additionally, -D_POSIX_SOURCE (or its equivalent) may be specified
-#	if your compiler supports posix-compatible compilation
-OS=-D_POSIX_SOURCE -DSUNOS
-
-#	add -Iincludedir for any include directories that need to be searched
-#	for posix header files (for UMIPS, add -I/usr/include/posix)
-INCS=-I../libframe -I../libXg
-
-#	SAMTERM contains the name of the file containing the samterm
-#	executable.  SAMTERMDIR is the directory where it is installed.
-SAMTERM=samterm
-SAMTERMDIR=/bin
-
-#	set directory where libXg.a is installed and libg.h lives
-LIBXGDIR=../libXg
-
-#	set this if your X libraries are in different locations
-#	or if you need extra libraries to load with X11 applications
-XLIBS=/usr/openwin/lib/libXt.a /usr/openwin/lib/libX11.a
-
-CFLAGS=$(OS) $(INCS) -fno-builtin -D_LIBXG_EXTENSION
-
-LIBS=../libframe/libframe.a $(LIBXGDIR)/libXg.a $(XLIBS)
-CC=gcc
-
-OBJ=main.o flayer.o icons.o io.o menu.o mesg.o rasp.o scroll.o unix.o
-
-all:	samterm
-
-samterm:	$(OBJ) $(LIBS)
-	$(CC) -o samterm $(OBJ) $(LIBS) $(XLIBS)
-
-clean:
-	rm -f *.o core
-
-install:	samterm
-	cp samterm $(SAMTERMDIR)/$(SAMTERM)
-
-$(OBJ):	samterm.h flayer.h ../libframe/u.h ../sam/mesg.h
//GO.SYSIN DD ./samterm/Make.sun
echo ./libframe/Make.sun
sed s/.// > ./libframe/Make.sun <<'//GO.SYSIN DD ./libframe/Make.sun'
-#
-#	define operating system.  ONE of: -DIRIX -DSUNOS -DUMIPS -DSYSVR3
-#	
-#	Additionally, -D_POSIX_SOURCE (or its equivalent) may be specified
-#	if your compiler supports posix-compatible compilation
-OS=-D_POSIX_SOURCE -DSUNOS
-
-#	add -Iincludedir for any include directories that need to be searched
-#	for posix header files (for UMIPS, add -I/usr/include/posix)
-INCS=-I. -I../libXg
-
-#	add name of library orderer - use ":" if none exists
-RANLIB=ranlib
-
-#	add name of library
-AR=ar
-
-CFLAGS=-c -fno-builtin $(OS) $(INCS) -D_LIBXG_EXTENSION
-
-LIB=libframe.a
-CC=gcc
-
-OBJ=frbox.o frdelete.o frdraw.o frinit.o frinsert.o frptofchar.o\
-	frselect.o frstr.o frutil.o misc.o rune.o
-
-all:	$(LIB)
-
-$(LIB):	$(OBJ)
-	$(AR) rv $(LIB) $(OBJ)
-	$(RANLIB) $(LIB)
-	rm -f $(OBJ)
-
-clean:
-	rm -f *.o core $(LIB)
-
-install:	$(LIB)
-
-$(OBJ):	u.h frame.h
//GO.SYSIN DD ./libframe/Make.sun
echo ./libXg/Make.sun
sed s/.// > ./libXg/Make.sun <<'//GO.SYSIN DD ./libXg/Make.sun'
-#
-#	define operating system.  ONE of: -DIRIX -DSUNOS -DUMIPS -DSYSVR3
-#	
-#	Additionally, -D_POSIX_SOURCE (or its equivalent) may be specified
-#	if your compiler supports posix-compatible compilation
-OS=-D_POSIX_SOURCE -DSUNOS
-
-#	add -Iincludedir for any include directories that need to be searched
-INCS=-I/usr/openwin/include
-
-#	set this if your X libraries are in different locations
-#	or if you need extra libraries to load with X11 applications
-XLIBS=/usr/openwin/lib/libXt.a /usr/openwin/lib/libX11.a
-
-#	add name of library orderer - use ":" if none
-RANLIB=ranlib
-
-#	add name of librarian
-AR=ar
-
-#	the name of the library
-LIB=libXg.a
-
-CFLAGS=$(OS) -fno-builtin -D_LIBXG_EXTENSION $(INCS) $(XCFLAGS)
-CC=gcc
-
-OBJS=	arc.o arith.o balloc.o bitblt.o bitbltclip.o border.o bscreenrect.o \
-	circle.o clipline.o clipr.o cursorset.o cursorswitch.o disc.o ellipse.o\
-	gcs.o getrect.o gwin.o latin1.o menuhit.o point.o rdbitmap.o\
-	rdbitmapfile.o rectclip.o segment.o string.o strwidth.o texture.o wrbitmap.o \
-	wrbitmapfile.o xtbinit.o
-
-install:	$(LIB)
-compile:	$(LIB)
-test:	test.o
-	$(CC) -o $@ $? $(LIB) $(XLIBS) -lm
-	echo try running test
-clean:
-	rm -f *.o test
-
-nuke:	clean
-	rm -f $(LIB)
-
-$(LIB):	$(OBJS)
-	$(AR) rv $(LIB) $(OBJS)
-	$(RANLIB) $(LIB)
-	rm $(OBJS)
-
-$(LIB)(%.o): %.o
-#
-#%.o:	%.c
-#	$(CC) -c $(CFLAGS) $?
//GO.SYSIN DD ./libXg/Make.sun
echo ./sam/Make.v10
sed s/.// > ./sam/Make.v10 <<'//GO.SYSIN DD ./sam/Make.v10'
-#
-#	define operating system.  ONE of: -DIRIX -DSUNOS -DUMIPS -DSYSVR3
-#	
-#	Additionally, -D_POSIX_SOURCE (or its equivalent) may be specified
-#	if your compiler supports posix-compatible compilation
-OS=-D_POSIX_SOURCE
-
-#	add -Iincludedir for any include directories that need to be searched
-#	for posix header files (for UMIPS, add -I/usr/include/posix)
-INCS=-I../libframe
-
-#	Set the name of the environment variable containing the user's home directory
-HOMEDIR=HOME
-
-#	RSAMNAME and TERMNAME contain the names of the files containing the
-#	sam and samterm executables, respectively.  SAMDIR is the directory
-#	where sam is to be installed.
-RSAMNAME=sam
-TERMNAME=/usr/bin/samterm
-SAMDIR=/usr/bin
-
-#	Set TMP to a good place for tmp files (with lots of room)
-TMP=/usr/tmp
-
-#	Set SHELLNAME and SHELLPATH to the name of a shell and the pathname
-#	of its executable
-SHELLNAME=sh
-SHELLPATH=/bin/sh
-
-#	Set RXNAME and RXPATHNAME to the name of the remote execution command
-#	and the pathname of its executable
-RXNAME=rsh
-RXPATHNAME=/usr/bin/rsh
-
-CFLAGS=$(OS) -D_LIBXG_EXTENSION $(INCS)
-
-SYSFLAGS=  -DHOMEDIR=\"$(HOMEDIR)\" -DRSAMNAME=\"$(RSAMNAME)\" \
-		-DTERMNAME=\"$(TERMNAME)\" -DTMP=\"$(TMP)\" \
-		-DSHELLNAME=\"$(SHELLNAME)\" -DSHELLPATH=\"$(SHELLPATH)\" \
-		-DRXNAME=\"$(RXNAME)\" -DRXPATHNAME=\"$(RXPATHNAME)\" 
-
-LIB=../libframe/libframe.a
-CC=pcc
-
-OBJ=sam.o address.o buffer.o cmd.o disc.o error.o file.o io.o \
-	list.o mesg.o moveto.o multi.o rasp.o regexp.o shell.o \
-	string.o sys.o unix.o xec.o
-
-all:    sam
-
-sam:	$(OBJ) $(LIB)
-	$(CC) -o sam $(OBJ) $(LIB) /v/ape/lib/libap.a -lc
-clean:
-	rm -f *.o core
-
-install:	sam
-	cp sam $(SAMDIR)/$(RSAMNAME)
-
-$(OBJ):	sam.h ../libframe/u.h errors.h mesg.h
-
-cmd.o:	parse.h
-xec.o:	parse.h
-
-unix.o:	sam.h ../libframe/u.h errors.h mesg.h
-	$(CC) -c $(CFLAGS) $(SYSFLAGS) unix.c
//GO.SYSIN DD ./sam/Make.v10
echo ./samterm/Make.v10
sed s/.// > ./samterm/Make.v10 <<'//GO.SYSIN DD ./samterm/Make.v10'
-#
-#	define operating system.  ONE of: -DIRIX -DSUNOS -DUMIPS -DSYSVR3
-#	
-#	Additionally, -D_POSIX_SOURCE (or its equivalent) may be specified
-#	if your compiler supports posix-compatible compilation
-OS=-D_POSIX_SOURCE
-
-#	add -Iincludedir for any include directories that need to be searched
-#	for posix header files (for UMIPS, add -I/usr/include/posix)
-INCS=-I../libframe -I../libXg
-
-#	SAMTERM contains the name of the file containing the samterm
-#	executable.  SAMTERMDIR is the directory where it is installed.
-SAMTERM=samterm
-SAMTERMDIR=/usr/bin
-
-#	set directory where libXg.a is installed and libg.h lives
-LIBXGDIR=../libXg
-
-#	set this if your X libraries are in different locations
-#	or if you need extra libraries to load with X11 applications
-XLIBS=-lXt -lX11
-
-CFLAGS=$(OS) $(INCS) -D_LIBXG_EXTENSION
-
-LIBS=../libframe/libframe.a $(LIBXGDIR)/libXg.a
-CC=pcc
-
-OBJ=main.o flayer.o icons.o io.o menu.o mesg.o rasp.o scroll.o unix.o
-
-all:	samterm
-
-samterm:	$(OBJ) $(LIBS)
-	$(CC) -o samterm $(OBJ) $(LIBS) $(XLIBS) -lipc -lc
-
-clean:
-	rm -f *.o core
-
-install:	samterm
-	cp samterm $(SAMTERMDIR)/$(SAMTERM)
-
-$(OBJ):	samterm.h flayer.h ../libframe/u.h ../sam/mesg.h
//GO.SYSIN DD ./samterm/Make.v10
echo ./libframe/Make.v10
sed s/.// > ./libframe/Make.v10 <<'//GO.SYSIN DD ./libframe/Make.v10'
-#
-#	define operating system.  ONE of: -DIRIX -DSUNOS -DUMIPS -DSYSVR3
-#	
-#	Additionally, -D_POSIX_SOURCE (or its equivalent) may be specified
-#	if your compiler supports posix-compatible compilation
-OS=-D_POSIX_SOURCE
-
-#	add -Iincludedir for any include directories that need to be searched
-#	for posix header files (for UMIPS, add -I/usr/include/posix)
-INCS=-I. -I../libXg
-
-#	add name of library orderer - use ":" if none exists
-RANLIB=ranlib
-
-#	add name of library
-AR=ar
-
-CFLAGS=-c $(OS) $(INCS) -D_LIBXG_EXTENSION
-
-LIB=libframe.a
-CC=pcc
-
-OBJ=frbox.o frdelete.o frdraw.o frinit.o frinsert.o frptofchar.o\
-	frselect.o frstr.o frutil.o misc.o rune.o
-
-all:	$(LIB)
-
-$(LIB):	$(OBJ)
-	$(AR) rv $(LIB) $(OBJ)
-	$(RANLIB) $(LIB)
-	rm -f $(OBJ)
-
-clean:
-	rm -f *.o core
-
-install:	$(LIB)
-
-$(OBJ):	u.h frame.h
//GO.SYSIN DD ./libframe/Make.v10
echo ./libXg/Make.v10
sed s/.// > ./libXg/Make.v10 <<'//GO.SYSIN DD ./libXg/Make.v10'
-#
-#	define operating system.  ONE of: -DIRIX -DSUNOS -DUMIPS -DSYSVR3
-#	
-#	Additionally, -D_POSIX_SOURCE (or its equivalent) may be specified
-#	if your compiler supports posix-compatible compilation
-OS=-D_POSIX_SOURCE -Dv10
-
-#	add -Iincludedir for any include directories that need to be searched
-INCS=
-
-#	set this if your X libraries are in different locations
-#	or if you need extra libraries to load with X11 applications
-XLIBS=-lXt -lX11
-
-#	add name of library orderer - use ":" if none
-RANLIB=ranlib
-
-#	add name of librarian
-AR=ar
-
-#	the name of the library
-LIB=libXg.a
-
-CFLAGS=$(OS) -D_LIBXG_EXTENSION $(INCS) $(XCFLAGS)
-CC=pcc
-
-OBJS=	arc.o arith.o balloc.o bitblt.o bitbltclip.o border.o bscreenrect.o \
-	circle.o clipline.o clipr.o cursorset.o cursorswitch.o disc.o ellipse.o\
-	gcs.o getrect.o gwin.o latin1.o menuhit.o point.o rdbitmap.o\
-	rdbitmapfile.o rectclip.o segment.o string.o strwidth.o texture.o wrbitmap.o \
-	wrbitmapfile.o xtbinit.o
-
-install:	$(LIB)
-compile:	$(LIB)
-test:	test.o
-	$(CC) -o $@ $? $(LIB) $(XLIBS) -lm
-	echo try running test
-clean:
-	rm -f *.o test
-
-nuke:	clean
-	rm -f $(LIB)
-
-$(LIB):	$(OBJS)
-	$(AR) rv $(LIB) $(OBJS)
-	$(RANLIB) $(LIB)
-	rm $(OBJS)
-
-$(LIB)(%.o): %.o
-
-%.o:	%.c
-	$(CC) -c $(CFLAGS) $?
//GO.SYSIN DD ./libXg/Make.v10
echo ./sam/Make.mips
sed s/.// > ./sam/Make.mips <<'//GO.SYSIN DD ./sam/Make.mips'
-#
-#	define operating system.  ONE of: -DIRIX -DSUNOS -DUMIPS -DSYSVR3
-#	
-#	Additionally, -D_POSIX_SOURCE (or its equivalent) may be specified
-#	if your compiler supports posix-compatible compilation
-OS=-DUMIPS
-
-#	add -Iincludedir for any include directories that need to be searched
-#	for posix header files (for UMIPS, add -I/usr/include/posix)
-INCS=-I../libframe -I/usr/include/posix
-
-#	Set the name of the environment variable containing the user's home directory
-HOMEDIR=HOME
-
-#	RSAMNAME and TERMNAME contain the names of the files containing the
-#	sam and samterm executables, respectively.  SAMDIR is the directory
-#	where sam is to be installed.
-RSAMNAME=sam
-TERMNAME=/usr/local/bin/samterm
-SAMDIR=/usr/local/bin
-
-#	Set TMP to a good place for tmp files (with lots of room)
-TMP=/usr/tmp
-
-#	Set SHELLNAME and SHELLPATH to the name of a shell and the pathname
-#	of its executable
-SHELLNAME=sh
-SHELLPATH=/bin/sh
-
-#	Set RXNAME and RXPATHNAME to the name of the remote execution command
-#	and the pathname of its executable
-RXNAME=rsh
-RXPATHNAME=/usr/ucb/rsh
-
-CFLAGS=$(OS) -D_LIBXG_EXTENSION $(INCS)
-
-SYSFLAGS=  -DHOMEDIR=\"$(HOMEDIR)\" -DRSAMNAME=\"$(RSAMNAME)\" \
-		-DTERMNAME=\"$(TERMNAME)\" -DTMP=\"$(TMP)\" \
-		-DSHELLNAME=\"$(SHELLNAME)\" -DSHELLPATH=\"$(SHELLPATH)\" \
-		-DRXNAME=\"$(RXNAME)\" -DRXPATHNAME=\"$(RXPATHNAME)\" 
-
-LIB=../libframe/libframe.a
-CC=cc
-
-OBJ=sam.o address.o buffer.o cmd.o disc.o error.o file.o io.o \
-	list.o mesg.o moveto.o multi.o rasp.o regexp.o shell.o \
-	string.o sys.o unix.o xec.o
-
-all:    sam
-
-sam:	$(OBJ) $(LIB)
-	$(CC) -o sam $(OBJ) $(LIB)
-
-clean:
-	rm -f *.o core
-
-install:	sam 
-	cp sam $(SAMDIR)/$(RSAMNAME)
-
-$(OBJ):	sam.h ../libframe/u.h errors.h mesg.h
-
-cmd.o:	parse.h
-xec.o:	parse.h
-
-unix.o:	sam.h ../libframe/u.h errors.h mesg.h
-	$(CC) -c $(CFLAGS) $(SYSFLAGS) unix.c
//GO.SYSIN DD ./sam/Make.mips
echo ./samterm/Make.mips
sed s/.// > ./samterm/Make.mips <<'//GO.SYSIN DD ./samterm/Make.mips'
-#
-#	define operating system.  ONE of: -DIRIX -DSUNOS -DUMIPS -DSYSVR3
-#	
-#	Additionally, -D_POSIX_SOURCE (or its equivalent) may be specified
-#	if your compiler supports posix-compatible compilation
-OS=-DUMIPS
-
-#	add -Iincludedir for any include directories that need to be searched
-#	for posix header files (for UMIPS, add -I/usr/include/posix)
-INCS=-I../libframe -I../libXg -I/usr/include/posix
-
-#	SAMTERM contains the name of the file containing the samterm
-#	executable.  SAMTERMDIR is the directory where it is installed.
-SAMTERM=samterm
-SAMTERMDIR=/bin
-
-#	set directory where libXg.a is installed and libg.h lives
-LIBXGDIR=../libXg
-
-#	set this if your X libraries are in different locations
-#	or if you need extra libraries to load with X11 applications
-XLIBS=-lXt -lX11 -lbsd
-
-CFLAGS=$(OS) $(INCS) -D_LIBXG_EXTENSION
-
-LIBS=../libframe/libframe.a $(LIBXGDIR)/libXg.a
-CC=cc
-
-OBJ=main.o flayer.o icons.o io.o menu.o mesg.o rasp.o scroll.o unix.o
-
-all:	samterm
-
-samterm:	$(OBJ) $(LIBS)
-	$(CC) -o samterm $(OBJ) $(LIBS) $(XLIBS)
-
-clean:
-	rm -f *.o core
-
-install:	samterm
-	cp samterm $(SAMTERMDIR)/$(SAMTERM)
-
-$(OBJ):	samterm.h flayer.h ../libframe/u.h ../sam/mesg.h
//GO.SYSIN DD ./samterm/Make.mips
echo ./libframe/Make.mips
sed s/.// > ./libframe/Make.mips <<'//GO.SYSIN DD ./libframe/Make.mips'
-#
-#	define operating system.  ONE of: -DIRIX -DSUNOS -DUMIPS -DSYSVR3
-#	
-#	Additionally, -D_POSIX_SOURCE (or its equivalent) may be specified
-#	if your compiler supports posix-compatible compilation
-OS=-DUMIPS
-
-#	add -Iincludedir for any include directories that need to be searched
-#	for posix header files (for UMIPS, add -I/usr/include/posix)
-INCS=-I. -I../libXg -I/usr/include/posix
-
-#	add name of library orderer - use ":" if none exists
-RANLIB=:
-
-#	add name of library
-AR=ar
-
-CFLAGS=-c $(OS) $(INCS) -D_LIBXG_EXTENSION
-
-LIB=libframe.a
-CC=cc
-
-OBJ=frbox.o frdelete.o frdraw.o frinit.o frinsert.o frptofchar.o\
-	frselect.o frstr.o frutil.o misc.o rune.o
-
-all:	$(LIB)
-
-$(LIB):	$(OBJ)
-	$(AR) rv $(LIB) $(OBJ)
-	$(RANLIB) $(LIB)
-	rm -f $(OBJ)
-
-clean:
-	rm -f *.o core
-
-install:	$(LIB)
-
-$(OBJ):	u.h frame.h
//GO.SYSIN DD ./libframe/Make.mips
echo ./libXg/Make.mips
sed s/.// > ./libXg/Make.mips <<'//GO.SYSIN DD ./libXg/Make.mips'
-#
-#	define operating system.  ONE of: -DIRIX -DSUNOS -DUMIPS -DSYSVR3
-#	
-#	Additionally, -D_POSIX_SOURCE (or its equivalent) may be specified
-#	if your compiler supports posix-compatible compilation
-OS=-DUMIPS -DMips
-
-#	add -Iincludedir for any include directories that need to be searched
-INCS=
-
-#	set this if your X libraries are in different locations
-#	or if you need extra libraries to load with X11 applications
-XLIBS=/usr/local/X11R5/lib/libXt.a /usr/local/X11R5/lib/libX11.a
-
-#	add name of library orderer - use ":" if none
-RANLIB=:
-
-#	add name of librarian
-AR=ar
-
-#	the name of the library
-LIB=libXg.a
-
-CFLAGS=$(OS) -D_LIBXG_EXTENSION $(INCS) $(XCFLAGS)
-CC=cc
-
-OBJS=	arc.o arith.o balloc.o bitblt.o bitbltclip.o border.o bscreenrect.o \
-	circle.o clipline.o clipr.o cursorset.o cursorswitch.o disc.o ellipse.o\
-	gcs.o getrect.o gwin.o latin1.o menuhit.o point.o rdbitmap.o\
-	rdbitmapfile.o rectclip.o segment.o string.o strwidth.o texture.o wrbitmap.o \
-	wrbitmapfile.o xtbinit.o
-
-install:	$(LIB)
-compile:	$(LIB)
-test:	test.o
-	$(CC) -o $@ $? $(LIB) $(XLIBS)
-	echo try running test
-clean:
-	: rm -f *.o test
-
-nuke:	clean
-	rm -f $(LIB)
-
-$(LIB):	$(OBJS)
-	$(AR) rv $(LIB) $(OBJS)
-	$(RANLIB) $(LIB)
-	rm $(OBJS)
-
-$(LIB)(%.o): %.o
//GO.SYSIN DD ./libXg/Make.mips
echo ./sam/address.c
sed s/.// > ./sam/address.c <<'//GO.SYSIN DD ./sam/address.c'
-#include "sam.h"
-#include "parse.h"
-
-Address	addr;
-String	lastpat;
-int	patset;
-File	*menu;
-
-File	*matchfile(String*);
-Address	charaddr(Posn, Address, int);
-
-Address
-address(Addr *ap, Address a, int sign)
-{
-	File *f = a.f;
-	Address a1, a2;
-
-	do{
-		switch(ap->type){
-		case 'l':
-		case '#':
-			a = (*(ap->type=='#'?charaddr:lineaddr))(ap->num, a, sign);
-			break;
-
-		case '.':
-			a = f->dot;
-			break;
-
-		case '$':
-			a.r.p1 = a.r.p2 = f->nrunes;
-			break;
-
-		case '\'':
-			a.r = f->mark;
-			break;
-
-		case '?':
-			sign = -sign;
-			if(sign == 0)
-				sign = -1;
-			/* fall through */
-		case '/':
-			nextmatch(f, ap->are, sign>=0? a.r.p2 : a.r.p1, sign);
-			a.r = sel.p[0];
-			break;
-
-		case '"':
-			a = matchfile(ap->are)->dot;
-			f = a.f;
-			if(f->state == Unread)
-				load(f);
-			break;
-
-		case '*':
-			a.r.p1 = 0, a.r.p2 = f->nrunes;
-			return a;
-
-		case ',':
-		case ';':
-			if(ap->left)
-				a1 = address(ap->left, a, 0);
-			else
-				a1.f = a.f, a1.r.p1 = a1.r.p2 = 0;
-			if(ap->type == ';'){
-				f = a1.f;
-				f->dot = a = a1;
-			}
-			if(ap->next)
-				a2 = address(ap->next, a, 0);
-			else
-				a2.f = a.f, a2.r.p1 = a2.r.p2 = f->nrunes;
-			if(a1.f != a2.f)
-				error(Eorder);
-			a.f = a1.f, a.r.p1 = a1.r.p1, a.r.p2 = a2.r.p2;
-			if(a.r.p2 < a.r.p1)
-				error(Eorder);
-			return a;
-
-		case '+':
-		case '-':
-			sign = 1;
-			if(ap->type == '-')
-				sign = -1;
-			if(ap->next==0 || ap->next->type=='+' || ap->next->type=='-')
-				a = lineaddr(1L, a, sign);
-			break;
-		default:
-			panic("address");
-			return a;
-		}
-	}while(ap = ap->next);	/* assign = */
-	return a;
-}
-
-void
-nextmatch(File *f, String *r, Posn p, int sign)
-{
-	compile(r);
-	if(sign >= 0){
-		if(!execute(f, p, INFINITY))
-			error(Esearch);
-		if(sel.p[0].p1==sel.p[0].p2 && sel.p[0].p1==p){
-			if(++p>f->nrunes)
-				p = 0;
-			if(!execute(f, p, INFINITY))
-				panic("address");
-		}
-	}else{
-		if(!bexecute(f, p))
-			error(Esearch);
-		if(sel.p[0].p1==sel.p[0].p2 && sel.p[0].p2==p){
-			if(--p<0)
-				p = f->nrunes;
-			if(!bexecute(f, p))
-				panic("address");
-		}
-	}
-}
-
-File *
-matchfile(String *r)
-{
-	File *f;
-	File *match = 0;
-	int i;
-
-	for(i = 0; i<file.nused; i++){
-		f = file.filepptr[i];
-		if(f == cmd)
-			continue;
-		if(filematch(f, r)){
-			if(match)
-				error(Emanyfiles);
-			match = f;
-		}
-	}
-	if(!match)
-		error(Efsearch);
-	return match;
-}
-
-int
-filematch(File *f, String *r)
-{
-	char *c, buf[STRSIZE+100];
-	String *t;
-
-	c = Strtoc(&f->name);
-	sprint(buf, "%c%c%c %s\n", " '"[f->state==Dirty],
-		"-+"[f->rasp!=0], " ."[f==curfile], c);
-	free(c);
-	t = tmpcstr(buf);
-	Strduplstr(&genstr, t);
-	freetmpstr(t);
-	/* A little dirty... */
-	if(menu == 0)
-		(menu=Fopen())->state=Clean;
-	Bdelete(menu->buf, 0, menu->buf->nrunes);
-	Binsert(menu->buf, &genstr, 0);
-	menu->nrunes = menu->buf->nrunes;
-	compile(r);
-	return execute(menu, 0, menu->nrunes);
-}
-
-Address
-charaddr(Posn l, Address addr, int sign)
-{
-	if(sign == 0)
-		addr.r.p1 = addr.r.p2 = l;
-	else if(sign < 0)
-		addr.r.p2 = addr.r.p1-=l;
-	else if(sign > 0)
-		addr.r.p1 = addr.r.p2+=l;
-	if(addr.r.p1<0 || addr.r.p2>addr.f->nrunes)
-		error(Erange);
-	return addr;
-}
-
-Address
-lineaddr(Posn l, Address addr, int sign)
-{
-	int n;
-	int c;
-	File *f = addr.f;
-	Address a;
-
-	SET(c);
-	a.f = f;
-	if(sign >= 0){
-		if(l == 0){
-			if(sign==0 || addr.r.p2==0){
-				a.r.p1 = a.r.p2 = 0;
-				return a;
-			}
-			a.r.p1 = addr.r.p2;
-			Fgetcset(f, addr.r.p2-1);
-		}else{
-			if(sign==0 || addr.r.p2==0){
-				Fgetcset(f, (Posn)0);
-				n = 1;
-			}else{
-				Fgetcset(f, addr.r.p2-1);
-				n = Fgetc(f)=='\n';
-			}
-			for(; n<l; ){
-				c = Fgetc(f);
-				if(c == -1)
-					error(Erange);
-				else if(c == '\n')
-					n++;
-			}
-			a.r.p1 = f->getcp;
-		}
-		do; while((c=Fgetc(f))!='\n' && c!=-1);
-		a.r.p2 = f->getcp;
-	}else{
-		Fbgetcset(f, addr.r.p1);
-		if(l == 0)
-			a.r.p2 = addr.r.p1;
-		else{
-			for(n = 0; n<l; ){	/* always runs once */
-				c = Fbgetc(f);
-				if(c == '\n')
-					n++;
-				else if(c == -1){
-					if(++n != l)
-						error(Erange);
-				}
-			}
-			a.r.p2 = f->getcp;
-			if(c == '\n')
-				a.r.p2++;	/* lines start after a newline */
-		}
-		do; while((c=Fbgetc(f))!='\n' && c!=-1);
-		a.r.p1 = f->getcp;
-		if(c == '\n')
-			a.r.p1++;	/* lines start after a newline */
-	}
-	return a;
-}
//GO.SYSIN DD ./sam/address.c
echo ./sam/buffer.c
sed s/.// > ./sam/buffer.c <<'//GO.SYSIN DD ./sam/buffer.c'
-#include "sam.h"
-
-int	incache(Buffer*, Posn, Posn);
-
-Buffer *
-Bopen(Discdesc *dd)
-{
-	Buffer *b;
-
-	b = emalloc(sizeof(Buffer));
-	b->disc = Dopen(dd);
-	Strinit(&b->cache);
-	return b;
-}
-
-void
-Bclose(Buffer *b)
-{
-	Dclose(b->disc);
-	Strclose(&b->cache);
-	free(b);
-}
-
-int
-Bread(Buffer *b, Rune *addr, int n, Posn p0)
-{
-	int m;
-
-	if(b->c2>b->disc->nrunes || b->c1>b->disc->nrunes)
-		panic("bread cache");
-	if(p0 < 0)
-		panic("Bread p0<0");
-	if(p0+n > b->nrunes){
-		n = b->nrunes-p0;
-		if(n < 0)
-			panic("Bread<0");
-	}
-	if(!incache(b, p0, p0+n)){
-		Bflush(b);
-		if(n>=BLOCKSIZE/2)
-			return Dread(b->disc, addr, n, p0);
-		else{
-			Posn minp;
-			if(b->nrunes-p0>BLOCKSIZE/2)
-				m = BLOCKSIZE/2;
-			else
-				m = b->nrunes-p0;
-			if(m<n)
-				m = n;
-			minp = p0-BLOCKSIZE/2;
-			if(minp<0)
-				minp = 0;
-			m += p0-minp;
-			Strinsure(&b->cache, m);
-			if(Dread(b->disc, b->cache.s, m, minp)!=m)
-				panic("Bread");
-			b->cache.n = m;
-			b->c1 = minp;
-			b->c2 = minp+m;
-			b->dirty = FALSE;
-		}
-	}
-	memmove(addr, &b->cache.s[p0-b->c1], n*RUNESIZE);
-	return n;
-}
-
-void
-Binsert(Buffer *b, String *s, Posn p0)
-{
-	if(b->c2>b->disc->nrunes || b->c1>b->disc->nrunes)
-		panic("binsert cache");
-	if(p0<0)
-		panic("Binsert p0<0");
-	if(s->n == 0)
-		return;
-	if(incache(b, p0, p0) && b->cache.n+s->n<=STRSIZE){
-		Strinsert(&b->cache, s, p0-b->c1);
-		b->dirty = TRUE;
-		if(b->cache.n > BLOCKSIZE*2){
-			b->nrunes += s->n;
-			Bflush(b);
-			/* try to leave some cache around p0 */
-			if(p0 >= b->c1+BLOCKSIZE){
-				/* first BLOCKSIZE can go */
-				Strdelete(&b->cache, 0, BLOCKSIZE);
-				b->c1 += BLOCKSIZE;
-			}else if(p0 <= b->c2-BLOCKSIZE){
-				/* last BLOCKSIZE can go */
-				b->cache.n -= BLOCKSIZE;
-				b->c2 -= BLOCKSIZE;
-			}else{
-				/* too hard; negate the cache and pick up next time */
-				Strzero(&b->cache);
-				b->c1 = b->c2 = 0;
-			}
-			return;
-		}
-	}else{
-		Bflush(b);
-		if(s->n >= BLOCKSIZE/2){
-			b->cache.n = 0;
-			b->c1 = b->c2 = 0;
-			Dinsert(b->disc, s->s, s->n, p0);
-		}else{
-			int m;
-			Posn minp;
-			if(b->nrunes-p0 > BLOCKSIZE/2)
-				m = BLOCKSIZE/2;
-			else
-				m = b->nrunes-p0;
-			minp = p0-BLOCKSIZE/2;
-			if(minp < 0)
-				minp = 0;
-			m += p0-minp;
-			Strinsure(&b->cache, m);
-			if(Dread(b->disc, b->cache.s, m, minp)!=m)
-				panic("Bread");
-			b->cache.n = m;
-			b->c1 = minp;
-			b->c2 = minp+m;
-			Strinsert(&b->cache, s, p0-b->c1);
-			b->dirty = TRUE;
-		}
-	}
-	b->nrunes += s->n;
-}
-
-void
-Bdelete(Buffer *b, Posn p1, Posn p2)
-{
-	if(p1<0 || p2<0)
-		panic("Bdelete p<0");
-	if(b->c2>b->disc->nrunes || b->c1>b->disc->nrunes)
-		panic("bdelete cache");
-	if(p1 == p2)
-		return;
-	if(incache(b, p1, p2)){
-		Strdelete(&b->cache, p1-b->c1, p2-b->c1);
-		b->dirty = TRUE;
-	}else{
-		Bflush(b);
-		Ddelete(b->disc, p1, p2);
-		b->cache.n = 0;
-		b->c1 = b->c2 = 0;
-	}
-	b->nrunes -= p2-p1;
-}
-
-void
-Bflush(Buffer *b)
-{
-	if(b->dirty){
-		Dreplace(b->disc, b->c1, b->c2, b->cache.s, b->cache.n);
-		b->c2 = b->c1+b->cache.n;
-		b->dirty = FALSE;
-		if(b->nrunes != b->disc->nrunes)
-			panic("Bflush");
-	}
-}
-
-void
-Bclean(Buffer *b)
-{
-	if(b->dirty){
-		Bflush(b);
-		b->c1 = b->c2 = 0;
-		Strzero(&b->cache);
-	}
-}
-
-/*int hits, misses; /**/
-
-int
-incache(Buffer *b, Posn p1, Posn p2)
-{
-	/*if(b->c1<=p1 && p2<=b->c1+b->cache.n)hits++; else misses++;/**/
-	return b->c1<=p1 && p2<=b->c1+b->cache.n;
-}
//GO.SYSIN DD ./sam/buffer.c
echo ./sam/cmd.c
sed s/.// > ./sam/cmd.c <<'//GO.SYSIN DD ./sam/cmd.c'
-#include "sam.h"
-#include "parse.h"
-
-static char	linex[]="\n";
-static char	wordx[]=" \t\n";
-struct cmdtab cmdtab[]={
-/*	cmdc	text	regexp	addr	defcmd	defaddr	count	token	 fn	*/
-	'\n',	0,	0,	0,	0,	aDot,	0,	0,	nl_cmd,
-	'a',	1,	0,	0,	0,	aDot,	0,	0,	a_cmd,
-	'b',	0,	0,	0,	0,	aNo,	0,	linex,	b_cmd,
-	'B',	0,	0,	0,	0,	aNo,	0,	linex,	b_cmd,
-	'c',	1,	0,	0,	0,	aDot,	0,	0,	c_cmd,
-	'd',	0,	0,	0,	0,	aDot,	0,	0,	d_cmd,
-	'D',	0,	0,	0,	0,	aNo,	0,	linex,	D_cmd,
-	'e',	0,	0,	0,	0,	aNo,	0,	wordx,	e_cmd,
-	'f',	0,	0,	0,	0,	aNo,	0,	wordx,	f_cmd,
-	'g',	0,	1,	0,	'p',	aDot,	0,	0,	g_cmd,
-	'i',	1,	0,	0,	0,	aDot,	0,	0,	i_cmd,
-	'k',	0,	0,	0,	0,	aDot,	0,	0,	k_cmd,
-	'm',	0,	0,	1,	0,	aDot,	0,	0,	m_cmd,
-	'n',	0,	0,	0,	0,	aNo,	0,	0,	n_cmd,
-	'p',	0,	0,	0,	0,	aDot,	0,	0,	p_cmd,
-	'q',	0,	0,	0,	0,	aNo,	0,	0,	q_cmd,
-	'r',	0,	0,	0,	0,	aDot,	0,	wordx,	e_cmd,
-	's',	0,	1,	0,	0,	aDot,	1,	0,	s_cmd,
-	't',	0,	0,	1,	0,	aDot,	0,	0,	m_cmd,
-	'u',	0,	0,	0,	0,	aNo,	1,	0,	u_cmd,
-	'v',	0,	1,	0,	'p',	aDot,	0,	0,	g_cmd,
-	'w',	0,	0,	0,	0,	aAll,	0,	wordx,	w_cmd,
-	'x',	0,	1,	0,	'p',	aDot,	0,	0,	x_cmd,
-	'y',	0,	1,	0,	'p',	aDot,	0,	0,	x_cmd,
-	'X',	0,	1,	0,	'f',	aNo,	0,	0,	X_cmd,
-	'Y',	0,	1,	0,	'f',	aNo,	0,	0,	X_cmd,
-	'!',	0,	0,	0,	0,	aNo,	0,	linex,	plan9_cmd,
-	'>',	0,	0,	0,	0,	aDot,	0,	linex,	plan9_cmd,
-	'<',	0,	0,	0,	0,	aDot,	0,	linex,	plan9_cmd,
-	'|',	0,	0,	0,	0,	aDot,	0,	linex,	plan9_cmd,
-	'=',	0,	0,	0,	0,	aDot,	0,	linex,	eq_cmd,
-	'c'|0x100,0,	0,	0,	0,	aNo,	0,	wordx,	cd_cmd,
-	0,	0,	0,	0,	0,	0,	0,	0,
-};
-Cmd	*parsecmd(int);
-Addr	*compoundaddr(void);
-Addr	*simpleaddr(void);
-void	freecmd(void);
-void	okdelim(int);
-
-Rune	line[BLOCKSIZE];
-Rune	termline[BLOCKSIZE];
-Rune	*linep = line;
-Rune	*terminp = termline;
-Rune	*termoutp = termline;
-List	cmdlist;
-List	addrlist;
-List	relist;
-List	stringlist;
-int	eof;
-
-void
-resetcmd(void)
-{
-	linep = line;
-	*linep = 0;
-	terminp = termoutp = termline;
-	freecmd();
-}
-
-int
-inputc(void)
-{
-	int n, nbuf;
-	char buf[3];
-	Rune r;
-
-    Again:
-	nbuf = 0;
-	if(downloaded){
-		while(termoutp == terminp){
-			cmdupdate();
-			if(patset)
-				tellpat();
-			while(termlocked > 0){
-				outT0(Hunlock);
-				termlocked--;
-			}
-			if(rcv() == 0)
-				return -1;
-		}
-		r = *termoutp++;
-		if(termoutp == terminp)
-			terminp = termoutp = termline;
-	}else{
-   		do{
-			n = read(0, buf+nbuf, 1);
-			if(n <= 0)
-				return -1;
-			nbuf += n;
-		}while(!fullrune(buf, nbuf));
-		chartorune(&r, buf);
-	}
-	if(r == 0){
-		warn(Wnulls);
-		goto Again;
-	}
-	return r;
-}
-
-int
-inputline(void)
-{
-	int i, c;
-
-	linep = line;
-	i = 0;
-	do{
-		if((c = inputc())<=0)
-			return -1;
-		if(i == (sizeof line)/RUNESIZE-1)
-			error(Etoolong);
-	}while((line[i++]=c) != '\n');
-	line[i] = 0;
-	return 1;
-}
-
-int
-getch(void)
-{
-	if(eof)
-		return -1;
-	if(*linep==0 && inputline()<0){
-		eof = TRUE;
-		return -1;
-	}
-	return *linep++;
-}
-
-int
-nextc(void)
-{
-	if(*linep == 0)
-		return -1;
-	return *linep;
-}
-
-void
-ungetch(void)
-{
-	if(--linep < line)
-		panic("ungetch");
-}
-
-Posn
-getnum(void)
-{
-	Posn n=0;
-	int c;
-
-	if((c=nextc())<'0' || '9'<c)	/* no number defaults to 1 */
-		return 1;
-	while('0'<=(c=getch()) && c<='9')
-		n = n*10 + (c-'0');
-	ungetch();
-	return n;
-}
-
-int
-skipbl(void)
-{
-	int c;
-	do
-		c = getch();
-	while(c==' ' || c=='\t');
-	if(c >= 0)
-		ungetch();
-	return c;
-}
-
-void
-termcommand(void)
-{
-	Posn p;
-
-	Fgetcset(cmd, cmdpt);
-	for(p=cmdpt; p<cmd->nrunes; p++){
-		if(terminp >= &termline[BLOCKSIZE]){
-			cmdpt = cmd->nrunes;
-			error(Etoolong);
-		}
-		*terminp++ = Fgetc(cmd);
-	}
-	cmdpt = cmd->nrunes;
-}
-
-void
-cmdloop(void)
-{
-	Cmd *cmdp;
-	File *ocurfile;
-	int loaded;
-
-	for(;;){
-		if(!downloaded && curfile && curfile->state==Unread)
-			load(curfile);
-		if((cmdp = parsecmd(0))==0){
-			if(downloaded){
-				rescue();
-				exits("eof");
-			}
-			break;
-		}
-		ocurfile = curfile;
-		loaded = curfile && curfile->state!=Unread;
-		if(cmdexec(curfile, cmdp)==0)
-			break;
-		freecmd();
-		cmdupdate();
-		update();
-		if(downloaded && curfile &&
-		    (ocurfile!=curfile || (!loaded && curfile->state!=Unread)))
-			outTs(Hcurrent, curfile->tag);
-	}
-}
-
-Cmd *
-newcmd(void){
-	Cmd *p;
-
-	p = emalloc(sizeof(Cmd));
-	inslist(&cmdlist, cmdlist.nused, (long)p);
-	return p;
-}
-
-Addr*
-newaddr(void)
-{
-	Addr *p;
-
-	p = emalloc(sizeof(Addr));
-	inslist(&addrlist, addrlist.nused, (long)p);
-	return p;
-}
-
-String*
-newre(void)
-{
-	String *p;
-
-	p = emalloc(sizeof(String));
-	inslist(&relist, relist.nused, (long)p);
-	Strinit(p);
-	return p;
-}
-
-String*
-newstring(void)
-{
-	String *p;
-
-	p = emalloc(sizeof(String));
-	inslist(&stringlist, stringlist.nused, (long)p);
-	Strinit(p);
-	return p;
-}
-
-void
-freecmd(void)
-{
-	int i;
-
-	while(cmdlist.nused > 0)
-		free(cmdlist.ucharpptr[--cmdlist.nused]);
-	while(addrlist.nused > 0)
-		free(addrlist.ucharpptr[--addrlist.nused]);
-	while(relist.nused > 0){
-		i = --relist.nused;
-		Strclose(relist.stringpptr[i]);
-		free(relist.stringpptr[i]);
-	}
-	while(stringlist.nused>0){
-		i = --stringlist.nused;
-		Strclose(stringlist.stringpptr[i]);
-		free(stringlist.stringpptr[i]);
-	}
-}
-
-int
-lookup(int c)
-{
-	int i;
-
-	for(i=0; cmdtab[i].cmdc; i++)
-		if(cmdtab[i].cmdc == c)
-			return i;
-	return -1;
-}
-
-void
-okdelim(int c)
-{
-	if(c=='\\' || ('a'<=c && c<='z')
-	|| ('A'<=c && c<='Z') || ('0'<=c && c<='9'))
-		error_c(Edelim, c);
-}
-
-void
-atnl(void)
-{
-	skipbl();
-	if(getch() != '\n')
-		error(Enewline);
-}
-
-void
-getrhs(String *s, int delim, int cmd)
-{
-	int c;
-
-	while((c = getch())>0 && c!=delim && c!='\n'){
-		if(c == '\\'){
-			if((c=getch()) <= 0)
-				error(Ebadrhs);
-			if(c == '\n'){
-				ungetch();
-				c='\\';
-			}else if(c == 'n')
-				c='\n';
-			else if(c!=delim && (cmd=='s' || c!='\\'))	/* s does its own */
-				Straddc(s, '\\');
-		}
-		Straddc(s, c);
-	}
-	ungetch();	/* let client read whether delimeter, '\n' or whatever */
-}
-
-String *
-collecttoken(char *end)
-{
-	String *s = newstring();
-	int c;
-
-	while((c=nextc())==' ' || c=='\t')
-		Straddc(s, getch()); /* blanks significant for getname() */
-	while((c=getch())>0 && utfrune(end, c)==0)
-		Straddc(s, c);
-	Straddc(s, 0);
-	if(c != '\n')
-		atnl();
-	return s;
-}
-
-String *
-collecttext(void)
-{
-	String *s = newstring();
-	int begline, i, c, delim;
-
-	if(skipbl()=='\n'){
-		getch();
-		i = 0;
-		do{
-			begline = i;
-			while((c = getch())>0 && c!='\n')
-				i++, Straddc(s, c);
-			i++, Straddc(s, '\n');
-			if(c < 0)
-				goto Return;
-		}while(s->s[begline]!='.' || s->s[begline+1]!='\n');
-		Strdelete(s, s->n-2, s->n);
-	}else{
-		okdelim(delim = getch());
-		getrhs(s, delim, 'a');
-		if(nextc()==delim)
-			getch();
-		atnl();
-	}
-    Return:
-	Straddc(s, 0);		/* JUST FOR CMDPRINT() */
-	return s;
-}
-
-Cmd *
-parsecmd(int nest)
-{
-	int i, c;
-	struct cmdtab *ct;
-	Cmd *cp, *ncp;
-	Cmd cmd;
-
-	cmd.next = cmd.ccmd = 0;
-	cmd.re = 0;
-	cmd.flag = cmd.num = 0;
-	cmd.addr = compoundaddr();
-	if(skipbl() == -1)
-		return 0;
-	if((c=getch())==-1)
-		return 0;
-	cmd.cmdc = c;
-	if(cmd.cmdc=='c' && nextc()=='d'){	/* sleazy two-character case */
-		getch();		/* the 'd' */
-		cmd.cmdc='c'|0x100;
-	}
-	i = lookup(cmd.cmdc);
-	if(i >= 0){
-		if(cmd.cmdc == '\n')
-			goto Return;	/* let nl_cmd work it all out */
-		ct = &cmdtab[i];
-		if(ct->defaddr==aNo && cmd.addr)
-			error(Enoaddr);
-		if(ct->count)
-			cmd.num = getnum();
-		if(ct->regexp){
-			/* x without pattern -> .*\n, indicated by cmd.re==0 */
-			/* X without pattern is all files */
-			if((ct->cmdc!='x' && ct->cmdc!='X') ||
-			   ((c = nextc())!=' ' && c!='\t' && c!='\n')){
-				skipbl();
-				if((c = getch())=='\n' || c<0)
-					error(Enopattern);
-				okdelim(c);
-				cmd.re = getregexp(c);
-				if(ct->cmdc == 's'){
-					cmd.ctext = newstring();
-					getrhs(cmd.ctext, c, 's');
-					if(nextc() == c){
-						getch();
-						if(nextc() == 'g')
-							cmd.flag = getch();
-					}
-			
-				}
-			}
-		}
-		if(ct->addr && (cmd.caddr=simpleaddr())==0)
-			error(Eaddress);
-		if(ct->defcmd){
-			if(skipbl() == '\n'){
-				getch();
-				cmd.ccmd = newcmd();
-				cmd.ccmd->cmdc = ct->defcmd;
-			}else if((cmd.ccmd = parsecmd(nest))==0)
-				panic("defcmd");
-		}else if(ct->text)
-			cmd.ctext = collecttext();
-		else if(ct->token)
-			cmd.ctext = collecttoken(ct->token);
-		else
-			atnl();
-	}else
-		switch(cmd.cmdc){
-		case '{':
-			cp = 0;
-			do{
-				if(skipbl()=='\n')
-					getch();
-				ncp = parsecmd(nest+1);
-				if(cp)
-					cp->next = ncp;
-				else
-					cmd.ccmd = ncp;
-			}while(cp = ncp);
-			break;
-		case '}':
-			atnl();
-			if(nest==0)
-				error(Enolbrace);
-			return 0;
-		default:
-			error_c(Eunk, cmd.cmdc);
-		}
-    Return:
-	cp = newcmd();
-	*cp = cmd;
-	return cp;
-}
-
-String*				/* BUGGERED */
-getregexp(int delim)
-{
-	String *r = newre();
-	int c;
-
-	for(Strzero(&genstr); ; Straddc(&genstr, c))
-		if((c = getch())=='\\'){
-			if(nextc()==delim)
-				c = getch();
-			else if(nextc()=='\\'){
-				Straddc(&genstr, c);
-				c = getch();
-			}
-		}else if(c==delim || c=='\n')
-			break;
-	if(c!=delim && c)
-		ungetch();
-	if(genstr.n > 0){
-		patset = TRUE;
-		Strduplstr(&lastpat, &genstr);
-		Straddc(&lastpat, '\0');
-	}
-	if(lastpat.n <= 1)
-		error(Epattern);
-	Strduplstr(r, &lastpat);
-	return r;
-}
-
-Addr *
-simpleaddr(void)
-{
-	Addr addr;
-	Addr *ap, *nap;
-
-	addr.next = 0;
-	addr.left = 0;
-	switch(skipbl()){
-	case '#':
-		addr.type = getch();
-		addr.num = getnum();
-		break;
-	case '0': case '1': case '2': case '3': case '4':
-	case '5': case '6': case '7': case '8': case '9': 
-		addr.num = getnum();
-		addr.type='l';
-		break;
-	case '/': case '?': case '"':
-		addr.are = getregexp(addr.type = getch());
-		break;
-	case '.':
-	case '$':
-	case '+':
-	case '-':
-	case '\'':
-		addr.type = getch();
-		break;
-	default:
-		return 0;
-	}
-	if(addr.next = simpleaddr())
-		switch(addr.next->type){
-		case '.':
-		case '$':
-		case '\'':
-			if(addr.type!='"')
-		case '"':
-				error(Eaddress);
-			break;
-		case 'l':
-		case '#':
-			if(addr.type=='"')
-				break;
-			/* fall through */
-		case '/':
-		case '?':
-			if(addr.type!='+' && addr.type!='-'){
-				/* insert the missing '+' */
-				nap = newaddr();
-				nap->type='+';
-				nap->next = addr.next;
-				addr.next = nap;
-			}
-			break;
-		case '+':
-		case '-':
-			break;
-		default:
-			panic("simpleaddr");
-		}
-	ap = newaddr();
-	*ap = addr;
-	return ap;
-}
-
-Addr *
-compoundaddr(void)
-{
-	Addr addr;
-	Addr *ap, *next;
-
-	addr.left = simpleaddr();
-	if((addr.type = skipbl())!=',' && addr.type!=';')
-		return addr.left;
-	getch();
-	next = addr.next = compoundaddr();
-	if(next && (next->type==',' || next->type==';') && next->left==0)
-		error(Eaddress);
-	ap = newaddr();
-	*ap = addr;
-	return ap;
-}
//GO.SYSIN DD ./sam/cmd.c
echo ./sam/disc.c
sed s/.// > ./sam/disc.c <<'//GO.SYSIN DD ./sam/disc.c'
-#include "sam.h"
-
-#define	BLOCKFILL	(BLOCKSIZE/2)
-
-static Discdesc	desc[NBUFFILES];
-
-void		bkalloc(Disc*, int);
-void		bkfree(Disc*, int);
-void		bkwrite(Disc*, Rune*, int, int, int);
-void		bkread(Disc*, Rune*, int, int, int);
-
-
-Discdesc *
-Dstart(void)
-{
-	int i, fd;
-	Discdesc *dd;
-
-	for(i=0, dd=desc; dd->fd; i++, dd++)
-		if(i == NBUFFILES-1)
-			panic("too many buffer files");
-	fd = newtmp(i);
-	if(fd < 0)
-		panic("can't create buffer file");
-	dd->fd = fd;
-	return dd;
-}
-
-Disc *
-Dopen(Discdesc *dd)
-{
-	Disc *d;
-
-	d = emalloc(sizeof(Disc));
-	d->desc = dd;
-	return d;
-}
-
-void
-Dclose(Disc *d)
-{
-	int i;
-
-	for(i=d->block.nused; --i>=0; )	/* backwards because bkfree() stacks */
-		bkfree(d, i);
-	free(d->block.listptr);
-	free(d);
-}
-
-int
-Dread(Disc *d, Rune *addr, int n, Posn p1)
-{
-	int i, nb, nr;
-	Posn p = 0, p2 = p1+n;
-
-	for(i=0; i<d->block.nused; i++){
-		if((p+=d->block.blkptr[i].nrunes) > p1){
-			p -= d->block.blkptr[i].nrunes;
-			goto out;
-		}
-	}
-	if(p == p1)
-		return 0;	/* eof */
-	return -1;		/* past eof */
-
-    out:
-	n = 0;
-	if(p != p1){	/* trailing partial block */
-		nb = d->block.blkptr[i].nrunes;
-		if(p2 > p+nb)
-			nr = nb-(p1-p);
-		else
-			nr = p2-p1;
-		bkread(d, addr, nr, i, p1-p);
-		/* advance to next block */
-		p += nb;
-		addr += nr;
-		n += nr;
-		i++;
-	}
-	/* whole blocks */
-	while(p<p2 && (nb = d->block.blkptr[i].nrunes)<=p2-p){
-		if(i >= d->block.nused)
-			return n;	/* eof */
-		bkread(d, addr, nb, i, 0);
-		p += nb;
-		addr += nb;
-		n += nb;
-		i++;
-	}
-	if(p < p2){	/* any initial partial block left? */
-		nr = p2-p;
-		nb = d->block.blkptr[i].nrunes;
-		if(nr>nb)
-			nr = nb;		/* eof */
-		/* just read in the part that survives */
-		bkread(d, addr, nr, i, 0);
-		n += nr;
-	}
-	return n;
-}
-
-void
-Dinsert(Disc *d, Rune *addr, int n, Posn p0) /* if addr null, just make space */
-{
-	int i, nb, ni;
-	Posn p = 0;
-	Rune hold[BLOCKSIZE];
-	int nhold;
-
-	for(i=0; i<d->block.nused; i++){
-		if((p+=d->block.blkptr[i].nrunes) >= p0){
-			p -= d->block.blkptr[i].nrunes;
-			goto out;
-		}
-	}
-	if(p != p0)
-		panic("Dinsert");	/* beyond eof */
-
-    out:
-	d->nrunes += n;
-	nhold = 0;
-	if(i<d->block.nused && (nb=d->block.blkptr[i].nrunes)>p0-p){
-		nhold = nb-(p0-p);
-		bkread(d, hold, nhold, i, p0-p);
-		d->block.blkptr[i].nrunes -= nhold;	/* no write necessary */
-	}
-	/* insertion point is now at end of block i (which may not exist) */
-	while(n > 0){
-		if(i < d->block.nused
-		&& (nb=d->block.blkptr[i].nrunes) < BLOCKFILL){
-			/* fill this block */
-			if(nb+n > BLOCKSIZE)
-				ni = BLOCKFILL-nb;
-			else
-				ni = n;
-			if(addr)
-				bkwrite(d, addr, ni, i, nb);
-			nb += ni;
-		}else{	/* make new block */
-			if(i < d->block.nused)
-				i++;	/* put after this block, if it exists */
-			bkalloc(d, i);
-			if(n > BLOCKSIZE)
-				ni = BLOCKFILL;
-			else
-				ni = n;
-			if(addr)
-				bkwrite(d, addr, ni, i, 0);
-			nb = ni;
-		}
-		d->block.blkptr[i].nrunes = nb;
-		if(addr)
-			addr += ni;
-		n -= ni;
-	}
-	if(nhold){
-		if(i < d->block.nused
-		&& (nb=d->block.blkptr[i].nrunes)+nhold < BLOCKSIZE){
-			/* fill this block */
-			bkwrite(d, hold, nhold, i, nb);
-			nb += nhold;
-		}else{	/* make new block */
-			if(i < d->block.nused)
-				i++;	/* put after this block, if it exists */
-			bkalloc(d, i);
-			bkwrite(d, hold, nhold, i, 0);
-			nb = nhold;
-		}
-		d->block.blkptr[i].nrunes = nb;
-	}
-}
-
-void
-Ddelete(Disc *d, Posn p1, Posn p2)
-{
-	int i, nb, nd;
-	Posn p = 0;
-	Rune buf[BLOCKSIZE];
-
-	for(i = 0; i<d->block.nused; i++){
-		if((p+=d->block.blkptr[i].nrunes) > p1){
-			p -= d->block.blkptr[i].nrunes;
-			goto out;
-		}
-	}
-	if(p1!=d->nrunes || p2!=p1)
-		panic("Ddelete");
-	return;	/* beyond eof */
-
-    out:
-	d->nrunes -= p2-p1;
-	if(p != p1){	/* throw away partial block */
-		nb = d->block.blkptr[i].nrunes;
-		bkread(d, buf, nb, i, 0);
-		if(p2 >= p+nb)
-			nd = nb-(p1-p);
-		else{
-			nd = p2-p1;
-			memmove(buf+(p1-p), buf+(p1-p)+nd, RUNESIZE*(nb-((p1-p)+nd)));
-		}
-		nb -= nd;
-		bkwrite(d, buf, nb, i, 0);
-		d->block.blkptr[i].nrunes = nb;
-		p2 -= nd;
-		/* advance to next block */
-		p += nb;
-		i++;
-	}
-	/* throw away whole blocks */
-	while(p<p2 && (nb = d->block.blkptr[i].nrunes)<=p2-p){
-		if(i >= d->block.nused)
-			panic("Ddelete 2");
-		bkfree(d, i);
-		p2 -= nb;
-	}
-	if(p >= p2)	/* any initial partial block left to delete? */
-		return;	/* no */
-	nd = p2-p;
-	nb = d->block.blkptr[i].nrunes;
-	/* just read in the part that survives */
-	bkread(d, buf, nb-=nd, i, nd);
-	/* a little block merging */
-	if(nb<BLOCKSIZE/2 && i>0 && (nd = d->block.blkptr[i-1].nrunes)<BLOCKSIZE/2){
-		memmove(buf+nd, buf, RUNESIZE*nb);
-		bkread(d, buf, nd, --i, 0);
-		bkfree(d, i);
-		nb += nd;
-	}
-	bkwrite(d, buf, nb, i, 0);
-	d->block.blkptr[i].nrunes = nb;
-}
-
-void
-Dreplace(Disc *d, Posn p1, Posn p2, Rune *addr, int n)
-{
-	int i, nb, nr;
-	Posn p = 0;
-	Rune buf[BLOCKSIZE];
-
-	if(p2-p1 > n)
-		Ddelete(d, p1+n, p2);
-	else if(p2-p1 < n)
-		Dinsert(d, 0, n-(p2-p1), p2);
-	if(n == 0)
-		return;
-	p2 = p1+n;
-	/* they're now conformal; replace in place */
-	for(i=0; i<d->block.nused; i++){
-		if((p+=d->block.blkptr[i].nrunes) > p1){
-			p -= d->block.blkptr[i].nrunes;
-			goto out;
-		}
-	}
-	panic("Dreplace");
-
-    out:
-	if(p != p1){	/* trailing partial block */
-		nb = d->block.blkptr[i].nrunes;
-		bkread(d, buf, nb, i, 0);
-		if(p2 > p+nb)
-			nr = nb-(p1-p);
-		else
-			nr = p2-p1;
-		memmove(buf+p1-p, addr, RUNESIZE*nr);
-		bkwrite(d, buf, nb, i, 0);
-		/* advance to next block */
-		p += nb;
-		addr += nr;
-		i++;
-	}
-	/* whole blocks */
-	while(p<p2 && (nb = d->block.blkptr[i].nrunes)<=p2-p){
-		if(i >= d->block.nused)
-			panic("Dreplace 2");
-		bkwrite(d, addr, nb, i, 0);
-		p += nb;
-		addr += nb;
-		i++;
-	}
-	if(p < p2){	/* any initial partial block left? */
-		nr = p2-p;
-		nb = d->block.blkptr[i].nrunes;
-		/* just read in the part that survives */
-		bkread(d, buf+nr, nb-nr, i, nr);
-		memmove(buf, addr, RUNESIZE*nr);
-		bkwrite(d, buf, nb, i, 0);
-	}
-}
-
-void
-bkread(Disc *d, Rune *loc, int n, int bk, int off)
-{
-	Seek(d->desc->fd, RUNESIZE*(BLOCKSIZE*d->block.blkptr[bk].bnum+off), 0);
-	Read(d->desc->fd, loc, n*RUNESIZE);
-}
-
-void
-bkwrite(Disc *d, Rune *loc, int n, int bk, int off)
-{
-	Seek(d->desc->fd, RUNESIZE*(BLOCKSIZE*d->block.blkptr[bk].bnum+off), 0);
-	Write(d->desc->fd, loc, n*RUNESIZE);
-}
-
-void
-bkalloc(Disc *d, int n)
-{
-	Discdesc *dd = d->desc;
-	ulong bnum;
-
-	if(dd->free.nused)
-		bnum = dd->free.longptr[--dd->free.nused];
-	else
-		bnum = dd->nbk++;
-	if(bnum >= 1<<(8*(sizeof(((Block*)0)->bnum))))
-		error(Etmpovfl);
-	inslist(&d->block, n, 0L);
-	d->block.blkptr[n].bnum = bnum;
-}
-
-void
-bkfree(Disc *d, int n)
-{
-	Discdesc *dd = d->desc;
-
-	inslist(&dd->free, dd->free.nused, d->block.blkptr[n].bnum);
-	dellist(&d->block, n);
-}
//GO.SYSIN DD ./sam/disc.c
echo ./sam/error.c
sed s/.// > ./sam/error.c <<'//GO.SYSIN DD ./sam/error.c'
-#include "sam.h"
-
-static char *emsg[]={
-	/* error_s */
-	"can't open",
-	"can't create",
-	"not in menu:",
-	"changes to",
-	"I/O error:",
-	/* error_c */
-	"unknown command",
-	"no operand for",
-	"bad delimiter",
-	/* error */
-	"can't fork",
-	"interrupt",
-	"address",
-	"search",
-	"pattern",
-	"newline expected",
-	"blank expected",
-	"pattern expected",
-	"can't nest X or Y",
-	"unmatched `}'",
-	"command takes no address",
-	"addresses overlap",
-	"substitution",
-	"& match too long",
-	"bad \\ in rhs",
-	"address range",
-	"changes not in sequence",
-	"addresses out of order",
-	"no file name",
-	"unmatched `('",
-	"unmatched `)'",
-	"malformed `[]'",
-	"malformed regexp",
-	"reg. exp. list overflow",
-	"plan 9 command",
-	"can't pipe",
-	"no current file",
-	"string too long",
-	"changed files",
-	"empty string",
-	"file search",
-	"non-unique match for \"\"",
-	"tag match too long",
-	"too many subexpressions",
-	"temporary file too large",
-};
-static char *wmsg[]={
-	/* warn_s */
-	"duplicate file name",
-	"no such file",
-	"write might change good version of",
-	/* warn */
-	"null characters elided",
-	"can't run pwd",
-	"last char not newline",
-	"exit status not 0",
-};
-
-void
-error(Err s)
-{
-	char buf[512];
-
-	sprint(buf, "?%s", emsg[s]);
-	hiccough(buf);
-}
-
-void
-error_s(Err s, char *a)
-{
-	char buf[512];
-
-	sprint(buf, "?%s \"%s\"", emsg[s], a);
-	hiccough(buf);
-}
-
-void
-error_c(Err s, int c)
-{
-	char buf[512];
-
-	sprint(buf, "?%s `%C'", emsg[s], c);
-	hiccough(buf);
-}
-
-void
-warn(Warn s)
-{
-	dprint("?warning: %s\n", wmsg[s]);
-}
-
-void
-warn_S(Warn s, String *a)
-{
-	char *c;
-
-	c = Strtoc(a);
-	dprint("?warning: %s `%s'\n", wmsg[s], c);
-	free(c);
-}
-
-void
-warn_s(Warn s, char *a)
-{
-	dprint("?warning: %s `%s'\n", wmsg[s], a);
-}
-
-void
-termwrite(char *s)
-{
-	String *p;
-
-	if(downloaded){
-		p = tmpcstr(s);
-		if(cmd)
-			Finsert(cmd, p, cmdpt);
-		else
-			Strinsert(&cmdstr, p, cmdstr.n);
-		cmdptadv += p->n;
-	}else
-		Write(2, s, strlen(s));
-}
//GO.SYSIN DD ./sam/error.c
echo ./sam/errors.h
sed s/.// > ./sam/errors.h <<'//GO.SYSIN DD ./sam/errors.h'
-typedef enum Err{
-	/* error_s */
-	Eopen,
-	Ecreate,
-	Emenu,
-	Emodified,
-	Eio,
-	/* error_c */
-	Eunk,
-	Emissop,
-	Edelim,
-	/* error */
-	Efork,
-	Eintr,
-	Eaddress,
-	Esearch,
-	Epattern,
-	Enewline,
-	Eblank,
-	Enopattern,
-	EnestXY,
-	Enolbrace,
-	Enoaddr,
-	Eoverlap,
-	Enosub,
-	Elongrhs,
-	Ebadrhs,
-	Erange,
-	Esequence,
-	Eorder,
-	Enoname,
-	Eleftpar,
-	Erightpar,
-	Ebadclass,
-	Ebadregexp,
-	Eoverflow,
-	Enocmd,
-	Epipe,
-	Enofile,
-	Etoolong,
-	Echanges,
-	Eempty,
-	Efsearch,
-	Emanyfiles,
-	Elongtag,
-	Esubexp,
-	Etmpovfl
-}Err;
-typedef enum Warn{
-	/* warn_s */
-	Wdupname,
-	Wfile,
-	Wdate,
-	/* warn */
-	Wnulls,
-	Wpwd,
-	Wnotnewline,
-	Wbadstatus
-}Warn;
//GO.SYSIN DD ./sam/errors.h
echo ./sam/file.c
sed s/.// > ./sam/file.c <<'//GO.SYSIN DD ./sam/file.c'
-#include "sam.h"
-
-/*
- * Files are splayed out a factor of NDISC to reduce indirect block access
- */
-Discdesc	*files[NDISC];
-Discdesc	*transcripts[NDISC];
-Buffer		*undobuf;
-static String	*ftempstr(Rune*, int);
-int		fcount;
-static File	*lastfile;
-
-void	puthdr_csl(Buffer*, char, short, Posn);
-void	puthdr_cs(Buffer*, char, short);
-void	puthdr_M(Buffer*, Posn, Range, Range, Mod, short);
-void	puthdr_cll(Buffer*, char, Posn, Posn);
-void	Fflush(File*);
-
-enum{
-	SKIP=50,		/* max dist between file changes folded together */
-	MAXCACHE=STRSIZE	/* max length of cache. must be < 32K-BLOCKSIZE */
-};
-
-void
-Fstart(void)
-{
-	undobuf = Bopen(Dstart());
-	snarfbuf = Bopen(Dstart());
-	plan9buf = Bopen(Dstart());
-}
-
-void
-Fmark(File *f, Mod m)
-{
-	Buffer *t = f->transcript;
-	Posn p;
-
-	if(f->state == Unread)	/* this is implicit 'e' of a file */
-		return;
-	p = m==0? -1 : f->markp;
-	f->markp = t->nrunes;
-	puthdr_M(t, p, f->dot.r, f->mark, f->mod, f->state);
-	f->ndot = f->dot;
-	f->marked = TRUE;
-	f->mod = m;
-	f->hiposn = -1;
-	/* Safety first */
-	f->cp1 = f->cp2 = 0;
-}
-
-File *
-Fopen(void)
-{
-	File *f;
-
-	f = emalloc(sizeof(File));
-	if(files[fcount] == 0){
-		files[fcount] = Dstart();
-		transcripts[fcount] = Dstart();
-	}
-	f->buf = Bopen(files[fcount]);
-	f->transcript = Bopen(transcripts[fcount]);
-	if(++fcount == NDISC)
-		fcount = 0;
-	f->nrunes = 0;
-	f->markp = 0;
-	f->mod = 0;
-	f->dot.f = f;
-	f->ndot.f = f;
-	Strinit0(&f->name);
-	Strinit(&f->cache);
-	f->state = Unread;
-	Fmark(f, (Mod)0);
-	return f;
-}
-
-void
-Fclose(File *f)
-{
-	if(f == lastfile)
-		lastfile = 0;
-	Bclose(f->buf);
-	Bclose(f->transcript);
-	Strclose(&f->name);
-	Strclose(&f->cache);
-	if(f->rasp)
-		listfree(f->rasp);
-	free(f);
-}
-
-void
-Finsert(File *f, String *str, Posn p1)
-{
-	Buffer *t = f->transcript;
-
-	if(str->n == 0)
-		return;
-	if(str->n<0 || str->n>STRSIZE)
-		panic("Finsert");
-	if(f->mod < modnum)
-		Fmark(f, modnum);
-	if(p1 < f->hiposn)
-		error(Esequence);
-	if(str->n >= BLOCKSIZE){	/* don't bother with the cache */
-		Fflush(f);
-		puthdr_csl(t, 'i', str->n, p1);
-		Binsert(t, str, t->nrunes);
-	}else{	/* insert into the cache instead of the transcript */
-		if(f->cp2==0 && f->cp1==0 && f->cache.n==0)	/* empty cache */
-			f->cp1 = f->cp2 = p1;
-		if(p1-f->cp2>SKIP || f->cache.n+str->n>MAXCACHE-SKIP){
-			Fflush(f);
-			f->cp1 = f->cp2 = p1;
-		}
-		if(f->cp2 != p1){	/* grab the piece in between */
-			Rune buf[SKIP];
-			String s;
-			Fchars(f, buf, f->cp2, p1);
-			s.s = buf;
-			s.n = p1-f->cp2;
-			Strinsert(&f->cache, &s, f->cache.n);
-			f->cp2 = p1;
-		}
-		Strinsert(&f->cache, str, f->cache.n);
-	}
-	if(f != cmd)
-		quitok = FALSE;
-	f->closeok = FALSE;
-	if(f->state == Clean)
-		state(f, Dirty);
-	f->hiposn = p1;
-}
-
-void
-Fdelete(File *f, Posn p1, Posn p2)
-{
-	if(p1==p2)
-		return;
-	if(f->mod<modnum)
-		Fmark(f, modnum);
-	if(p1<f->hiposn)
-		error(Esequence);
-	if(p1-f->cp2>SKIP)
-		Fflush(f);
-	if(f->cp2==0 && f->cp1==0 && f->cache.n==0)	/* empty cache */
-		f->cp1 = f->cp2 = p1;
-	if(f->cp2 != p1){	/* grab the piece in between */
-		if(f->cache.n+(p1-f->cp2)>MAXCACHE){
-			Fflush(f);
-			f->cp1 = f->cp2 = p1;
-		}else{
-			Rune buf[SKIP];
-			String s;
-			Fchars(f, buf, f->cp2, p1);
-			s.s = buf;
-			s.n = p1-f->cp2;
-			Strinsert(&f->cache, &s, f->cache.n);
-		}
-	}
-	f->cp2 = p2;
-	if(f!=cmd)
-		quitok = FALSE;
-	f->closeok = FALSE;
-	if(f->state==Clean)
-		state(f, Dirty);
-	f->hiposn = p2;
-}
-
-void
-Fflush(File *f)
-{
-	Buffer *t = f->transcript;
-	Posn p1 = f->cp1, p2 = f->cp2;
-
-	if(p1 != p2)
-		puthdr_cll(t, 'd', p1, p2);
-	if(f->cache.n){
-		puthdr_csl(t, 'i', f->cache.n, p2);
-		Binsert(t, &f->cache, t->nrunes);
-		Strzero(&f->cache);
-	}
-	f->cp1 = f->cp2 = 0;
-}
-
-void
-Fsetname(File *f, String *s)
-{
-	Buffer *t = f->transcript;
-
-	if(f->state == Unread){	/* This is setting initial file name */
-		Strduplstr(&f->name, s);
-		sortname(f);
-	}else{
-		if(f->mod < modnum)
-			Fmark(f, modnum);
-		puthdr_cs(t, 'f', s->n);
-		Binsert(t, s, t->nrunes);
-	}
-}
-
-/*
- * The heart of it all. Fupdate will run along the transcript list, executing
- * the commands and converting them into their inverses for a later undo pass.
- * The pass runs top to bottom, so addresses in the transcript are tracked
- * (by the var. delta) so they stay valid during the operation.  This causes
- * all operations to appear to happen simultaneously, which is why the addresses
- * passed to Fdelete and Finsert never take into account other changes occurring
- * in this command (and is why things are done this way).
- */
-int
-Fupdate(File *f, int mktrans, int toterm)
-{
-	Buffer *t = f->transcript;
-	Buffer *u = undobuf;
-	int n, ni;
-	Posn p0, p1, p2, p, deltadot = 0, deltamark = 0, delta = 0;
-	int changes = FALSE;
-	union Hdr buf;
-	Rune tmp[BLOCKSIZE+1];	/* +1 for NUL in 'f' case */
-
-	if(lastfile && f!=lastfile)
-		Bclean(lastfile->transcript);	/* save memory when multifile */
-	lastfile = f;
-	Fflush(f);
-	if(f->marked)
-		p0 = f->markp+sizeof(Mark)/RUNESIZE;
-	else
-		p0 = 0;
-	f->dot = f->ndot;
-	while((n=Bread(t, (Rune*)&buf, sizeof buf/RUNESIZE, p0)) > 0){
-		switch(buf.cs.c){
-		default:
-			panic("unknown in Fupdate");
-		case 'd':
-			p1 = buf.cll.l;
-			p2 = buf.cll.l1;
-			p0 += sizeof(struct _cll)/RUNESIZE;
-			if(p2 <= f->dot.r.p1)
-				deltadot -= p2-p1;
-			if(p2 <= f->mark.p1)
-				deltamark -= p2-p1;
-			p1 += delta, p2+=delta;
-			delta -= p2-p1;
-			if(!mktrans)
-				for(p = p1; p<p2; p+=ni){
-					if(p2-p>BLOCKSIZE)
-						ni = BLOCKSIZE;
-					else
-						ni = p2-p;
-					puthdr_csl(u, 'i', ni, p1);
-					Bread(f->buf, tmp, ni, p);
-					Binsert(u, ftempstr(tmp, ni), u->nrunes);
-				}
-			f->nrunes -= p2-p1;
-			Bdelete(f->buf, p1, p2);
-			changes = TRUE;
-			break;
-
-		case 'f':
-			n = buf.cs.s;
-			p0 += sizeof(struct _cs)/RUNESIZE;
-			Strinsure(&genstr, n+1);
-			Bread(t, tmp, n, p0);
-			tmp[n] = 0;
-			p0 += n;
-			Strdupl(&genstr, tmp);
-			if(!mktrans){
-				puthdr_cs(u, 'f', f->name.n);
-				Binsert(u, &f->name, u->nrunes);
-			}
-			Strduplstr(&f->name, &genstr);
-			sortname(f);
-			changes = TRUE;
-			break;
-
-		case 'i':
-			n = buf.csl.s;
-			p1 = buf.csl.l;
-			p0 += sizeof(struct _csl)/RUNESIZE;
-			if(p1 < f->dot.r.p1)
-				deltadot += n;
-			if(p1 < f->mark.p1)
-				deltamark += n;
-			p1 += delta;
-			delta += n;
-			if(!mktrans)
-				puthdr_cll(u, 'd', p1, p1+n);
-			changes = TRUE;
-			f->nrunes += n;
-			while(n > 0){
-				if(n > BLOCKSIZE)
-					ni = BLOCKSIZE;
-				else
-					ni = n;
-				Bread(t, tmp, ni, p0);
-				Binsert(f->buf, ftempstr(tmp, ni), p1);
-				n -= ni;
-				p1 += ni;
-				p0 += ni;
-			}
-			break;
-		}
-	}
-	toterminal(f, toterm);
-	f->dot.r.p1 += deltadot;
-	f->dot.r.p2 += deltadot;
-	if(f->dot.r.p1 > f->nrunes)
-		f->dot.r.p1 = f->nrunes;
-	if(f->dot.r.p2 > f->nrunes)
-		f->dot.r.p2 = f->nrunes;
-	f->mark.p1 += deltamark;
-	f->mark.p2 += deltamark;
-	if(f->mark.p1 > f->nrunes)
-		f->mark.p1 = f->nrunes;
-	if(f->mark.p2 > f->nrunes)
-		f->mark.p2 = f->nrunes;
-	if(n < 0)
-		panic("Fupdate read");
-	if(f == cmd)
-		f->mod = 0;	/* can't undo command file */
-	if(p0 > f->markp+sizeof(Posn)/RUNESIZE){	/* for undo, this throws away the undo transcript */
-		if(f->mod > 0){	/* can't undo the dawn of time */
-			Bdelete(t, f->markp+sizeof(Mark)/RUNESIZE, t->nrunes);
-			/* copy the undo list back into the transcript */
-			for(p = 0; p<u->nrunes; p+=ni){
-				if(u->nrunes-p>BLOCKSIZE)
-					ni = BLOCKSIZE;
-				else
-					ni = u->nrunes-p;
-				Bread(u, tmp, ni, p);
-				Binsert(t, ftempstr(tmp, ni), t->nrunes);
-			}
-		}
-		Bdelete(u, (Posn)0, u->nrunes);
-	}
-	return f==cmd? FALSE : changes;
-}
-
-void
-puthdr_csl(Buffer *b, char c, short s, Posn p)
-{
-	struct _csl buf;
-
-	if(p < 0)
-		panic("puthdr_csP");
-	buf.c = c;
-	buf.s = s;
-	buf.l = p;
-	Binsert(b, ftempstr((Rune*)&buf, sizeof buf/RUNESIZE), b->nrunes);
-}
-
-void
-puthdr_cs(Buffer *b, char c, short s)
-{
-	struct _cs buf;
-
-	buf.c = c;
-	buf.s = s;
-	Binsert(b, ftempstr((Rune*)&buf, sizeof buf/RUNESIZE), b->nrunes);
-}
-
-void
-puthdr_M(Buffer *b, Posn p, Range dot, Range mk, Mod m, short s1)
-{
-	Mark mark;
-	static first = 1;
-
-	if(!first && p<0)
-		panic("puthdr_M");
-	mark.p = p;
-	mark.dot = dot;
-	mark.mark = mk;
-	mark.m = m;
-	mark.s1 = s1;
-	Binsert(b, ftempstr((Rune *)&mark, sizeof mark/RUNESIZE), b->nrunes);
-}
-
-void
-puthdr_cll(Buffer *b, char c, Posn p1, Posn p2)
-{
-	struct _cll buf;
-
-	if(p1<0 || p2<0)
-		panic("puthdr_cll");
-	buf.c = c;
-	buf.l = p1;
-	buf.l1 = p2;
-	Binsert(b, ftempstr((Rune*)&buf, sizeof buf/RUNESIZE), b->nrunes);
-}
-
-long
-Fchars(File *f, Rune *addr, Posn p1, Posn p2)
-{
-	return Bread(f->buf, addr, p2-p1, p1);
-}
-
-int
-Fgetcset(File *f, Posn p)
-{
-	if(p<0 || p>f->nrunes)
-		panic("Fgetcset out of range");
-	if((f->ngetc = Fchars(f, f->getcbuf, p, p+NGETC))<0)
-		panic("Fgetcset Bread fail");
-	f->getcp = p;
-	f->getci = 0;
-	return f->ngetc;
-}
-
-int
-Fbgetcset(File *f, Posn p)
-{
-	if(p<0 || p>f->nrunes)
-		panic("Fbgetcset out of range");
-	if((f->ngetc = Fchars(f, f->getcbuf, p<NGETC? (Posn)0 : p-NGETC, p))<0)
-		panic("Fbgetcset Bread fail");
-	f->getcp = p;
-	f->getci = f->ngetc;
-	return f->ngetc;
-}
-
-int
-Fgetcload(File *f, Posn p)
-{
-	if(Fgetcset(f, p)){
-		--f->ngetc;
-		f->getcp++;
-		return f->getcbuf[f->getci++];
-	}
-	return -1;
-}
-
-int
-Fbgetcload(File *f, Posn p)
-{
-	if(Fbgetcset(f, p)){
-		--f->getcp;
-		return f->getcbuf[--f->getci];
-	}
-	return -1;
-}
-
-static String*
-ftempstr(Rune *s, int n)
-{
-	static String p;
-
-	p.s = s;
-	p.n = n;
-	p.size = n;
-	return &p;
-}
//GO.SYSIN DD ./sam/file.c
echo ./sam/io.c
sed s/.// > ./sam/io.c <<'//GO.SYSIN DD ./sam/io.c'
-#include "sam.h"
-
-#define	NSYSFILE	3
-#define	NOFILE		128
-
-void
-writef(File *f)
-{
-	Rune c;
-	Posn n;
-	char *name;
-	int i, samename, newfile;
-	ulong qid;
-	long mtime;
-
-	newfile = 0;
-	samename = Strcmp(&genstr, &f->name) == 0;
-	name = Strtoc(&f->name);
-	i = statfile(name, &qid, &mtime, 0);
-	free(name);
-	if(i == -1)
-		newfile++;
-	else if(samename &&
-	        (f->inumber!=qid || f->date<mtime)){
-		f->inumber = qid;
-		f->date = mtime;
-		warn_S(Wdate, &genstr);
-		return;
-	}
-	if(genc)
-		free(genc);
-	genc = Strtoc(&genstr);
-	if((io=create(genc, 1, 0666L)) < 0)
-		error_s(Ecreate, genc);
-	dprint("%s: ", genc);
-	n = writeio(f);
-	if(f->name.s[0]==0 || samename)
-		state(f, addr.r.p1==0 && addr.r.p2==f->nrunes? Clean : Dirty);
-	if(newfile)
-		dprint("(new file) ");
-	if(addr.r.p2>0 && Fchars(f, &c, addr.r.p2-1, addr.r.p2) && c!='\n')
-		warn(Wnotnewline);
-	if(f->name.s[0]==0 || samename){
-		if(statfd(io, &qid, &mtime, 0) > 0){
-			f->inumber = qid;
-			f->date = mtime;
-		}
-	}
-	closeio(n);
-}
-
-Posn
-readio(File *f, int *nulls, int setdate)
-{
-	int n, b, w;
-	Rune *r;
-	Posn nt;
-	Posn p = addr.r.p2;
-	ulong qid;
-	long mtime;
-	char buf[BLOCKSIZE+1], *s;
-
-	*nulls = FALSE;
-	b = 0;
-	for(nt = 0; (n = read(io, buf+b, BLOCKSIZE-b))>0; nt+=(r-genbuf)){
-		n += b;
-		b = 0;
-		r = genbuf;
-		s = buf;
-		while(n > 0){
-			if((*r = *(uchar*)s) < Runeself){
-				if(*r)
-					r++;
-				else
-					*nulls = TRUE;
-				--n;
-				s++;
-				continue;
-			}
-			if(fullrune(s, n)){
-				w = chartorune(r, s);
-				if(*r)
-					r++;
-				else
-					*nulls = TRUE;
-				n -= w;
-				s += w;
-				continue;
-			}
-			b = n;
-			memmove(buf, s, b);
-			break;
-		}
-		Finsert(f, tmprstr(genbuf, r-genbuf), p);
-	}
-	if(b)
-		*nulls = TRUE;
-	if(*nulls)
-		warn(Wnulls);
-	if(setdate){
-		if(statfd(io, &qid, &mtime, 0) > 0){
-			f->inumber = qid;
-			f->date = mtime;
-		}
-	}
-	return nt;
-}
-
-Posn
-writeio(File *f)
-{
-	int m, n;
-	Posn p = addr.r.p1;
-	char *c;
-
-	while(p < addr.r.p2){
-		if(addr.r.p2-p>BLOCKSIZE)
-			n = BLOCKSIZE;
-		else
-			n = addr.r.p2-p;
-		if(Fchars(f, genbuf, p, p+n)!=n)
-			panic("writef read");
-		c = Strtoc(tmprstr(genbuf, n));
-		m = strlen(c);
-		if(Write(io, c, m) != m){
-			free(c);
-			if(p > 0)
-				p += n;
-			break;
-		}
-		free(c);
-		p += n;
-	}
-	return p-addr.r.p1;
-}
-void
-closeio(Posn p)
-{
-	close(io);
-	io = 0;
-	if(p >= 0)
-		dprint("#%lu\n", p);
-}
-
-int	remotefd0 = 0;
-int	remotefd1 = 1;
-
-void
-bootterm(char *machine, char **argv, char **end)
-{
-	int ph2t[2], pt2h[2];
-
-	if(machine){
-		dup(remotefd0, 0);
-		dup(remotefd1, 1);
-		close(remotefd0);
-		close(remotefd1);
-		argv[0] = "samterm";
-		*end = 0;
-		exec(samterm, argv);
-		fprint(2, "can't exec: ");
-		perror(samterm);
-		_exits("damn");
-	}
-	if(pipe(ph2t)==-1 || pipe(pt2h)==-1)
-		panic("pipe");
-	switch(fork()){
-	case 0:
-		dup(ph2t[0], 0);
-		dup(pt2h[1], 1);
-		close(ph2t[0]);
-		close(ph2t[1]);
-		close(pt2h[0]);
-		close(pt2h[1]);
-		argv[0] = "samterm";
-		*end = 0;
-		exec(samterm, argv);
-		fprint(2, "can't exec: ");
-		perror(samterm);
-		_exits("damn");
-	case -1:
-		panic("can't fork samterm");
-	}
-	dup(pt2h[0], 0);
-	dup(ph2t[1], 1);
-	close(ph2t[0]);
-	close(ph2t[1]);
-	close(pt2h[0]);
-	close(pt2h[1]);
-}
-
-void
-connectto(char *machine)
-{
-	int p1[2], p2[2];
-
-	if(pipe(p1)<0 || pipe(p2)<0){
-		dprint("can't pipe\n");
-		exits("pipe");
-	}
-	remotefd0 = p1[0];
-	remotefd1 = p2[1];
-	switch(fork()){
-	case 0:
-		dup(p2[0], 0);
-		dup(p1[1], 1);
-		close(p1[0]);
-		close(p1[1]);
-		close(p2[0]);
-		close(p2[1]);
-		execl(RXPATH, RX, machine, rsamname, "-R", (char*)0);
-		dprint("can't exec %s\n", RXPATH);
-		exits("exec");
-
-	case -1:
-		dprint("can't fork\n");
-		exits("fork");
-	}
-	close(p1[1]);
-	close(p2[0]);
-}
-
-void
-startup(char *machine, int Rflag, char **argv, char **end)
-{
-	if(machine)
-		connectto(machine);
-	if(!Rflag)
-		bootterm(machine, argv, end);
-	downloaded = 1;
-	outTs(Hversion, VERSION);
-}
//GO.SYSIN DD ./sam/io.c
echo ./sam/list.c
sed s/.// > ./sam/list.c <<'//GO.SYSIN DD ./sam/list.c'
-#include "sam.h"
-
-/*
- * Check that list has room for one more element.
- */
-void
-growlist(List *l)
-{
-	if(l->listptr==0 || l->nalloc==0){
-		l->nalloc = INCR;
-		l->listptr = emalloc(INCR*sizeof(long));
-		l->nused = 0;
-	}else if(l->nused == l->nalloc){
-		l->listptr = erealloc(l->listptr, (l->nalloc+INCR)*sizeof(long));
-		memset(l->longptr+l->nalloc, 0, INCR*sizeof(long));
-		l->nalloc += INCR;
-	}
-}
-
-/*
- * Remove the ith element from the list
- */
-void
-dellist(List *l, int i)
-{
-	memmove(&l->longptr[i], &l->longptr[i+1], (l->nused-(i+1))*sizeof(long));
-	l->nused--;
-}
-
-/*
- * Add a new element, whose position is i, to the list
- */
-void
-inslist(List *l, int i, long val)
-{
-	growlist(l);
-	memmove(&l->longptr[i+1], &l->longptr[i], (l->nused-i)*sizeof(long));
-	l->longptr[i] = val;
-	l->nused++;
-}
-
-void
-listfree(List *l)
-{
-	free(l->listptr);
-	free(l);
-}
//GO.SYSIN DD ./sam/list.c
echo ./sam/mesg.c
sed s/.// > ./sam/mesg.c <<'//GO.SYSIN DD ./sam/mesg.c'
-#include "sam.h"
-
-Header	h;
-uchar	indata[DATASIZE];
-uchar	outdata[2*DATASIZE+3];	/* room for overflow message */
-uchar	*inp;
-uchar	*outp;
-uchar	*outmsg = outdata;
-Posn	cmdpt;
-Posn	cmdptadv;
-Buffer	*snarfbuf;
-int	waitack;
-int	noflush;
-int	tversion;
-
-long	inlong(void);
-int	inshort(void);
-int	inmesg(Tmesg);
-void	setgenstr(File*, Posn, Posn);
-
-#ifdef DEBUG
-char *hname[] = {
-	[Hversion]	"Hversion",
-	[Hbindname]	"Hbindname",
-	[Hcurrent]	"Hcurrent",
-	[Hnewname]	"Hnewname",
-	[Hmovname]	"Hmovname",
-	[Hgrow]		"Hgrow",
-	[Hcheck0]	"Hcheck0",
-	[Hcheck]	"Hcheck",
-	[Hunlock]	"Hunlock",
-	[Hdata]		"Hdata",
-	[Horigin]	"Horigin",
-	[Hunlockfile]	"Hunlockfile",
-	[Hsetdot]	"Hsetdot",
-	[Hgrowdata]	"Hgrowdata",
-	[Hmoveto]	"Hmoveto",
-	[Hclean]	"Hclean",
-	[Hdirty]	"Hdirty",
-	[Hcut]		"Hcut",
-	[Hsetpat]	"Hsetpat",
-	[Hdelname]	"Hdelname",
-	[Hclose]	"Hclose",
-	[Hsetsnarf]	"Hsetsnarf",
-	[Hsnarflen]	"Hsnarflen",
-	[Hack]		"Hack",
-	[Hexit]		"Hexit",
-};
-
-char *tname[] = {
-	[Tversion]	"Tversion",
-	[Tstartcmdfile]	"Tstartcmdfile",
-	[Tcheck]	"Tcheck",
-	[Trequest]	"Trequest",
-	[Torigin]	"Torigin",
-	[Tstartfile]	"Tstartfile",
-	[Tworkfile]	"Tworkfile",
-	[Ttype]		"Ttype",
-	[Tcut]		"Tcut",
-	[Tpaste]	"Tpaste",
-	[Tsnarf]	"Tsnarf",
-	[Tstartnewfile]	"Tstartnewfile",
-	[Twrite]	"Twrite",
-	[Tclose]	"Tclose",
-	[Tsearch]	"Tsearch",
-	[Tlook]		"Tlook",
-	[Tsend]		"Tsend",
-	[Tstartsnarf]	"Tstartsnarf",
-	[Tsetsnarf]	"Tsetsnarf",
-	[Tdclick]	"Tdclick",
-	[Tack]		"Tack",
-	[Texit]		"Texit",
-};
-
-void
-journal(int out, char *s)
-{
-	static fd = 0;
-
-	if(fd <= 0)
-		fd = create("/tmp/sam.out", 1, 0666L);
-	fprint(fd, "%s%s\n", out? "out: " : "in:  ", s);
-}
-
-journaln(int out, int n)
-{
-	char buf[32];
-	sprint(buf, "%d", n);
-	journal(out, buf);
-}
-#else
-#define	journal(a, b)
-#define journaln(a, b)
-#endif
-
-int
-rcvchar(void){
-	static uchar buf[64];
-	static i, nleft = 0;
-
-	if(nleft <= 0){
-		nleft = read(0, (char *)buf, sizeof buf);
-		if(nleft <= 0)
-			return -1;
-		i = 0;
-	}
-	--nleft;
-	return buf[i++];
-}
-
-int
-rcv(void){
-	int c;
-	static state = 0;
-	static count = 0;
-	static i = 0;
-
-	while((c=rcvchar()) != -1)
-		switch(state){
-		case 0:
-			h.type = c;
-			state++;
-			break;
-
-		case 1:
-			h.count0 = c;
-			state++;
-			break;
-
-		case 2:
-			h.count1 = c;
-			count = h.count0|(h.count1<<8);
-			i = 0;
-			if(count > DATASIZE)
-				panic("count>DATASIZE");
-			if(count == 0)
-				goto zerocount;
-			state++;
-			break;
-
-		case 3:
-			indata[i++] = c;
-			if(i == count){
-		zerocount:
-				indata[i] = 0;
-				state = count = 0;
-				return inmesg(h.type);
-			}
-			break;
-		}
-	return 0;
-}
-
-File *
-whichfile(int tag)
-{
-	int i;
-
-	for(i = 0; i<file.nused; i++)
-		if(file.filepptr[i]->tag==tag)
-			return file.filepptr[i];
-	hiccough((char *)0);
-	return 0;
-}
-
-int
-inmesg(Tmesg type)
-{
-	Rune buf[1025];
-	int i, m;
-	short s;
-	long l, l1;
-	File *f;
-	Posn p0, p1;
-	Range r;
-	String *str;
-	char *c;
-
-	if(type > TMAX)
-		panic("inmesg");
-
-	journal(0, tname[type]);
-
-	inp = indata;
-	SET(c);
-	switch(type){
-	case -1:
-		panic("rcv error");
-
-	default:
-		fprint(2, "unknown type %d\n", type);
-		panic("rcv unknown");
-
-	case Tversion:
-		tversion = inshort();
-		journaln(0, tversion);
-		break;
-
-	case Tstartcmdfile:
-		l = inlong();
-		journaln(0, l);
-		Strdupl(&genstr, samname);
-		cmd = newfile();
-		outTsl(Hbindname, cmd->tag, l);
-		outTs(Hcurrent, cmd->tag);
-		Fsetname(cmd, &genstr);
-		cmd->rasp = emalloc(sizeof(List));
-		cmd->state = Clean;
-		if(cmdstr.n){
-			Finsert(cmd, &cmdstr, 0L);
-			Strdelete(&cmdstr, 0L, (Posn)cmdstr.n);
-		}
-		Fupdate(cmd, FALSE, TRUE);
-		outT0(Hunlock);
-		break;
-
-	case Tcheck:
-		/* go through whichfile to check the tag */
-		outTs(Hcheck, whichfile(inshort())->tag);
-		break;
-
-	case Trequest:
-		f = whichfile(inshort());
-		p0 = inlong();
-		p1 = p0+inshort();
-		journaln(0, p0);
-		journaln(0, p1-p0);
-		if(f->state == Unread)
-			panic("Trequest: unread");
-		if(p1>f->nrunes)
-			p1 = f->nrunes;
-		if(p0>f->nrunes) /* can happen e.g. scrolling during command */
-			p0 = f->nrunes;
-		if(p0 == p1){
-			i = 0;
-			r.p1 = r.p2 = p0;
-		}else{
-			r = rdata(f->rasp, p0, p1-p0);
-			i = r.p2-r.p1;
-			if(Fchars(f, buf, r.p1, r.p2)!=i)
-				panic("Trequest 2");
-		}
-		buf[i]=0;
-		outTslS(Hdata, f->tag, r.p1, tmprstr(buf, i+1));
-		break;
-
-	case Torigin:
-		s = inshort();
-		l = inlong();
-		l1 = inlong();
-		journaln(0, l1);
-		lookorigin(whichfile(s), l, l1);
-		break;
-
-	case Tstartfile:
-		f = whichfile(inshort());
-		if(!f->rasp)	/* this might be a duplicate message */
-			f->rasp = emalloc(sizeof(List));
-		current(f);
-		outTsl(Hbindname, f->tag, inlong());
-		outTs(Hcurrent, f->tag);
-		journaln(0, f->tag);
-		termlocked++;
-		if(f->state == Unread)
-			load(f);
-		else{
-			if(f->nrunes>0){
-				rgrow(f->rasp, 0L, f->nrunes);
-				outTsll(Hgrow, f->tag, 0L, f->nrunes);
-			}
-			outTs(Hcheck0, f->tag);
-			moveto(f, f->dot.r);
-		}
-		break;
-
-	case Tworkfile:
-		i = inshort();
-		f = whichfile(i);
-		current(f);
-		f->dot.r.p1 = inlong();
-		f->dot.r.p2 = inlong();
-		f->tdot = f->dot.r;
-		journaln(0, i);
-		journaln(0, f->dot.r.p1);
-		journaln(0, f->dot.r.p2);
-		break;
-
-	case Ttype:
-		f = whichfile(inshort());
-		p0 = inlong();
-		journaln(0, p0);
-		journal(0, (char*)inp);
-		str = tmpcstr((char*)inp);
-		i = str->n;
-		Finsert(f, str, p0);
-		if(Fupdate(f, FALSE, FALSE))
-			modnum++;
-		if(f==cmd && p0==f->nrunes-i && i>0 && str->s[i-1]=='\n'){
-			freetmpstr(str);
-			termlocked++;
-			termcommand();
-		}else
-			freetmpstr(str);
-		f->dot.r.p1 = f->dot.r.p2 = p0+i; /* terminal knows this already */
-		f->tdot = f->dot.r;
-		break;
-
-	case Tcut:
-		f = whichfile(inshort());
-		p0 = inlong();
-		p1 = inlong();
-		journaln(0, p0);
-		journaln(0, p1);
-		Fdelete(f, p0, p1);
-		if(Fupdate(f, FALSE, FALSE))
-			modnum++;
-		f->dot.r.p1 = f->dot.r.p2 = p0;
-		f->tdot = f->dot.r;   /* terminal knows the value of dot already */
-		break;
-
-	case Tpaste:
-		f = whichfile(inshort());
-		p0 = inlong();
-		journaln(0, p0);
-		for(l=0; l<snarfbuf->nrunes; l+=m){
-			m = snarfbuf->nrunes-l;
-			if(m>BLOCKSIZE)
-				m = BLOCKSIZE;
-			Bread(snarfbuf, genbuf, m, l);
-			Finsert(f, tmprstr(genbuf, m), p0);
-		}
-		if(Fupdate(f, FALSE, TRUE))
-			modnum++;
-		f->dot.r.p1 = p0;
-		f->dot.r.p2 = p0+snarfbuf->nrunes;
-		f->tdot.p1 = -1; /* force telldot to tell (arguably a BUG) */
-		telldot(f);
-		outTs(Hunlockfile, f->tag);
-		break;
-
-	case Tsnarf:
-		i = inshort();
-		p0 = inlong();
-		p1 = inlong();
-		snarf(whichfile(i), p0, p1, snarfbuf, 0);
-		break;
-
-	case Tstartnewfile:
-		l = inlong();
-		Strdupl(&genstr, empty);
-		f = newfile();
-		f->rasp = emalloc(sizeof(List));
-		outTsl(Hbindname, f->tag, l);
-		Fsetname(f, &genstr);
-		outTs(Hcurrent, f->tag);
-		current(f);
-		load(f);
-		break;
-
-	case Twrite:
-		termlocked++;
-		i = inshort();
-		journaln(0, i);
-		f = whichfile(i);
-		addr.r.p1 = 0;
-		addr.r.p2 = f->nrunes;
-		if(f->name.s[0] == 0)
-			error(Enoname);
-		Strduplstr(&genstr, &f->name);
-		writef(f);
-		break;
-
-	case Tclose:
-		i = inshort();
-		journaln(0, i);
-		f = whichfile(i);
-		current(f);
-		trytoclose(f);
-		break;
-
-	case Tlook:
-		f = whichfile(inshort());
-		termlocked++;
-		p0 = inlong();
-		p1 = inlong();
-		journaln(0, p0);
-		journaln(0, p1);
-		setgenstr(f, p0, p1);
-		for(l = 0; l<genstr.n; l++){
-			i = genstr.s[l];
-			if(utfrune(".*+?(|)\\[]^$", i))
-				Strinsert(&genstr, tmpcstr("\\"), l++);
-		}
-		Straddc(&genstr, '\0');
-		nextmatch(f, &genstr, p1, 1);
-		moveto(f, sel.p[0]);
-		break;
-
-	case Tsearch:
-		termlocked++;
-		if(curfile == 0)
-			error(Enofile);
-		if(lastpat.s[0] == 0)
-			panic("Tsearch");
-		nextmatch(curfile, &lastpat, curfile->dot.r.p2, 1);
-		moveto(curfile, sel.p[0]);
-		break;
-
-	case Tsend:
-		termlocked++;
-		inshort();	/* ignored */
-		p0 = inlong();
-		p1 = inlong();
-		setgenstr(cmd, p0, p1);
-		Bdelete(snarfbuf, (Posn)0, snarfbuf->nrunes);
-		Binsert(snarfbuf, &genstr, (Posn)0);
-		outTl(Hsnarflen, genstr.n);
-		if(genstr.s[genstr.n-1] != '\n')
-			Straddc(&genstr, '\n');
-		Finsert(cmd, &genstr, cmd->nrunes);
-		Fupdate(cmd, FALSE, TRUE);
-		cmd->dot.r.p1 = cmd->dot.r.p2 = cmd->nrunes;
-		telldot(cmd);
-		termcommand();
-		break;
-
-	case Tdclick:
-		f = whichfile(inshort());
-		p1 = inlong();
-		doubleclick(f, p1);
-		f->tdot.p1 = f->tdot.p2 = p1;
-		telldot(f);
-		outTs(Hunlockfile, f->tag);
-		break;
-
-	case Tstartsnarf:
-		i = -1;
-		if(snarfbuf->nrunes < BLOCKSIZE){
-			Bread(snarfbuf, genbuf, snarfbuf->nrunes, 0);
-			c = Strtoc(tmprstr(genbuf, snarfbuf->nrunes));
-			i = strlen(c);
-			if(i > SNARFSIZE){
-				free(c);
-				i = -1;
-			}
-		}
-		if(i < 0){
-			dprint("snarf buffer too long\n");
-			i = 0;
-		}
-		outTs(Hsetsnarf, i);
-		if(i){
-			Write(1, c, i);
-			free(c);
-		}
-		break;
-
-	case Tsetsnarf:
-		m = inshort();
-		if(m > SNARFSIZE)
-			error(Etoolong);
-		c = malloc(m+1);
-		if(c){
-			for(i=0; i<m; i++)
-				c[i] = rcvchar();
-			c[m] = 0;
-			str = tmpcstr(c);
-			free(c);
-			Bdelete(snarfbuf, (Posn)0, snarfbuf->nrunes);
-			Binsert(snarfbuf, str, (Posn)0);
-			freetmpstr(str);
-			outT0(Hunlock);
-		}
-		break;
-
-	case Tack:
-		waitack = 0;
-		break;
-
-	case Texit:
-		exits(0);
-	}
-	return TRUE;
-}
-
-void
-snarf(File *f, Posn p1, Posn p2, Buffer *buf, int emptyok)
-{
-	Posn l;
-	int i;
-
-	if(!emptyok && p1==p2)
-		return;
-	Bdelete(buf, (Posn)0, buf->nrunes);
-	/* Stage through genbuf to avoid compaction problems (vestigial) */
-	for(l=p1; l<p2; l+=i){
-		i = p2-l>BLOCKSIZE? BLOCKSIZE : p2-l;
-		Fchars(f, genbuf, l, l+i);
-		Binsert(buf, tmprstr(genbuf, i), buf->nrunes);
-	}
-}
-
-int
-inshort(void)
-{
-	ushort n;
-
-	n = inp[0] | (inp[1]<<8);
-	inp += 2;
-	return n;
-}
-
-long
-inlong(void)
-{
-	ulong n;
-
-	n = inp[0] | (inp[1]<<8) | (inp[2]<<16) | (inp[3]<<24);
-	inp += 4;
-	return n;
-}
-
-void
-setgenstr(File *f, Posn p0, Posn p1)
-{
-	if(p0 != p1){
-		if(p1-p0 >= TBLOCKSIZE)
-			error(Etoolong);
-		Strinsure(&genstr, p1-p0);
-		Fchars(f, genbuf, p0, p1);
-		memmove(genstr.s, genbuf, RUNESIZE*(p1-p0));
-		genstr.n = p1-p0;
-	}else{
-		if(snarfbuf->nrunes == 0)
-			error(Eempty);
-		if(snarfbuf->nrunes > TBLOCKSIZE)
-			error(Etoolong);
-		Bread(snarfbuf, genbuf, snarfbuf->nrunes, (Posn)0);
-		Strinsure(&genstr, snarfbuf->nrunes);
-		memmove(genstr.s, genbuf, RUNESIZE*snarfbuf->nrunes);
-		genstr.n = snarfbuf->nrunes;
-	}
-}
-
-void
-outT0(Hmesg type)
-{
-	outstart(type);
-	outsend();
-}
-
-void
-outTl(Hmesg type, long l)
-{
-	outstart(type);
-	outlong(l);
-	outsend();
-}
-
-void
-outTs(Hmesg type, int s)
-{
-	outstart(type);
-	journaln(1, s);
-	outshort(s);
-	outsend();
-}
-
-void
-outS(String *s)
-{
-	char *c;
-	int i;
-
-	c = Strtoc(s);
-	i = strlen(c);
-	outcopy(i, c);
-	if(i > 99)
-		c[99] = 0;
-	journaln(1, i);
-	journal(1, c);
-	free(c);
-}
-
-void
-outTsS(Hmesg type, int s1, String *s)
-{
-	outstart(type);
-	outshort(s1);
-	outS(s);
-	outsend();
-}
-
-void
-outTslS(Hmesg type, int s1, Posn l1, String *s)
-{
-	outstart(type);
-	outshort(s1);
-	journaln(1, s1);
-	outlong(l1);
-	journaln(1, l1);
-	outS(s);
-	outsend();
-}
-
-void
-outTS(Hmesg type, String *s)
-{
-	outstart(type);
-	outS(s);
-	outsend();
-}
-
-void
-outTsllS(Hmesg type, int s1, Posn l1, Posn l2, String *s)
-{
-	outstart(type);
-	outshort(s1);
-	outlong(l1);
-	outlong(l2);
-	journaln(1, l1);
-	journaln(1, l2);
-	outS(s);
-	outsend();
-}
-
-void
-outTsll(Hmesg type, int s, Posn l1, Posn l2)
-{
-	outstart(type);
-	outshort(s);
-	outlong(l1);
-	outlong(l2);
-	journaln(1, l1);
-	journaln(1, l2);
-	outsend();
-}
-
-void
-outTsl(Hmesg type, int s, Posn l)
-{
-	outstart(type);
-	outshort(s);
-	outlong(l);
-	journaln(1, l);
-	outsend();
-}
-
-void
-outstart(Hmesg type)
-{
-	journal(1, hname[type]);
-	outmsg[0] = type;
-	outp = outmsg+3;
-}
-
-void
-outcopy(int count, void *data)
-{
-	memmove(outp, data, count);
-	outp += count;
-}
-
-void
-outshort(int s)
-{
-	*outp++ = s;
-	*outp++ = s>>8; 
-}
-
-void
-outlong(long l)
-{
-	*outp++ = l;
-	*outp++ = l>>8;
-	*outp++ = l>>16;
-	*outp++ = l>>24;
-}
-
-void
-outsend(void)
-{
-	int outcount;
-
-	outcount = outp-outmsg;
-	outcount -= 3;
-	outmsg[1] = outcount;
-	outmsg[2] = outcount>>8;
-	outmsg = outp;
-	if(!noflush){
-		Write(1, outdata, outmsg-outdata);
-		outmsg = outdata;
-		return;
-	}
-	if(outmsg < outdata+DATASIZE)
-		return;
-	outflush();
-}
-
-void
-outflush(void)
-{
-	if(outmsg == outdata)
-		return;
-	noflush = 0;
-	outT0(Hack);
-	waitack = 1;
-	do
-		if(rcv() == 0){
-			rescue();
-			exits("eof");
-		}
-	while(waitack);
-	outmsg = outdata;
-	noflush = 1;
-}
//GO.SYSIN DD ./sam/mesg.c
echo ./sam/mesg.h
sed s/.// > ./sam/mesg.h <<'//GO.SYSIN DD ./sam/mesg.h'
-#define	VERSION	0
-
-#define	TBLOCKSIZE 512		  /* largest piece of text sent to terminal */
-#define	DATASIZE  (UTFmax*TBLOCKSIZE+30) /* ... including protocol header stuff */
-#define	SNARFSIZE 4096		/* maximum length of exchanged snarf buffer */
-/*
- * Messages originating at the terminal
- */
-typedef enum Tmesg
-{
-	Tversion,	/* version */
-	Tstartcmdfile,	/* terminal just opened command frame */
-	Tcheck,		/* ask host to poke with Hcheck */
-	Trequest,	/* request data to fill a hole */
-	Torigin,	/* gimme an Horigin near here */
-	Tstartfile,	/* terminal just opened a file's frame */
-	Tworkfile,	/* set file to which commands apply */
-	Ttype,		/* add some characters, but terminal already knows */
-	Tcut,
-	Tpaste,
-	Tsnarf,
-	Tstartnewfile,	/* terminal just opened a new frame */
-	Twrite,		/* write file */
-	Tclose,		/* terminal requests file close; check mod. status */
-	Tlook,		/* search for literal current text */
-	Tsearch,	/* search for last regular expression */
-	Tsend,		/* pretend he typed stuff */
-	Tdclick,	/* double click */
-	Tstartsnarf,	/* initiate snarf buffer exchange */
-	Tsetsnarf,	/* remember string in snarf buffer */
-	Tack,		/* acknowledge Hack */
-	Texit,		/* exit */
-	TMAX
-}Tmesg;
-/*
- * Messages originating at the host
- */
-typedef enum Hmesg
-{
-	Hversion,	/* version */
-	Hbindname,	/* attach name[0] to text in terminal */
-	Hcurrent,	/* make named file the typing file */
-	Hnewname,	/* create "" name in menu */
-	Hmovname,	/* move file name in menu */
-	Hgrow,		/* insert space in rasp */
-	Hcheck0,	/* see below */
-	Hcheck,		/* ask terminal to check whether it needs more data */
-	Hunlock,	/* command is finished; user can do things */
-	Hdata,		/* store this data in previously allocated space */
-	Horigin,	/* set origin of file/frame in terminal */
-	Hunlockfile,	/* unlock file in terminal */
-	Hsetdot,	/* set dot in terminal */
-	Hgrowdata,	/* Hgrow + Hdata folded together */
-	Hmoveto,	/* scrolling, context search, etc. */
-	Hclean,		/* named file is now 'clean' */
-	Hdirty,		/* named file is now 'dirty' */
-	Hcut,		/* remove space from rasp */
-	Hsetpat,	/* set remembered regular expression */
-	Hdelname,	/* delete file name from menu */
-	Hclose,		/* close file and remove from menu */
-	Hsetsnarf,	/* remember string in snarf buffer */
-	Hsnarflen,	/* report length of implicit snarf */
-	Hack,		/* request acknowledgement */
-	Hexit,
-	HMAX
-}Hmesg;
-typedef struct Header{
-	uchar	type;		/* one of the above */
-	uchar	count0;		/* low bits of data size */
-	uchar	count1;		/* high bits of data size */
-	uchar	data[1];	/* variable size */
-}Header;
-/*
- * File transfer protocol schematic, a la Holzmann
- *	
- *	proc h
- *	{	pvar n = 0;
- *		queue h[4];
- *	
- *		do
- *		:: (n <  N)  -> n++; t!Hgrow
- *		:: (n == N)  -> n++; t!Hcheck0
- *		:: h?Trequest -> t!Hdata
- *		:: h?Tcheck  -> t!Hcheck
- *		od
- *	}
- *	proc t
- *	{	queue t[4];
- *		do
- *		:: t?Hgrow -> h!Trequest
- *		:: t?Hdata -> skip
- *		:: t?Hcheck0 -> h!Tcheck
- *		:: t?Hcheck ->
- *			if
- *			:: break
- *			:: h!Trequest; h!Tcheck
- *			fi
- *		od
- *	}
- */
//GO.SYSIN DD ./sam/mesg.h
echo ./sam/moveto.c
sed s/.// > ./sam/moveto.c <<'//GO.SYSIN DD ./sam/moveto.c'
-#include "sam.h"
-
-void
-moveto(File *f, Range r)
-{
-	Posn p1 = r.p1, p2 = r.p2;
-
-	f->dot.r.p1 = p1;
-	f->dot.r.p2 = p2;
-	if(f->rasp){
-		telldot(f);
-		outTsl(Hmoveto, f->tag, f->dot.r.p1);
-	}
-}
-
-void
-telldot(File *f)
-{
-	if(f->rasp == 0)
-		panic("telldot");
-	if(f->dot.r.p1==f->tdot.p1 && f->dot.r.p2==f->tdot.p2)
-		return;
-	outTsll(Hsetdot, f->tag, f->dot.r.p1, f->dot.r.p2);
-	f->tdot = f->dot.r;
-}
-
-void
-tellpat(void)
-{
-	outTS(Hsetpat, &lastpat);
-	patset = FALSE;
-}
-
-#define	CHARSHIFT	128
-
-void
-lookorigin(File *f, Posn p0, Posn ls)
-{
-	int nl, nc, c;
-	Posn oldp0;
-
-	if(p0 > f->nrunes)
-		p0 = f->nrunes;
-	oldp0 = p0;
-	Fgetcset(f, p0);
-	for(nl=nc=c=0; c!=-1 && nl<ls && nc<ls*CHARSHIFT; nc++)
-		if((c=Fbgetc(f)) == '\n'){
-			nl++;
-			oldp0 = p0-nc;
-		}
-	if(c == -1)
-		p0 = 0;
-	else if(nl==0){
-		if(p0>=CHARSHIFT/2)
-			p0-=CHARSHIFT/2;
-		else
-			p0 = 0;
-	}else
-		p0 = oldp0;
-	outTsl(Horigin, f->tag, p0);
-}
-
-int
-alnum(int c)
-{
-	/*
-	 * Hard to get absolutely right.  Use what we know about ASCII
-	 * and assume anything above the Latin control characters is
-	 * potentially an alphanumeric.
-	 */
-	if(c<=' ')
-		return 0;
-	if(0x7F<=c && c<=0xA0)
-		return 0;
-	if(utfrune("!\"#$%&'()*+,-./:;<=>?@[\\]^`{|}~", c))
-		return 0;
-	return 1;
-}
-
-int
-clickmatch(File *f, int cl, int cr, int dir)
-{
-	int c;
-	int nest = 1;
-
-	while((c=(dir>0? Fgetc(f) : Fbgetc(f))) > 0)
-		if(c == cr){
-			if(--nest==0)
-				return 1;
-		}else if(c == cl)
-			nest++;
-	return cl=='\n' && nest==1;
-}
-
-Rune*
-strrune(Rune *s, Rune c)
-{
-	Rune c1;
-
-	if(c == 0) {
-		while(*s++)
-			;
-		return s-1;
-	}
-
-	while(c1 = *s++)
-		if(c1 == c)
-			return s-1;
-	return 0;
-}
-
-void
-doubleclick(File *f, Posn p1)
-{
-	int c, i;
-	Rune *r, *l;
-
-	if(p1 > f->nrunes)
-		return;
-	f->dot.r.p1 = f->dot.r.p2 = p1;
-	for(i=0; left[i]; i++){
-		l = left[i];
-		r = right[i];
-		/* try left match */
-		if(p1 == 0){
-			Fgetcset(f, p1);
-			c = '\n';
-		}else{
-			Fgetcset(f, p1-1);
-			c = Fgetc(f);
-		}
-		if(c!=-1 && strrune(l, c)){
-			if(clickmatch(f, c, r[strrune(l, c)-l], 1)){
-				f->dot.r.p1 = p1;
-				f->dot.r.p2 = f->getcp-(c!='\n');
-			}
-			return;
-		}
-		/* try right match */
-		if(p1 == f->nrunes){
-			Fbgetcset(f, p1);
-			c = '\n';
-		}else{
-			Fbgetcset(f, p1+1);
-			c = Fbgetc(f);
-		}
-		if(c!=-1 && strrune(r, c)){
-			if(clickmatch(f, c, l[strrune(r, c)-r], -1)){
-				f->dot.r.p1 = f->getcp;
-				if(c!='\n' || f->getcp!=0 ||
-				   (Fgetcset(f, (Posn)0),Fgetc(f))=='\n')
-					f->dot.r.p1++;
-				f->dot.r.p2 = p1+(p1<f->nrunes && c=='\n');
-			}
-			return;
-		}
-	}
-	/* try filling out word to right */
-	Fgetcset(f, p1);
-	while((c=Fgetc(f))!=-1 && alnum(c))
-		f->dot.r.p2++;
-	/* try filling out word to left */
-	Fbgetcset(f, p1);
-	while((c=Fbgetc(f))!=-1 && alnum(c))
-		f->dot.r.p1--;
-}
-
//GO.SYSIN DD ./sam/moveto.c
echo ./sam/multi.c
sed s/.// > ./sam/multi.c <<'//GO.SYSIN DD ./sam/multi.c'
-#include "sam.h"
-
-List	file;
-ushort	tag;
-
-File *
-newfile(void)
-{
-	File *f;
-
-	inslist(&file, 0, (long)(f = Fopen()));
-	f->tag = tag++;
-	if(downloaded)
-		outTs(Hnewname, f->tag);
-	/* already sorted; file name is "" */
-	return f;
-}
-
-int
-whichmenu(File *f)
-{
-	int i;
-
-	for(i=0; i<file.nused; i++)
-		if(file.filepptr[i]==f)
-			return i;
-	return -1;
-}
-
-void
-delfile(File *f)
-{
-	int w = whichmenu(f);
-
-	if(w < 0)	/* e.g. x/./D */
-		return;
-	if(downloaded)
-		outTs(Hdelname, f->tag);
-	dellist(&file, w);
-	Fclose(f);
-}
-
-void
-sortname(File *f)
-{
-	int i, cmp, w;
-	int dupwarned;
-
-	w = whichmenu(f);
-	dupwarned = FALSE;
-	dellist(&file, w);
-	if(f == cmd)
-		i = 0;
-	else for(i=0; i<file.nused; i++){
-		cmp = Strcmp(&f->name, &file.filepptr[i]->name);
-		if(cmp==0 && !dupwarned){
-			dupwarned = TRUE;
-			warn_S(Wdupname, &f->name);
-		}else if(cmp<0 && (i>0 || cmd==0))
-			break;
-	}
-	inslist(&file, i, (long)f);
-	if(downloaded)
-		outTsS(Hmovname, f->tag, &f->name);
-}
-
-void
-state(File *f, int cleandirty)
-{
-	if(f == cmd)
-		return;
-	if(downloaded && whichmenu(f)>=0){	/* else flist or menu */
-		if(f->state==Dirty && cleandirty!=Dirty)
-			outTs(Hclean, f->tag);
-		else if(f->state!=Dirty && cleandirty==Dirty)
-			outTs(Hdirty, f->tag);
-	}
-	f->state = cleandirty;
-}
-
-File *
-lookfile(String *s)
-{
-	int i;
-
-	for(i=0; i<file.nused; i++)
-		if(Strcmp(&file.filepptr[i]->name, s) == 0)
-			return file.filepptr[i];
-	return 0;
-}
//GO.SYSIN DD ./sam/multi.c
echo ./sam/parse.h
sed s/.// > ./sam/parse.h <<'//GO.SYSIN DD ./sam/parse.h'
-typedef struct Addr Addr;
-typedef struct Cmd Cmd;
-struct Addr
-{
-	char	type;	/* # (char addr), l (line addr), / ? . $ + - , ; */
-	union{
-		String	*re;
-		Addr	*aleft;		/* left side of , and ; */
-	} g;
-	Posn	num;
-	Addr	*next;			/* or right side of , and ; */
-};
-
-#define	are	g.re
-#define	left	g.aleft
-
-struct Cmd
-{
-	Addr	*addr;			/* address (range of text) */
-	String	*re;			/* regular expression for e.g. 'x' */
-	union{
-		Cmd	*cmd;		/* target of x, g, {, etc. */
-		String	*text;		/* text of a, c, i; rhs of s */
-		Addr	*addr;		/* address for m, t */
-	} g;
-	Cmd	*next;			/* pointer to next element in {} */
-	short	num;
-	ushort	flag;			/* whatever */
-	ushort	cmdc;			/* command character; 'x' etc. */
-};
-
-#define	ccmd	g.cmd
-#define	ctext	g.text
-#define	caddr	g.addr
-
-extern struct cmdtab{
-	ushort	cmdc;		/* command character */
-	uchar	text;		/* takes a textual argument? */
-	uchar	regexp;		/* takes a regular expression? */
-	uchar	addr;		/* takes an address (m or t)? */
-	uchar	defcmd;		/* default command; 0==>none */
-	uchar	defaddr;	/* default address */
-	uchar	count;		/* takes a count e.g. s2/// */
-	char	*token;		/* takes text terminated by one of these */
-	int	(*fn)(File*, Cmd*);	/* function to call with parse tree */
-}cmdtab[];
-
-enum Defaddr{	/* default addresses */
-	aNo,
-	aDot,
-	aAll
-};
-
-int	nl_cmd(File*, Cmd*), a_cmd(File*, Cmd*), b_cmd(File*, Cmd*);
-int	c_cmd(File*, Cmd*), cd_cmd(File*, Cmd*), d_cmd(File*, Cmd*);
-int	D_cmd(File*, Cmd*), e_cmd(File*, Cmd*);
-int	f_cmd(File*, Cmd*), g_cmd(File*, Cmd*), i_cmd(File*, Cmd*);
-int	k_cmd(File*, Cmd*), m_cmd(File*, Cmd*), n_cmd(File*, Cmd*);
-int	p_cmd(File*, Cmd*), q_cmd(File*, Cmd*);
-int	s_cmd(File*, Cmd*), u_cmd(File*, Cmd*), w_cmd(File*, Cmd*);
-int	x_cmd(File*, Cmd*), X_cmd(File*, Cmd*), plan9_cmd(File*, Cmd*);
-int	eq_cmd(File*, Cmd*);
-
-
-String	*getregexp(int);
-Addr	*newaddr(void);
-Address	address(Addr*, Address, int);
-int	cmdexec(File*, Cmd*);
//GO.SYSIN DD ./sam/parse.h
echo ./sam/rasp.c
sed s/.// > ./sam/rasp.c <<'//GO.SYSIN DD ./sam/rasp.c'
-#include "sam.h"
-/*
- * GROWDATASIZE must be big enough that all errors go out as Hgrowdata's,
- * so they will be scrolled into visibility in the ~~sam~~ window (yuck!).
- */
-#define	GROWDATASIZE	50	/* if size is > this, send data with grow */
-
-void	rcut(List*, Posn, Posn);
-int	rterm(List*, Posn);
-void	rgrow(List*, Posn, Posn);
-
-void
-toterminal(File *f, int toterm)
-{
-	Buffer *t = f->transcript;
-	Posn n, p0, p1, p2, delta = 0, deltacmd = 0;
-	Range r;
-	union{
-		union	Hdr g;
-		Rune	buf[8+GROWDATASIZE];
-	}hdr;
-	Posn growpos, grown;
-
-	if(f->rasp == 0)
-		return;
-	if(f->marked)
-		p0 = f->markp+sizeof(Mark)/RUNESIZE;
-	else
-		p0 = 0;
-	grown = 0;
-	noflush = 1;
-	SET(growpos);
-	while(Bread(t, (Rune*)&hdr, sizeof(hdr)/RUNESIZE, p0) > 0){
-		switch(hdr.g.cs.c){
-		default:
-			fprint(2, "char %c %.2x\n", hdr.g.cs.c, hdr.g.cs.c);
-			panic("unknown in toterminal");
-
-		case 'd':
-			if(grown){
-				outTsll(Hgrow, f->tag, growpos, grown);
-				grown = 0;
-			}
-			p1 = hdr.g.cll.l;
-			p2 = hdr.g.cll.l1;
-			if(p2 <= p1)
-				panic("toterminal delete 0");
-			if(f==cmd && p1<cmdpt){
-				if(p2 <= cmdpt)
-					deltacmd -= (p2-p1);
-				else
-					deltacmd -= cmdpt-p1;
-			}
-			p1 += delta;
-			p2 += delta;
-			p0 += sizeof(struct _cll)/RUNESIZE;
-			if(toterm)
-				outTsll(Hcut, f->tag, p1, p2-p1);
-			rcut(f->rasp, p1, p2);
-			delta -= p2-p1;
-			break;
-
-		case 'f':
-			if(grown){
-				outTsll(Hgrow, f->tag, growpos, grown);
-				grown = 0;
-			}
-			n = hdr.g.cs.s;
-			p0 += sizeof(struct _cs)/RUNESIZE + n;
-			break;
-
-		case 'i':
-			n = hdr.g.csl.s;
-			p1 = hdr.g.csl.l;
-			p0 += sizeof(struct _csl)/RUNESIZE + n;
-			if(n <= 0)
-				panic("toterminal insert 0");
-			if(f==cmd && p1<cmdpt)
-				deltacmd += n;
-			p1 += delta;
-			if(toterm){
-				if(n>GROWDATASIZE || !rterm(f->rasp, p1)){
-					rgrow(f->rasp, p1, n);
-					if(grown && growpos+grown!=p1){
-						outTsll(Hgrow, f->tag, growpos, grown);
-						grown = 0;
-					}
-					if(grown)
-						grown += n;
-					else{
-						growpos = p1;
-						grown = n;
-					}
-				}else{
-					Rune *rp;
-					if(grown){
-						outTsll(Hgrow, f->tag, growpos, grown);
-						grown = 0;
-					}
-					rp = hdr.buf+sizeof(hdr.g.csl)/RUNESIZE;
-					rgrow(f->rasp, p1, n);
-					r = rdata(f->rasp, p1, n);
-					if(r.p1!=p1 || r.p2!=p1+n)
-						panic("rdata in toterminal");
-					outTsllS(Hgrowdata, f->tag, p1, n, tmprstr(rp, n));
-				}
-			}else{
-				rgrow(f->rasp, p1, n);
-				r = rdata(f->rasp, p1, n);
-				if(r.p1!=p1 || r.p2!=p1+n)
-					panic("rdata in toterminal");
-			}
-			delta += n;
-			break;
-		}
-	}
-	if(grown)
-		outTsll(Hgrow, f->tag, growpos, grown);
-	if(toterm)
-		outTs(Hcheck0, f->tag);
-	outflush();
-	noflush = 0;
-	if(f == cmd){
-		cmdpt += deltacmd+cmdptadv;
-		cmdptadv = 0;
-	}
-}
-
-#define	M	0x80000000L
-#define	P(i)	r->longptr[i]
-#define	T(i)	(P(i)&M)	/* in terminal */
-#define	L(i)	(P(i)&~M)	/* length of this piece */
-
-void
-rcut(List *r, Posn p1, Posn p2)
-{
-	Posn p, x;
-	int i;
-
-	if(p1 == p2)
-		panic("rcut 0");
-	for(p=0,i=0; i<r->nused && p+L(i)<=p1; p+=L(i++))
-		;
-	if(i == r->nused)
-		panic("rcut 1");
-	if(p<p1){	/* chop this piece */
-		if(p+L(i) < p2){
-			x = p1-p;
-			p += L(i);
-		}else{
-			x = L(i)-(p2-p1);
-			p = p2;
-		}
-		if(T(i))
-			P(i) = x|M;
-		else
-			P(i) = x;
-		i++;
-	}
-	while(i<r->nused && p+L(i)<=p2){
-		p += L(i);
-		dellist(r, i);
-	}
-	if(p<p2){
-		if(i == r->nused)
-			panic("rcut 2");
-		x = L(i)-(p2-p);
-		if(T(i))
-			P(i) = x|M;
-		else
-			P(i) = x;
-	}
-	/* can we merge i and i-1 ? */
-	if(i>0 && i<r->nused && T(i-1)==T(i)){
-		x = L(i-1)+L(i);
-		dellist(r, i--);
-		if(T(i))
-			P(i)=x|M;
-		else
-			P(i)=x;
-	}
-}
-
-void
-rgrow(List *r, Posn p1, Posn n)
-{
-	Posn p;
-	int i;
-
-	if(n == 0)
-		panic("rgrow 0");
-	for(p=0,i=0; i<r->nused && p+L(i)<=p1; p+=L(i++))
-		;
-	if(i == r->nused){	/* stick on end of file */
-		if(p!=p1)
-			panic("rgrow 1");
-		if(i>0 && !T(i-1))
-			P(i-1)+=n;
-		else
-			inslist(r, i, n);
-	}else if(!T(i))		/* goes in this empty piece */
-		P(i)+=n;
-	else if(p==p1 && i>0 && !T(i-1))	/* special case; simplifies life */
-		P(i-1)+=n;
-	else if(p==p1)
-		inslist(r, i, n);
-	else{			/* must break piece in terminal */
-		inslist(r, i+1, (L(i)-(p1-p))|M);
-		inslist(r, i+1, n);
-		P(i) = (p1-p)|M;
-	}
-}
-
-int
-rterm(List *r, Posn p1)
-{
-	Posn p;
-	int i;
-
-	for(p = 0,i = 0; i<r->nused && p+L(i)<=p1; p+=L(i++))
-		;
-	if(i==r->nused && (i==0 || !T(i-1)))
-		return 0;
-	return T(i);
-}
-
-Range
-rdata(List *r, Posn p1, Posn n)
-{
-	Posn p;
-	int i;
-	Range rg;
-
-	if(n==0)
-		panic("rdata 0");
-	for(p = 0,i = 0; i<r->nused && p+L(i)<=p1; p+=L(i++))
-		;
-	if(i==r->nused)
-		panic("rdata 1");
-	if(T(i)){
-		n-=L(i)-(p1-p);
-		if(n<=0){
-			rg.p1 = rg.p2 = p1;
-			return rg;
-		}
-		p+=L(i++);
-		p1 = p;
-	}
-	if(T(i) || i==r->nused)
-		panic("rdata 2");
-	if(p+L(i)<p1+n)
-		n = L(i)-(p1-p);
-	rg.p1 = p1;
-	rg.p2 = p1+n;
-	if(p!=p1){
-		inslist(r, i+1, L(i)-(p1-p));
-		P(i)=p1-p;
-		i++;
-	}
-	if(L(i)!=n){
-		inslist(r, i+1, L(i)-n);
-		P(i)=n;
-	}
-	P(i)|=M;
-	/* now i is set; can we merge? */
-	if(i<r->nused-1 && T(i+1)){
-		P(i)=(n+=L(i+1))|M;
-		dellist(r, i+1);
-	}
-	if(i>0 && T(i-1)){
-		P(i)=(n+L(i-1))|M;
-		dellist(r, i-1);
-	}
-	return rg;
-}
//GO.SYSIN DD ./sam/rasp.c
echo ./sam/regexp.c
sed s/.// > ./sam/regexp.c <<'//GO.SYSIN DD ./sam/regexp.c'
-#include "sam.h"
-
-Rangeset	sel;
-String		lastregexp;
-/*
- * Machine Information
- */
-typedef struct Inst Inst;
-
-struct Inst
-{
-	long	type;	/* < 0x10000 ==> literal, otherwise action */
-	union {
-		int rsid;
-		int rsubid;
-		int class;
-		struct Inst *rother;
-		struct Inst *rright;
-	} r;
-	union{
-		struct Inst *lleft;
-		struct Inst *lnext;
-	} l;
-};
-#define	sid	r.rsid
-#define	subid	r.rsubid
-#define	rclass	r.class
-#define	other	r.rother
-#define	right	r.rright
-#define	left	l.lleft
-#define	next	l.lnext
-
-#define	NPROG	1024
-Inst	program[NPROG];
-Inst	*progp;
-Inst	*startinst;	/* First inst. of program; might not be program[0] */
-Inst	*bstartinst;	/* same for backwards machine */
-
-typedef struct Ilist Ilist;
-struct Ilist
-{
-	Inst	*inst;		/* Instruction of the thread */
-	Rangeset se;
-	Posn	startp;		/* first char of match */
-};
-
-#define	NLIST	128
-
-Ilist	*tl, *nl;	/* This list, next list */
-Ilist	list[2][NLIST];
-static	Rangeset sempty;
-
-/*
- * Actions and Tokens
- *
- *	0x100xx are operators, value == precedence
- *	0x200xx are tokens, i.e. operands for operators
- */
-#define	OPERATOR	0x10000	/* Bitmask of all operators */
-#define	START		0x10000	/* Start, used for marker on stack */
-#define	RBRA		0x10001	/* Right bracket, ) */
-#define	LBRA		0x10002	/* Left bracket, ( */
-#define	OR		0x10003	/* Alternation, | */
-#define	CAT		0x10004	/* Concatentation, implicit operator */
-#define	STAR		0x10005	/* Closure, * */
-#define	PLUS		0x10006	/* a+ == aa* */
-#define	QUEST		0x10007	/* a? == a|nothing, i.e. 0 or 1 a's */
-#define	ANY		0x20000	/* Any character but newline, . */
-#define	NOP		0x20001	/* No operation, internal use only */
-#define	BOL		0x20002	/* Beginning of line, ^ */
-#define	EOL		0x20003	/* End of line, $ */
-#define	CCLASS		0x20004	/* Character class, [] */
-#define	NCCLASS		0x20005	/* Negated character class, [^] */
-#define	END		0x20077	/* Terminate: match found */
-
-#define	ISATOR		0x10000
-#define	ISAND		0x20000
-
-/*
- * Parser Information
- */
-typedef struct Node Node;
-struct Node
-{
-	Inst	*first;
-	Inst	*last;
-};
-
-#define	NSTACK	20
-Node	andstack[NSTACK];
-Node	*andp;
-int	atorstack[NSTACK];
-int	*atorp;
-int	lastwasand;	/* Last token was operand */
-int	cursubid;
-int	subidstack[NSTACK];
-int	*subidp;
-int	backwards;
-int	nbra;
-Rune	*exprp;		/* pointer to next character in source expression */
-#define	DCLASS	10	/* allocation increment */
-int	nclass;		/* number active */
-int	Nclass;		/* high water mark */
-Rune	**class;
-int	negateclass;
-
-void	addinst(Ilist *l, Inst *inst, Rangeset *sep);
-void	newmatch(Rangeset*);
-void	bnewmatch(Rangeset*);
-void	pushand(Inst*, Inst*);
-void	pushator(int);
-Node	*popand(int);
-int	popator(void);
-void	startlex(Rune*);
-int	lex(void);
-void	operator(int);
-void	operand(int);
-void	evaluntil(int);
-void	optimize(Inst*);
-void	bldcclass(void);
-
-void
-regerror(Err e)
-{
-	Strzero(&lastregexp);
-	error(e);
-}
-
-void
-regerror_c(Err e, int c)
-{
-	Strzero(&lastregexp);
-	error_c(e, c);
-}
-
-Inst *
-newinst(int t)
-{
-	if(progp >= &program[NPROG])
-		regerror(Etoolong);
-	progp->type = t;
-	progp->left = 0;
-	progp->right = 0;
-	return progp++;
-}
-
-Inst *
-realcompile(Rune *s)
-{
-	int token;
-
-	startlex(s);
-	atorp = atorstack;
-	andp = andstack;
-	subidp = subidstack;
-	cursubid = 0;
-	lastwasand = FALSE;
-	/* Start with a low priority operator to prime parser */
-	pushator(START-1);
-	while((token=lex()) != END){
-		if((token&ISATOR) == OPERATOR)
-			operator(token);
-		else
-			operand(token);
-	}
-	/* Close with a low priority operator */
-	evaluntil(START);
-	/* Force END */
-	operand(END);
-	evaluntil(START);
-	if(nbra)
-		regerror(Eleftpar);
-	--andp;	/* points to first and only operand */
-	return andp->first;
-}
-
-void
-compile(String *s)
-{
-	int i;
-	Inst *oprogp;
-
-	if(Strcmp(s, &lastregexp)==0)
-		return;
-	for(i=0; i<nclass; i++)
-		free(class[i]);
-	nclass = 0;
-	progp = program;
-	backwards = FALSE;
-	startinst = realcompile(s->s);
-	optimize(program);
-	oprogp = progp;
-	backwards = TRUE;
-	bstartinst = realcompile(s->s);
-	optimize(oprogp);
-	Strduplstr(&lastregexp, s);
-}
-
-void
-operand(int t)
-{
-	Inst *i;
-	if(lastwasand)
-		operator(CAT);	/* catenate is implicit */
-	i = newinst(t);
-	if(t == CCLASS){
-		if(negateclass)
-			i->type = NCCLASS;	/* UGH */
-		i->rclass = nclass-1;		/* UGH */
-	}
-	pushand(i, i);
-	lastwasand = TRUE;
-}
-
-void
-operator(int t)
-{
-	if(t==RBRA && --nbra<0)
-		regerror(Erightpar);
-	if(t==LBRA){
-/*
- *		if(++cursubid >= NSUBEXP)
- *			regerror(Esubexp);
- */
-		cursubid++;	/* silently ignored */
-		nbra++;
-		if(lastwasand)
-			operator(CAT);
-	}else
-		evaluntil(t);
-	if(t!=RBRA)
-		pushator(t);
-	lastwasand = FALSE;
-	if(t==STAR || t==QUEST || t==PLUS || t==RBRA)
-		lastwasand = TRUE;	/* these look like operands */
-}
-
-void
-cant(char *s)
-{
-	char buf[100];
-
-	sprint(buf, "regexp: can't happen: %s", s);
-	panic(buf);
-}
-
-void
-pushand(Inst *f, Inst *l)
-{
-	if(andp >= &andstack[NSTACK])
-		cant("operand stack overflow");
-	andp->first = f;
-	andp->last = l;
-	andp++;
-}
-
-void
-pushator(int t)
-{
-	if(atorp >= &atorstack[NSTACK])
-		cant("operator stack overflow");
-	*atorp++=t;
-	if(cursubid >= NSUBEXP)
-		*subidp++= -1;
-	else
-		*subidp++=cursubid;
-}
-
-Node *
-popand(int op)
-{
-	if(andp <= &andstack[0])
-		if(op)
-			regerror_c(Emissop, op);
-		else
-			regerror(Ebadregexp);
-	return --andp;
-}
-
-int
-popator(void)
-{
-	if(atorp <= &atorstack[0])
-		cant("operator stack underflow");
-	--subidp;
-	return *--atorp;
-}
-
-void
-evaluntil(int pri)
-{
-	Node *op1, *op2, *t;
-	Inst *inst1, *inst2;
-
-	while(pri==RBRA || atorp[-1]>=pri){
-		switch(popator()){
-		case LBRA:
-			op1 = popand('(');
-			inst2 = newinst(RBRA);
-			inst2->subid = *subidp;
-			op1->last->next = inst2;
-			inst1 = newinst(LBRA);
-			inst1->subid = *subidp;
-			inst1->next = op1->first;
-			pushand(inst1, inst2);
-			return;		/* must have been RBRA */
-		default:
-			panic("unknown regexp operator");
-			break;
-		case OR:
-			op2 = popand('|');
-			op1 = popand('|');
-			inst2 = newinst(NOP);
-			op2->last->next = inst2;
-			op1->last->next = inst2;
-			inst1 = newinst(OR);
-			inst1->right = op1->first;
-			inst1->left = op2->first;
-			pushand(inst1, inst2);
-			break;
-		case CAT:
-			op2 = popand(0);
-			op1 = popand(0);
-			if(backwards && op2->first->type!=END)
-				t = op1, op1 = op2, op2 = t;
-			op1->last->next = op2->first;
-			pushand(op1->first, op2->last);
-			break;
-		case STAR:
-			op2 = popand('*');
-			inst1 = newinst(OR);
-			op2->last->next = inst1;
-			inst1->right = op2->first;
-			pushand(inst1, inst1);
-			break;
-		case PLUS:
-			op2 = popand('+');
-			inst1 = newinst(OR);
-			op2->last->next = inst1;
-			inst1->right = op2->first;
-			pushand(op2->first, inst1);
-			break;
-		case QUEST:
-			op2 = popand('?');
-			inst1 = newinst(OR);
-			inst2 = newinst(NOP);
-			inst1->left = inst2;
-			inst1->right = op2->first;
-			op2->last->next = inst2;
-			pushand(inst1, inst2);
-			break;
-		}
-	}
-}
-
-
-void
-optimize(Inst *start)
-{
-	Inst *inst, *target;
-
-	for(inst=start; inst->type!=END; inst++){
-		target = inst->next;
-		while(target->type == NOP)
-			target = target->next;
-		inst->next = target;
-	}
-}
-
-#ifdef	DEBUG
-void
-dumpstack(void){
-	Node *stk;
-	int *ip;
-
-	dprint("operators\n");
-	for(ip = atorstack; ip<atorp; ip++)
-		dprint("0%o\n", *ip);
-	dprint("operands\n");
-	for(stk = andstack; stk<andp; stk++)
-		dprint("0%o\t0%o\n", stk->first->type, stk->last->type);
-}
-void
-dump(void){
-	Inst *l;
-
-	l = program;
-	do{
-		dprint("%d:\t0%o\t%d\t%d\n", l-program, l->type,
-			l->left-program, l->right-program);
-	}while(l++->type);
-}
-#endif
-
-void
-startlex(Rune *s)
-{
-	exprp = s;
-	nbra = 0;
-}
-
-
-int
-lex(void){
-	int c= *exprp++;
-
-	switch(c){
-	case '\\':
-		if(*exprp)
-			if((c= *exprp++)=='n')
-				c='\n';
-		break;
-	case 0:
-		c = END;
-		--exprp;	/* In case we come here again */
-		break;
-	case '*':
-		c = STAR;
-		break;
-	case '?':
-		c = QUEST;
-		break;
-	case '+':
-		c = PLUS;
-		break;
-	case '|':
-		c = OR;
-		break;
-	case '.':
-		c = ANY;
-		break;
-	case '(':
-		c = LBRA;
-		break;
-	case ')':
-		c = RBRA;
-		break;
-	case '^':
-		c = BOL;
-		break;
-	case '$':
-		c = EOL;
-		break;
-	case '[':
-		c = CCLASS;
-		bldcclass();
-		break;
-	}
-	return c;
-}
-
-long
-nextrec(void){
-	if(exprp[0]==0 || (exprp[0]=='\\' && exprp[1]==0))
-		regerror(Ebadclass);
-	if(exprp[0] == '\\'){
-		exprp++;
-		if(*exprp=='n'){
-			exprp++;
-			return '\n';
-		}
-		return *exprp++|0x10000;
-	}
-	return *exprp++;
-}
-
-void
-bldcclass(void)
-{
-	long c1, c2, n, na;
-	Rune *classp;
-
-	classp = emalloc(DCLASS*RUNESIZE);
-	n = 0;
-	na = DCLASS;
-	/* we have already seen the '[' */
-	if(*exprp == '^'){
-		classp[n++] = '\n';	/* don't match newline in negate case */
-		negateclass = TRUE;
-		exprp++;
-	}else
-		negateclass = FALSE;
-	while((c1 = nextrec()) != ']'){
-		if(c1 == '-'){
-    Error:
-			free(classp);
-			regerror(Ebadclass);
-		}
-		if(n+4 >= na){		/* 3 runes plus NUL */
-			na += DCLASS;
-			classp = erealloc(classp, na*RUNESIZE);
-		}
-		if(*exprp == '-'){
-			exprp++;	/* eat '-' */
-			if((c2 = nextrec()) == ']')
-				goto Error;
-			classp[n+0] = 0xFFFF;
-			classp[n+1] = c1;
-			classp[n+2] = c2;
-			n += 3;
-		}else
-			classp[n++] = c1;
-	}
-	classp[n] = 0;
-	if(nclass == Nclass){
-		Nclass += DCLASS;
-		class = erealloc(class, Nclass*sizeof(Rune*));
-	}
-	class[nclass++] = classp;
-}
-
-int
-classmatch(int classno, int c, int negate)
-{
-	Rune *p;
-
-	p = class[classno];
-	while(*p){
-		if(*p == 0xFFFF){
-			if(p[1]<=c && c<=p[2])
-				return !negate;
-			p += 3;
-		}else if(*p++ == c)
-			return !negate;
-	}
-	return negate;
-}
-
-/*
- * Note optimization in addinst:
- * 	*l must be pending when addinst called; if *l has been looked
- *		at already, the optimization is a bug.
- */
-void
-addinst(Ilist *l, Inst *inst, Rangeset *sep)
-{
-	Ilist *p;
-
-	for(p = l; p->inst; p++){
-		if(p->inst==inst){
-			if((sep)->p[0].p1 < p->se.p[0].p1)
-				p->se= *sep;	/* this would be bug */
-			return;	/* It's already there */
-		}
-	}
-	p->inst = inst;
-	p->se= *sep;
-	(p+1)->inst = 0;
-}
-
-int
-execute(File *f, Posn startp, Posn eof)
-{
-	int flag = 0;
-	Inst *inst;
-	Ilist *tlp;
-	Posn p = startp;
-	int nnl = 0, ntl;
-	int c;
-	int wrapped = 0;
-	int startchar = startinst->type<OPERATOR? startinst->type : 0;
-
-	list[0][0].inst = list[1][0].inst = 0;
-	sel.p[0].p1 = -1;
-	Fgetcset(f, startp);
-	/* Execute machine once for each character */
-	for(;;p++){
-	doloop:
-		c = Fgetc(f);
-		if(p>=eof || c<0){
-			switch(wrapped++){
-			case 0:		/* let loop run one more click */
-			case 2:
-				break;
-			case 1:		/* expired; wrap to beginning */
-				if(sel.p[0].p1>=0 || eof!=INFINITY)
-					goto Return;
-				list[0][0].inst = list[1][0].inst = 0;
-				Fgetcset(f, (Posn)0);
-				p = 0;
-				goto doloop;
-			default:
-				goto Return;
-			}
-		}else if(((wrapped && p>=startp) || sel.p[0].p1>0) && nnl==0)
-			break;
-		/* fast check for first char */
-		if(startchar && nnl==0 && c!=startchar)
-			continue;
-		tl = list[flag];
-		nl = list[flag^=1];
-		nl->inst = 0;
-		ntl = nnl;
-		nnl = 0;
-		if(sel.p[0].p1<0 && (!wrapped || p<startp || startp==eof)){
-			/* Add first instruction to this list */
-			if(++ntl >= NLIST)
-	Overflow:
-				error(Eoverflow);
-			sempty.p[0].p1 = p;
-			addinst(tl, startinst, &sempty);
-		}
-		/* Execute machine until this list is empty */
-		for(tlp = tl; inst = tlp->inst; tlp++){	/* assignment = */
-	Switchstmt:
-			switch(inst->type){
-			default:	/* regular character */
-				if(inst->type==c){
-	Addinst:
-					if(++nnl >= NLIST)
-						goto Overflow;
-					addinst(nl, inst->next, &tlp->se);
-				}
-				break;
-			case LBRA:
-				if(inst->subid>=0)
-					tlp->se.p[inst->subid].p1 = p;
-				inst = inst->next;
-				goto Switchstmt;
-			case RBRA:
-				if(inst->subid>=0)
-					tlp->se.p[inst->subid].p2 = p;
-				inst = inst->next;
-				goto Switchstmt;
-			case ANY:
-				if(c!='\n')
-					goto Addinst;
-				break;
-			case BOL:
-				if(p == 0){
-	Step:
-					inst = inst->next;
-					goto Switchstmt;
-				}
-				if(f->getci > 1){
-					if(f->getcbuf[f->getci-2]=='\n')
-						goto Step;
-				}else{
-					Rune c;
-					if(Fchars(f, &c, p-1, p)==1 && c=='\n')
-						goto Step;
-				}
-				break;
-			case EOL:
-				if(c == '\n')
-					goto Step;
-				break;
-			case CCLASS:
-				if(c>=0 && classmatch(inst->rclass, c, 0))
-					goto Addinst;
-				break;
-			case NCCLASS:
-				if(c>=0 && classmatch(inst->rclass, c, 1))
-					goto Addinst;
-				break;
-			case OR:
-				/* evaluate right choice later */
-				if(++ntl >= NLIST)
-					goto Overflow;
-				addinst(tlp, inst->right, &tlp->se);
-				/* efficiency: advance and re-evaluate */
-				inst = inst->left;
-				goto Switchstmt;
-			case END:	/* Match! */
-				tlp->se.p[0].p2 = p;
-				newmatch(&tlp->se);
-				break;
-			}
-		}
-	}
-    Return:
-	return sel.p[0].p1>=0;
-}
-
-void
-newmatch(Rangeset *sp)
-{
-	int i;
-
-	if(sel.p[0].p1<0 || sp->p[0].p1<sel.p[0].p1 ||
-	   (sp->p[0].p1==sel.p[0].p1 && sp->p[0].p2>sel.p[0].p2))
-		for(i = 0; i<NSUBEXP; i++)
-			sel.p[i] = sp->p[i];
-}
-
-int
-bexecute(File *f, Posn startp)
-{
-	int flag = 0;
-	Inst *inst;
-	Ilist *tlp;
-	Posn p = startp;
-	int nnl = 0, ntl;
-	int c;
-	int wrapped = 0;
-	int startchar = bstartinst->type<OPERATOR? bstartinst->type : 0;
-
-	list[0][0].inst = list[1][0].inst = 0;
-	sel.p[0].p1= -1;
-	Fgetcset(f, startp);
-	/* Execute machine once for each character, including terminal NUL */
-	for(;;--p){
-	doloop:
-		if((c = Fbgetc(f))==-1){
-			switch(wrapped++){
-			case 0:		/* let loop run one more click */
-			case 2:
-				break;
-			case 1:		/* expired; wrap to end */
-				if(sel.p[0].p1>=0)
-			case 3:
-					goto Return;
-				list[0][0].inst = list[1][0].inst = 0;
-				Fgetcset(f, f->nrunes);
-				p = f->nrunes;
-				goto doloop;
-			default:
-				goto Return;
-			}
-		}else if(((wrapped && p<=startp) || sel.p[0].p1>0) && nnl==0)
-			break;
-		/* fast check for first char */
-		if(startchar && nnl==0 && c!=startchar)
-			continue;
-		tl = list[flag];
-		nl = list[flag^=1];
-		nl->inst = 0;
-		ntl = nnl;
-		nnl = 0;
-		if(sel.p[0].p1<0 && (!wrapped || p>startp)){
-			/* Add first instruction to this list */
-			if(++ntl >= NLIST)
-	Overflow:
-				error(Eoverflow);
-			/* the minus is so the optimizations in addinst work */
-			sempty.p[0].p1 = -p;
-			addinst(tl, bstartinst, &sempty);
-		}
-		/* Execute machine until this list is empty */
-		for(tlp = tl; inst = tlp->inst; tlp++){	/* assignment = */
-	Switchstmt:
-			switch(inst->type){
-			default:	/* regular character */
-				if(inst->type == c){
-	Addinst:
-					if(++nnl >= NLIST)
-						goto Overflow;
-					addinst(nl, inst->next, &tlp->se);
-				}
-				break;
-			case LBRA:
-				if(inst->subid>=0)
-					tlp->se.p[inst->subid].p1 = p;
-				inst = inst->next;
-				goto Switchstmt;
-			case RBRA:
-				if(inst->subid >= 0)
-					tlp->se.p[inst->subid].p2 = p;
-				inst = inst->next;
-				goto Switchstmt;
-			case ANY:
-				if(c != '\n')
-					goto Addinst;
-				break;
-			case BOL:
-				if(c=='\n' || p==0){
-	Step:
-					inst = inst->next;
-					goto Switchstmt;
-				}
-				break;
-			case EOL:
-				if(f->getci<f->ngetc-1){
-					if(f->getcbuf[f->getci+1]=='\n')
-						goto Step;
-				}else if(p<f->nrunes-1){
-					Rune c;
-					if(Fchars(f, &c, p, p+1)==1 && c=='\n')
-						goto Step;
-				}
-				break;
-			case CCLASS:
-				if(c>=0 && classmatch(inst->rclass, c, 0))
-					goto Addinst;
-				break;
-			case NCCLASS:
-				if(c>=0 && classmatch(inst->rclass, c, 1))
-					goto Addinst;
-				break;
-			case OR:
-				/* evaluate right choice later */
-				if(++ntl >= NLIST)
-					goto Overflow;
-				addinst(tlp, inst->right, &tlp->se);
-				/* efficiency: advance and re-evaluate */
-				inst = inst->left;
-				goto Switchstmt;
-			case END:	/* Match! */
-				tlp->se.p[0].p1 = -tlp->se.p[0].p1; /* minus sign */
-				tlp->se.p[0].p2 = p;
-				bnewmatch(&tlp->se);
-				break;
-			}
-		}
-	}
-    Return:
-	return sel.p[0].p1>=0;
-}
-
-void
-bnewmatch(Rangeset *sp)
-{
-        int  i;
-        if(sel.p[0].p1<0 || sp->p[0].p1>sel.p[0].p2 || (sp->p[0].p1==sel.p[0].p2 && sp->p[0].p2<sel.p[0].p1))
-                for(i = 0; i<NSUBEXP; i++){       /* note the reversal; p1<=p2 */
-                        sel.p[i].p1 = sp->p[i].p2;
-                        sel.p[i].p2 = sp->p[i].p1;
-                }
-}
//GO.SYSIN DD ./sam/regexp.c
echo ./sam/sam.c
sed s/.// > ./sam/sam.c <<'//GO.SYSIN DD ./sam/sam.c'
-#include "sam.h"
-
-Rune	genbuf[BLOCKSIZE];
-int	io;
-int	panicking;
-int	rescuing;
-Mod	modnum;
-String	genstr;
-String	rhs;
-String	wd;
-String	cmdstr;
-Rune	empty[] = { 0 };
-char	*genc;
-File	*curfile;
-File	*flist;
-File	*cmd;
-jmp_buf	mainloop;
-List tempfile;
-int	quitok = TRUE;
-int	downloaded;
-int	dflag;
-int	Rflag;
-char	*machine;
-char	*home;
-int	bpipeok;
-int	termlocked;
-char	*samterm = SAMTERM;
-char	*rsamname = RSAM;
-
-void	usage(void);
-
-void
-main(int argc, char *argv[])
-{
-	int i;
-	String *t;
-	char **ap, **arg;
-
-	arg = argv++;
-	ap = argv;
-	while(argc>1 && argv[0] && argv[0][0]=='-'){
-		switch(argv[0][1]){
-		case 'd':
-			dflag++;
-			break;
-
-		case 'r':
-			--argc, argv++;
-			if(argc == 1)
-				usage();
-			machine = *argv;
-			break;
-
-		case 'R':
-			Rflag++;
-			break;
-
-		case 't':
-			--argc, argv++;
-			if(argc == 1)
-				usage();
-			samterm = *argv;
-			break;
-
-		case 's':
-			--argc, argv++;
-			if(argc == 1)
-				usage();
-			rsamname = *argv;
-			break;
-
-		case 'g':	/* -geom -> pass to samterm */
-			*ap++ = *argv++;
-			*ap++ = *argv;
-			argc--;
-			break;
-
-		default:
-			dprint("sam: unknown flag %c\n", argv[1][1]);
-			exits("usage");
-		}
-		--argc, argv++;
-	}
-	Strinit(&cmdstr);
-	Strinit0(&lastpat);
-	Strinit0(&lastregexp);
-	Strinit0(&genstr);
-	Strinit0(&rhs);
-	Strinit0(&wd);
-	tempfile.listptr = emalloc(0);
-	Strinit0(&plan9cmd);
-	home = getenv(HOME);
-	if(home == 0)
-		home = "/";
-	if(!dflag)
-		startup(machine, Rflag, arg, ap);
-	Fstart();
-	notify(notifyf);
-	if(argc>1){
-		for(i=0; i<argc-1; i++)
-			if(!setjmp(mainloop)){
-				t = tmpcstr(argv[i]);
-				Straddc(t, '\0');
-				Strduplstr(&genstr, t);
-				freetmpstr(t);
-				Fsetname(newfile(), &genstr);
-			}
-	}else if(!downloaded)
-		newfile()->state = Clean;
-	modnum++;
-	if(file.nused)
-		current(file.filepptr[0]);
-	setjmp(mainloop);
-	cmdloop();
-	trytoquit();	/* if we already q'ed, quitok will be TRUE */
-	exits(0);
-}
-
-void
-usage(void)
-{
-	dprint("usage: sam [-d] [-t samterm] [-s sam name] -r machine\n");
-	exits("usage");
-}
-
-void
-rescue(void)
-{
-	int i, nblank = 0;
-	File *f;
-	char *c;
-	char buf[256];
-
-	if(rescuing++)
-		return;
-	io = -1;
-	for(i=0; i<file.nused; i++){
-		f = file.filepptr[i];
-		if(f==cmd || f->nrunes==0 || f->state!=Dirty)
-			continue;
-		if(io == -1){
-			sprint(buf, "%s/sam.save", home);
-			io = create(buf, 1, 0777);
-			if(io<0)
-				return;
-		}
-		if(f->name.s[0]){
-			c = Strtoc(&f->name);
-			strncpy(buf, c, sizeof buf-1);
-			buf[sizeof buf-1] = 0;
-			free(c);
-		}else
-			sprint(buf, "nameless.%d", nblank++);
-		fprint(io, "#!/bin/rc\n/sys/lib/samsave '%s' $* <<'---%s'\n", buf, buf);
-		addr.r.p1 = 0, addr.r.p2 = f->nrunes;
-		writeio(f);
-		fprint(io, "\n---%s\n", (char *)buf);
-	}
-}
-
-void
-panic(char *s)
-{
-	int wasd;
-
-	if(!panicking++ && !setjmp(mainloop)){
-		wasd = downloaded;
-		downloaded = 0;
-		dprint("sam: panic: %s\n", s);
-		if(wasd)
-			fprint(2, "sam: panic: %s\n", s);
-		rescue();
-		abort();
-	}
-}
-
-void
-hiccough(char *s)
-{
-	if(rescuing)
-		exits("rescue");
-	if(s)
-		dprint("%s\n", s);
-	resetcmd();
-	resetxec();
-	resetsys();
-	if(io > 0)
-		close(io);
-	if(undobuf->nrunes)
-		Bdelete(undobuf, (Posn)0, undobuf->nrunes);
-	update();
-	if(curfile && curfile->state==Unread)
-		curfile->state = Clean;
-	if(downloaded && curfile && curfile->state!=Unread)
-		outTs(Hcurrent, curfile->tag);
-	longjmp(mainloop, 1);
-}
-
-void
-intr(void)
-{
-	error(Eintr);
-}
-
-void
-trytoclose(File *f)
-{
-	char *t;
-
-	if(f == cmd)	/* possible? */
-		return;
-	if(f->state==Dirty && !f->closeok){
-		f->closeok = TRUE;
-		if(f->name.s[0]){
-			t = Strtoc(&f->name);
-			error_s(Emodified, t);
-			free(t);
-		}else
-			error_s(Emodified, "nameless file");
-	}
-	if(downloaded && f->rasp)
-		outTs(Hclose, f->tag);
-	delfile(f);
-	if(f == curfile)
-		current((File *)0);
-}
-
-void
-trytoquit(void)
-{
-	int c;
-	File *f;
-
-	if(!quitok)
-		for(c = 0; c<file.nused; c++){
-			f = file.filepptr[c];
-			if(f!=cmd && f->state==Dirty){
-				quitok = TRUE;
-				eof = FALSE;
-				error(Echanges);
-			}
-		}
-}
-
-void
-load(File *f)
-{
-	Address saveaddr;
-
-	Strduplstr(&genstr, &f->name);
-	filename(f);
-	if(f->name.s[0]){
-		saveaddr = addr;
-		edit(f, 'I');
-		addr = saveaddr;
-	}else
-		f->state = Clean;
-	Fupdate(f, TRUE, TRUE);
-}
-
-void
-cmdupdate(void)
-{
-	if(cmd && cmd->mod!=0){
-		Fupdate(cmd, FALSE, downloaded);
-		cmd->dot.r.p1 = cmd->dot.r.p2 = cmd->nrunes;
-		telldot(cmd);
-	}
-}
-
-void
-update(void)
-{
-	int i, anymod;
-	File *f;
-
-	settempfile();
-	for(anymod = i=0; i<tempfile.nused; i++){
-		f = tempfile.filepptr[i];
-		if(f==cmd)	/* cmd gets done in main() */
-			continue;
-		if(f->mod==modnum && Fupdate(f, FALSE, downloaded))
-			anymod++;
-		if(f->rasp)
-			telldot(f);
-	}
-	if(anymod)
-		modnum++;
-}
-
-File *
-current(File *f)
-{
-	return curfile = f;
-}
-
-void
-edit(File *f, int cmd)
-{
-	int empty = TRUE;
-	Posn p;
-	int nulls;
-
-	if(cmd == 'r')
-		Fdelete(f, addr.r.p1, addr.r.p2);
-	if(cmd=='e' || cmd=='I'){
-		Fdelete(f, (Posn)0, f->nrunes);
-		addr.r.p2 = f->nrunes;
-	}else if(f->nrunes!=0 || (f->name.s[0] && Strcmp(&genstr, &f->name)!=0))
-		empty = FALSE;
-	if((io = open(genc, OREAD))<0)
-		error_s(Eopen, genc);
-	p = readio(f, &nulls, empty);
-	closeio((cmd=='e' || cmd=='I')? -1 : p);
-	if(cmd == 'r')
-		f->ndot.r.p1 = addr.r.p2, f->ndot.r.p2 = addr.r.p2+p;
-	else
-		f->ndot.r.p1 = f->ndot.r.p2 = 0;
-	quitok = f->closeok = empty;
-	state(f, empty && !nulls? Clean : Dirty);
-	if(cmd == 'e')
-		filename(f);
-}
-
-int
-getname(File *f, String *s, int save)
-{
-	int c, i;
-
-	Strzero(&genstr);
-	if(genc){
-		free(genc);
-		genc = 0;
-	}
-	if(s==0 || (c = s->s[0])==0){		/* no name provided */
-		if(f)
-			Strduplstr(&genstr, &f->name);
-		else
-			Straddc(&genstr, '\0');
-		goto Return;
-	}
-	if(c!=' ' && c!='\t')
-		error(Eblank);
-	for(i=0; (c=s->s[i])==' ' || c=='\t'; i++)
-		;
-	while(s->s[i] > ' ')
-		Straddc(&genstr, s->s[i++]);
-	if(s->s[i])
-		error(Enewline);
-	Straddc(&genstr, '\0');
-	if(f && (save || f->name.s[0]==0)){
-		Fsetname(f, &genstr);
-		if(Strcmp(&f->name, &genstr)){
-			quitok = f->closeok = FALSE;
-			f->inumber = 0;
-			f->date = 0;
-			state(f, Dirty); /* if it's 'e', fix later */
-		}
-	}
-    Return:
-	genc = Strtoc(&genstr);
-	return genstr.n-1;	/* strlen(name) */
-}
-
-void
-filename(File *f)
-{
-	if(genc)
-		free(genc);
-	genc = Strtoc(&genstr);
-	dprint("%c%c%c %s\n", " '"[f->state==Dirty],
-		"-+"[f->rasp!=0], " ."[f==curfile], genc);
-}
-
-void
-undostep(File *f)
-{
-	Buffer *t;
-	int changes;
-	Mark mark;
-
-	t = f->transcript;
-	changes = Fupdate(f, TRUE, TRUE);
-	Bread(t, (Rune*)&mark, (sizeof mark)/RUNESIZE, f->markp);
-	Bdelete(t, f->markp, t->nrunes);
-	f->markp = mark.p;
-	f->dot.r = mark.dot;
-	f->ndot.r = mark.dot;
-	f->mark = mark.mark;
-	f->mod = mark.m;
-	f->closeok = mark.s1!=Dirty;
-	if(mark.s1==Dirty)
-		quitok = FALSE;
-	if(f->state==Clean && mark.s1==Clean && changes)
-		state(f, Dirty);
-	else
-		state(f, mark.s1);
-}
-
-void
-undo(void)
-{
-	File *f;
-	int i;
-	Mod max;
-
-	if((max = curfile->mod)==0)
-		return;
-	settempfile();
-	for(i = 0; i<tempfile.nused; i++){
-		f = tempfile.filepptr[i];
-		if(f!=cmd && f->mod==max)
-			undostep(f);
-	}
-}
-
-void
-readcmd(String *s)
-{
-	if(flist == 0)
-		(flist = Fopen())->state = Clean;
-	addr.r.p1 = 0, addr.r.p2 = flist->nrunes;
-	plan9(flist, '<', s, FALSE);
-	Fupdate(flist, FALSE, FALSE);
-	flist->mod = 0;
-	Strzero(&genstr);
-	Strinsure(&genstr, flist->nrunes);
-	Fchars(flist, genbuf, (Posn)0, flist->nrunes);
-	memmove(genstr.s, genbuf, flist->nrunes*RUNESIZE);
-	genstr.n = flist->nrunes;
-	Straddc(&genstr, '\0');
-}
-
-void
-cd(String *str)
-{
-	int i;
-	File *f;
-	String *t;
-
-	t = tmpcstr("/bin/pwd");
-	Straddc(t, '\0');
-	readcmd(t);
-	freetmpstr(t);
-	Strduplstr(&wd, &genstr);
-	if(wd.s[0] == 0){
-		wd.n = 0;
-		warn(Wpwd);
-	}else if(wd.s[wd.n-2] == '\n'){
-		--wd.n;
-		wd.s[wd.n-1]='/';
-	}
-	if(chdir(getname((File *)0, str, FALSE)? genc : home))
-		syserror("chdir");
-	settempfile();
-	for(i=0; i<tempfile.nused; i++){
-		f = tempfile.filepptr[i];
-		if(f!=cmd && f->name.s[0]!='/' && f->name.s[0]!=0){
-			Strinsert(&f->name, &wd, (Posn)0);
-			sortname(f);
-		}
-	}
-}
-
-int
-loadflist(String *s)
-{
-	int c, i;
-
-	c = s->s[0];
-	for(i = 0; s->s[i]==' ' || s->s[i]=='\t'; i++)
-		;
-	if((c==' ' || c=='\t') && s->s[i]!='\n'){
-		if(s->s[i]=='<'){
-			Strdelete(s, 0L, (long)i+1);
-			readcmd(s);
-		}else{
-			Strzero(&genstr);
-			while((c = s->s[i++]) && c!='\n')
-				Straddc(&genstr, c);
-			Straddc(&genstr, '\0');
-		}
-	}else{
-		if(c != '\n')
-			error(Eblank);
-		Strdupl(&genstr, empty);
-	}
-	if(genc)
-		free(genc);
-	genc = Strtoc(&genstr);
-	return genstr.s[0];
-}
-
-File *
-readflist(int readall, int delete)
-{
-	Posn i;
-	int c;
-	File *f;
-	String *t;
-
-	for(i=0,f=0; f==0 || readall || delete; i++){	/* ++ skips blank */
-		Strdelete(&genstr, (Posn)0, i);
-		for(i=0; (c = genstr.s[i])==' ' || c=='\t' || c=='\n'; i++)
-			;
-		if(i >= genstr.n)
-			break;
-		Strdelete(&genstr, (Posn)0, i);
-		for(i=0; (c=genstr.s[i]) && c!=' ' && c!='\t' && c!='\n'; i++)
-			;
-
-		if(i == 0)
-			break;
-		genstr.s[i] = 0;
-		t = tmprstr(genstr.s, i+1);
-		f = lookfile(t);
-		if(delete){
-			if(f == 0)
-				warn_S(Wfile, t);
-			else
-				trytoclose(f);
-		}else if(f==0 && readall)
-			Fsetname(f = newfile(), t);
-	}
-	return f;
-}
-
-File *
-tofile(String *s)
-{
-	File *f;
-
-	if(s->s[0] != ' ')
-		error(Eblank);
-	if(loadflist(s) == 0){
-		f = lookfile(&genstr);	/* empty string ==> nameless file */
-		if(f == 0)
-			error_s(Emenu, genc);
-	}else if((f=readflist(FALSE, FALSE)) == 0)
-		error_s(Emenu, genc);
-	return current(f);
-}
-
-File *
-getfile(String *s)
-{
-	File *f;
-
-	if(loadflist(s) == 0)
-		Fsetname(f = newfile(), &genstr);
-	else if((f=readflist(TRUE, FALSE)) == 0)
-		error(Eblank);
-	return current(f);
-}
-
-void
-closefiles(File *f, String *s)
-{
-	if(s->s[0] == 0){
-		if(f == 0)
-			error(Enofile);
-		trytoclose(f);
-		return;
-	}
-	if(s->s[0] != ' ')
-		error(Eblank);
-	if(loadflist(s) == 0)
-		error(Enewline);
-	readflist(FALSE, TRUE);
-}
-
-void
-copy(File *f, Address addr2)
-{
-	Posn p;
-	int ni;
-	for(p=addr.r.p1; p<addr.r.p2; p+=ni){
-		ni = addr.r.p2-p;
-		if(ni > BLOCKSIZE)
-			ni = BLOCKSIZE;
-		Fchars(f, genbuf, p, p+ni);
-		Finsert(addr2.f, tmprstr(genbuf, ni), addr2.r.p2);
-	}
-	addr2.f->ndot.r.p2 = addr2.r.p2+(f->dot.r.p2-f->dot.r.p1);
-	addr2.f->ndot.r.p1 = addr2.r.p2;
-}
-
-void
-move(File *f, Address addr2)
-{
-	if(addr.r.p2 <= addr2.r.p2){
-		Fdelete(f, addr.r.p1, addr.r.p2);
-		copy(f, addr2);
-	}else if(addr.r.p1 >= addr2.r.p2){
-		copy(f, addr2);
-		Fdelete(f, addr.r.p1, addr.r.p2);
-	}else
-		error(Eoverlap);
-}
-
-Posn
-nlcount(File *f, Posn p0, Posn p1)
-{
-	Posn nl = 0;
-
-	Fgetcset(f, p0);
-	while(p0++<p1)
-		if(Fgetc(f)=='\n')
-			nl++;
-	return nl;
-}
-
-void
-printposn(File *f, int charsonly)
-{
-	Posn l1, l2;
-
-	if(!charsonly){
-		l1 = 1+nlcount(f, (Posn)0, addr.r.p1);
-		l2 = l1+nlcount(f, addr.r.p1, addr.r.p2);
-		/* check if addr ends with '\n' */
-		if(addr.r.p2>0 && addr.r.p2>addr.r.p1 && (Fgetcset(f, addr.r.p2-1),Fgetc(f)=='\n'))
-			--l2;
-		dprint("%lu", l1);
-		if(l2 != l1)
-			dprint(",%lu", l2);
-		dprint("; ");
-	}
-	dprint("#%lu", addr.r.p1);
-	if(addr.r.p2 != addr.r.p1)
-		dprint(",#%lu", addr.r.p2);
-	dprint("\n");
-}
-
-void
-settempfile(void)
-{
-	if(tempfile.nalloc < file.nused){
-		free(tempfile.listptr);
-		tempfile.listptr = emalloc(sizeof(*tempfile.filepptr)*file.nused);
-		tempfile.nalloc = file.nused;
-	}
-	tempfile.nused = file.nused;
-	memmove(&tempfile.filepptr[0], &file.filepptr[0], file.nused*sizeof(File*));
-}
//GO.SYSIN DD ./sam/sam.c
echo ./sam/sam.h
sed s/.// > ./sam/sam.h <<'//GO.SYSIN DD ./sam/sam.h'
-#include <u.h>
-#include "errors.h"
-
-/*
- * BLOCKSIZE is relatively small to keep memory consumption down.
- */
-
-#define	BLOCKSIZE	2048
-#define	RUNESIZE	sizeof(Rune)
-#define	NDISC		5
-#define	NBUFFILES	3+2*NDISC	/* plan 9+undo+snarf+NDISC*(transcript+buf) */
-#define NSUBEXP	10
-
-#define	TRUE		1
-#define	FALSE		0
-
-#define	INFINITY	0x7FFFFFFFL
-#define	INCR		25
-#define	STRSIZE		(2*BLOCKSIZE)
-
-typedef long		Posn;		/* file position or address */
-typedef	ushort		Mod;		/* modification number */
-
-typedef struct Address	Address;
-typedef struct Block	Block;
-typedef struct Buffer	Buffer;
-typedef struct Disc	Disc;
-typedef struct Discdesc	Discdesc;
-typedef struct File	File;
-typedef struct List	List;
-typedef struct Mark	Mark;
-typedef struct Range	Range;
-typedef struct Rangeset	Rangeset;
-typedef struct String	String;
-
-enum State
-{
-	Clean =		' ',
-	Dirty =		'\'',
-	Unread =	'-'
-};
-
-struct Range
-{
-	Posn	p1, p2;
-};
-
-struct Rangeset
-{
-	Range	p[NSUBEXP];
-};
-
-struct Address
-{
-	Range	r;
-	File	*f;
-};
-
-struct List	/* code depends on a long being able to hold a pointer */
-{
-	int	nalloc;
-	int	nused;
-	union{
-		void	*listp;
-		Block	*blkp;
-		long	*longp;
-		uchar*	*ucharp;
-		String*	*stringp;
-		File*	*filep;
-		long	listv;
-	}g;
-};
-
-#define	listptr		g.listp
-#define	blkptr		g.blkp
-#define	longptr		g.longp
-#define	ucharpptr	g.ucharp
-#define	stringpptr	g.stringp
-#define	filepptr	g.filep
-#define	listval		g.listv
-
-/*
- * Block must fit in a long because the list routines manage arrays of
- * blocks.  Two problems: some machines (e.g. Cray) can't pull this off
- * -- on them, use bitfields -- and the ushort bnum limits temp file sizes
- * to about 200 megabytes.  Advantages: small, simple code and small
- * memory overhead.  If you really want to edit huge files, making BLOCKSIZE
- * bigger is the easiest way.
- */
-struct Block
-{
-	ushort	bnum;		/* absolute number on disk */
-	short	nrunes;		/* runes stored in this block */
-};
-
-struct Discdesc
-{
-	int	fd;		/* plan 9 file descriptor of temp file */
-	ulong	nbk;		/* high water mark */
-	List	free;		/* array of free block indices */
-};
-
-struct Disc
-{
-	Discdesc *desc;		/* descriptor of temp file */
-	Posn	nrunes;		/* runes on disc file */
-	List	block;		/* list of used block indices */
-};
-
-struct String
-{
-	short	n;
-	short	size;
-	Rune	*s;
-};
-
-struct Buffer
-{
-	Disc	*disc;		/* disc storage */
-	Posn	nrunes;		/* total length of buffer */
-	String	cache;		/* in-core storage for efficiency */
-	Posn	c1, c2;		/* cache start and end positions in disc */
-				/* note: if dirty, cache is really c1, c1+cache.n */
-	int	dirty;		/* cache dirty */
-};
-
-#define	NGETC	128
-
-struct File
-{
-	Buffer	*buf;		/* cached disc storage */
-	Buffer	*transcript;	/* what's been done */
-	Posn	markp;		/* file pointer to start of latest change */
-	Mod	mod;		/* modification stamp */
-	Posn	nrunes;		/* total length of file */
-	Posn	hiposn;		/* highest address touched this Mod */
-	Address	dot;		/* current position */
-	Address	ndot;		/* new current position after update */
-	Range	tdot;		/* what terminal thinks is current range */
-	Range	mark;		/* tagged spot in text (don't confuse with Mark) */
-	List	*rasp;		/* map of what terminal's got */
-	String	name;		/* file name */
-	short	tag;		/* for communicating with terminal */
-	char	state;		/* Clean, Dirty, Unread */
-	char	closeok;	/* ok to close file? */
-	char	marked;		/* file has been Fmarked at least once; once
-				 * set, this will never go off as undo doesn't
-				 * revert to the dawn of time */
-	long	inumber;	/* file from which it was read */
-	long	date;		/* time stamp of plan9 file */
-	Posn	cp1, cp2;	/* Write-behind cache positions and */
-	String	cache;		/* string */
-	Rune	getcbuf[NGETC];
-	int	ngetc;
-	int	getci;
-	Posn	getcp;
-};
-
-struct Mark
-{
-	Posn	p;
-	Range	dot;
-	Range	mark;
-	Mod	m;
-	short	s1;
-};
-
-/*
- * The precedent to any message in the transcript.
- * The component structures must be an integral number of Runes long.
- */
-union Hdr
-{
-	struct _csl
-	{
-		short	c;
-		short	s;
-		long	l;
-	}csl;
-	struct _cs
-	{
-		short	c;
-		short	s;
-	}cs;
-	struct _cll
-	{
-		short	c;
-		long	l;
-		long	l1;
-	}cll;
-	Mark	mark;
-};
-
-#define	Fgetc(f)  ((--(f)->ngetc<0)? Fgetcload(f, (f)->getcp) : (f)->getcbuf[(f)->getcp++, (f)->getci++])
-#define	Fbgetc(f) (((f)->getci<=0)? Fbgetcload(f, (f)->getcp) : (f)->getcbuf[--(f)->getcp, --(f)->getci])
-
-int	alnum(int);
-void	Bclean(Buffer*);
-void	Bclose(Buffer*);
-void	Bdelete(Buffer*, Posn, Posn);
-void	Bflush(Buffer*);
-void	Binsert(Buffer*, String*, Posn);
-Buffer	*Bopen(Discdesc*);
-int	Bread(Buffer*, Rune*, int, Posn);
-void	Dclose(Disc*);
-void	Ddelete(Disc*, Posn, Posn);
-void	Dinsert(Disc*, Rune*, int, Posn);
-Disc	*Dopen(Discdesc*);
-int	Dread(Disc*, Rune*, int, Posn);
-void	Dreplace(Disc *, Posn, Posn, Rune*, int);
-int	Fbgetcload(File*, Posn);
-int	Fbgetcset(File*, Posn);
-long	Fchars(File*, Rune*, Posn, Posn);
-void	Fclose(File*);
-void	Fdelete(File*, Posn, Posn);
-int	Fgetcload(File*, Posn);
-int	Fgetcset(File*, Posn);
-void	Finsert(File*, String*, Posn);
-File	*Fopen(void);
-void	Fsetname(File*, String*);
-void	Fstart(void);
-int	Fupdate(File*, int, int);
-int	Read(int, void*, int);
-void	Seek(int, long, int);
-void	plan9(File*, int, String*, int);
-int	Write(int, void*, int);
-int	bexecute(File*, Posn);
-void	cd(String*);
-void	closefiles(File*, String*);
-void	closeio(Posn);
-void	cmdloop(void);
-void	cmdupdate(void);
-void	compile(String*);
-void	copy(File*, Address);
-File	*current(File*);
-void	delfile(File*);
-void	dellist(List*, int);
-void	doubleclick(File*, Posn);
-void	dprint(char*, ...);
-void	edit(File*, int);
-void	*emalloc(ulong);
-void	*erealloc(void*, ulong);
-void	error(Err);
-void	error_c(Err, int);
-void	error_s(Err, char*);
-int	execute(File*, Posn, Posn);
-int	filematch(File*, String*);
-void	filename(File*);
-File	*getfile(String*);
-int	getname(File*, String*, int);
-long	getnum(void);
-void	hiccough(char*);
-void	inslist(List*, int, long);
-Address	lineaddr(Posn, Address, int);
-void	listfree(List*);
-void	load(File*);
-File	*lookfile(String*);
-void	lookorigin(File*, Posn, Posn);
-int	lookup(int);
-void	move(File*, Address);
-void	moveto(File*, Range);
-File	*newfile(void);
-void	nextmatch(File*, String*, Posn, int);
-int	newtmp(int);
-void	notifyf(void*, char*);
-void	panic(char*);
-void	printposn(File*, int);
-int	rcv(void);
-Range	rdata(List*, Posn, Posn);
-Posn	readio(File*, int*, int);
-void	rescue(void);
-void	resetcmd(void);
-void	resetsys(void);
-void	resetxec(void);
-void	rgrow(List*, Posn, Posn);
-void	samerr(char *);
-void	settempfile(void);
-int	skipbl(void);
-void	snarf(File*, Posn, Posn, Buffer*, int);
-void	sortname(File*);
-void	startup(char*, int, char**, char**);
-void	state(File*, int);
-int	statfd(int, ulong *, long *, long *);
-int	statfile(char *, ulong *, long *, long *);
-void	Straddc(String*, int);
-void	Strclose(String*);
-int	Strcmp(String*, String*);
-void	Strdelete(String*, Posn, Posn);
-void	Strdupl(String*, Rune*);
-void	Strduplstr(String*, String*);
-void	Strinit(String*);
-void	Strinit0(String*);
-void	Strinsert(String*, String*, Posn);
-void	Strinsure(String*, ulong);
-void	Strzero(String*);
-int	Strlen(Rune*);
-char	*Strtoc(String*);
-void	syserror(char*);
-void	telldot(File*);
-void	tellpat(void);
-String	*tmpcstr(char*);
-String	*tmprstr(Rune*, int);
-void	freetmpstr(String*);
-void	termcommand(void);
-void	termwrite(char*);
-File	*tofile(String*);
-void	toterminal(File*, int);
-void	trytoclose(File*);
-void	trytoquit(void);
-void	undo(void);
-void	update(void);
-int	waitfor(int);
-void	warn(Warn);
-void	warn_s(Warn, char*);
-void	warn_S(Warn, String*);
-int	whichmenu(File*);
-void	writef(File*);
-Posn	writeio(File*);
-Discdesc *Dstart(void);
-
-extern Rune	samname[];	/* compiler dependent */
-extern Rune	*left[];
-extern Rune	*right[];
-
-extern char	RSAM[];		/* system dependent */
-extern char	SAMTERM[];
-extern char	HOME[];
-extern char	TMPDIR[];
-extern char	SH[];
-extern char	SHPATH[];
-extern char	RX[];
-extern char	RXPATH[];
-
-extern char	*rsamname;	/* globals */
-extern char	*samterm;
-extern Rune	genbuf[];
-extern char	*genc;
-extern int	io;
-extern int	patset;
-extern int	quitok;
-extern Address	addr;
-extern Buffer	*undobuf;
-extern Buffer	*snarfbuf;
-extern Buffer	*plan9buf;
-extern List	file;
-extern List	tempfile;
-extern File	*cmd;
-extern File	*curfile;
-extern Mod	modnum;
-extern Posn	cmdpt;
-extern Posn	cmdptadv;
-extern Rangeset	sel;
-extern String	cmdstr;
-extern String	genstr;
-extern String	lastpat;
-extern String	lastregexp;
-extern String	plan9cmd;
-extern int	downloaded;
-extern int	eof;
-extern int	bpipeok;
-extern int	panicking;
-extern Rune	empty[];
-extern int	termlocked;
-extern int	noflush;
-
-#include "mesg.h"
-
-void	outTs(Hmesg, int);
-void	outT0(Hmesg);
-void	outTl(Hmesg, long);
-void	outTslS(Hmesg, int, long, String*);
-void	outTS(Hmesg, String*);
-void	outTsS(Hmesg, int, String*);
-void	outTsllS(Hmesg, int, long, long, String*);
-void	outTsll(Hmesg, int, long, long);
-void	outTsl(Hmesg, int, long);
-void	outstart(Hmesg);
-void	outcopy(int, void*);
-void	outshort(int);
-void	outlong(long);
-void	outsend(void);
-void	outflush(void);
//GO.SYSIN DD ./sam/sam.h
echo ./sam/shell.c
sed s/.// > ./sam/shell.c <<'//GO.SYSIN DD ./sam/shell.c'
-#include "sam.h"
-#include "parse.h"
-
-extern	jmp_buf	mainloop;
-
-char	errfile[64];
-String	plan9cmd;	/* null terminated */
-Buffer	*plan9buf;
-void	checkerrs(void);
-
-void
-plan9(File *f, int type, String *s, int nest)
-{
-	long l;
-	int m;
-	int pid, fd;
-	int retcode;
-	int pipe1[2], pipe2[2];
-
-	if(s->s[0]==0 && plan9cmd.s[0]==0)
-		error(Enocmd);
-	else if(s->s[0])
-		Strduplstr(&plan9cmd, s);
-	if(downloaded)
-		samerr(errfile);
-	else
-		strcpy(errfile, "/dev/tty");
-	if(type!='!' && pipe(pipe1)==-1)
-		error(Epipe);
-	if(type=='|')
-		snarf(f, addr.r.p1, addr.r.p2, plan9buf, 1);
-	if(downloaded)
-		remove(errfile);
-	if((pid=fork()) == 0){
-		if(downloaded){	/* also put nasty fd's into errfile */
-			fd = create(errfile, 1, 0666L);
-			if(fd < 0)
-				fd = create("/dev/null", 1, 0666L);
-			dup(fd, 2);
-			close(fd);
-			/* 2 now points at err file */
-			if(type == '>')
-				dup(2, 1);
-			else if(type=='!'){
-				dup(2, 1);
-				fd = open("/dev/null", 0);
-				dup(fd, 0);
-				close(fd);
-			}
-		}
-		if(type != '!') {
-			if(type=='<' || type=='|')
-				dup(pipe1[1], 1);
-			else if(type == '>')
-				dup(pipe1[0], 0);
-			close(pipe1[0]);
-			close(pipe1[1]);
-		}
-		if(type == '|'){
-			if(pipe(pipe2) == -1)
-				exits("pipe");
-			if((pid = fork())==0){
-				/*
-				 * It's ok if we get SIGPIPE here
-				 */
-				close(pipe2[0]);
-				io = pipe2[1];
-				if(retcode=!setjmp(mainloop)){	/* assignment = */
-					char *c;
-					for(l = 0; l<plan9buf->nrunes; l+=m){
-						m = plan9buf->nrunes-l;
-						if(m>BLOCKSIZE-1)
-							m = BLOCKSIZE-1;
-						Bread(plan9buf, genbuf, m, l);
-						genbuf[m] = 0;
-						c = Strtoc(tmprstr(genbuf, m+1));
-						Write(pipe2[1], c, strlen(c));
-						free(c);
-					}
-				}
-				exits(retcode? "error" : 0);
-			}
-			if(pid==-1){
-				fprint(2, "Can't fork?!\n");
-				exits("fork");
-			}
-			dup(pipe2[0], 0);
-			close(pipe2[0]);
-			close(pipe2[1]);
-		}
-		if(type=='<'){
-			close(0);	/* so it won't read from terminal */
-			open("/dev/null", 0);
-		}
-		execl(SHPATH, SH, "-c", Strtoc(&plan9cmd), (char *)0);
-		exits("exec");
-	}
-	if(pid == -1)
-		error(Efork);
-	if(type=='<' || type=='|'){
-		int nulls;
-		if(downloaded)
-			outTl(Hsnarflen, addr.r.p2-addr.r.p1);
-		snarf(f, addr.r.p1, addr.r.p2, snarfbuf, 0);
-		Fdelete(f, addr.r.p1, addr.r.p2);
-		close(pipe1[1]);
-		io = pipe1[0];
-		f->tdot.p1 = -1;
-		f->ndot.r.p2 = addr.r.p2+readio(f, &nulls, 0);
-		f->ndot.r.p1 = addr.r.p2;
-		closeio((Posn)-1);
-	}else if(type=='>'){
-		close(pipe1[0]);
-		io = pipe1[1];
-		bpipeok = 1;
-		writeio(f);
-		bpipeok = 0;
-		closeio((Posn)-1);
-	}
-	retcode = waitfor(pid);
-	if(type=='|' || type=='<')
-		if(retcode!=0)
-			warn(Wbadstatus);
-	if(downloaded)
-		checkerrs();
-	if(!nest)
-		dprint("!\n");
-}
-
-void
-checkerrs(void)
-{
-	char buf[256];
-	int f, n, nl;
-	char *p;
-	long l;
-
-	if(statfile(errfile, 0, 0, &l) > 0 && l != 0){
-		if((f=open((char *)errfile, 0)) != -1){
-			if((n=read(f, buf, sizeof buf-1)) > 0){
-				for(nl=0,p=buf; nl<3 && p<&buf[n]; p++)
-					if(*p=='\n')
-						nl++;
-				*p = 0;
-				dprint("%s", buf);
-				if(p-buf < l-1)
-					dprint("(sam: more in %s)\n", errfile);
-			}
-			close(f);
-		}
-	}else
-		remove((char *)errfile);
-}
//GO.SYSIN DD ./sam/shell.c
echo ./sam/string.c
sed s/.// > ./sam/string.c <<'//GO.SYSIN DD ./sam/string.c'
-#include "sam.h"
-
-#define	MINSIZE	16		/* minimum number of chars allocated */
-#define	MAXSIZE	256		/* maximum number of chars for an empty string */
-
-
-void
-Strinit(String *p)
-{
-	p->s = emalloc(MINSIZE*RUNESIZE);
-	p->n = 0;
-	p->size = MINSIZE;
-}
-
-void
-Strinit0(String *p)
-{
-	p->s = emalloc(MINSIZE*RUNESIZE);
-	p->s[0] = 0;
-	p->n = 1;
-	p->size = MINSIZE;
-}
-
-void
-Strclose(String *p)
-{
-	free(p->s);
-}
-
-void
-Strzero(String *p)
-{
-	if(p->size > MAXSIZE){
-		p->s = erealloc(p->s, RUNESIZE*MAXSIZE); /* throw away the garbage */
-		p->size = MAXSIZE;
-	}
-	p->n = 0;
-}
-
-int
-Strlen(Rune *r)
-{
-	Rune *s;
-
-	for(s=r; *s; s++)
-		;
-	return s-r;
-}
-
-void
-Strdupl(String *p, Rune *s)	/* copies the null */
-{
-	p->n = Strlen(s)+1;
-	Strinsure(p, p->n);
-	memmove(p->s, s, p->n*RUNESIZE);
-}
-
-void
-Strduplstr(String *p, String *q)	/* will copy the null if there's one there */
-{
-	Strinsure(p, q->n);
-	p->n = q->n;
-	memmove(p->s, q->s, q->n*RUNESIZE);
-}
-
-void
-Straddc(String *p, int c)
-{
-	Strinsure(p, p->n+1);
-	p->s[p->n++] = c;
-}
-
-void
-Strinsure(String *p, ulong n)
-{
-	if(n > STRSIZE)
-		error(Etoolong);
-	if(p->size < n){	/* p needs to grow */
-		n += 100;
-		p->s = erealloc(p->s, n*RUNESIZE);
-		p->size = n;
-	}
-}
-
-void
-Strinsert(String *p, String *q, Posn p0)
-{
-	Strinsure(p, p->n+q->n);
-	memmove(p->s+p0+q->n, p->s+p0, (p->n-p0)*RUNESIZE);
-	memmove(p->s+p0, q->s, q->n*RUNESIZE);
-	p->n += q->n;
-}
-
-void
-Strdelete(String *p, Posn p1, Posn p2)
-{
-	memmove(p->s+p1, p->s+p2, (p->n-p2)*RUNESIZE);
-	p->n -= p2-p1;
-}
-
-int
-Strcmp(String *a, String *b)
-{
-	int i, c;
-
-	for(i=0; i<a->n && i<b->n; i++)
-		if(c = (a->s[i] - b->s[i]))	/* assign = */
-			return c;
-	/* damn NULs confuse everything */
-	i = a->n - b->n;
-	if(i == 1){
-		if(a->s[a->n-1] == 0)
-			return 0;
-	}else if(i == -1){
-		if(b->s[b->n-1] == 0)
-			return 0;
-	}
-	return i;
-}
-
-char*
-Strtoc(String *s)
-{
-	int i;
-	char *c, *d;
-	Rune *r;
-
-	c = emalloc(s->n*UTFmax + 1);  /* worst case UTFmax bytes per rune, plus NUL */
-	d = c;
-	r = s->s;
-	for(i=0; i<s->n; i++)
-		d += runetochar(d, r++);
-	if(d==c || d[-1]!=0)
-		*d = 0;
-	return c;
-
-}
-
-/*
- * Build very temporary String from Rune*
- */
-String*
-tmprstr(Rune *r, int n)
-{
-	static String p;
-
-	p.s = r;
-	p.n = n;
-	p.size = n;
-	return &p;
-}
-
-/*
- * Convert null-terminated char* into String
- */
-String*
-tmpcstr(char *s)
-{
-	String *p;
-	Rune *r;
-	int i, n;
-
-	n = utflen(s);	/* don't include NUL */
-	p = emalloc(sizeof(String));
-	r = emalloc(n*RUNESIZE);
-	p->s = r;
-	for(i=0; i<n; i++,r++)
-		s += chartorune(r, s);
-	p->n = n;
-	p->size = n;
-	return p;
-}
-
-void
-freetmpstr(String *s)
-{
-	free(s->s);
-	free(s);
-}
//GO.SYSIN DD ./sam/string.c
echo ./sam/sys.c
sed s/.// > ./sam/sys.c <<'//GO.SYSIN DD ./sam/sys.c'
-#include "sam.h"
-
-static int inerror=FALSE;
-
-/*
- * A reasonable interface to the system calls
- */
-
-void
-resetsys(void)
-{
-	inerror = FALSE;
-}
-
-void
-syserror(char *a)
-{
-	char buf[ERRLEN];
-
-	if(!inerror){
-		inerror=TRUE;
-		errstr(buf);
-		dprint("%s: ", a);
-		error_s(Eio, buf);
-	}
-}
-
-int
-Read(int f, void *a, int n)
-{
-	if(read(f, (char *)a, n)!=n)
-		syserror("read");
-	return n;
-}
-
-int
-Write(int f, void *a, int n)
-{
-	int m;
-
-	if((m=write(f, (char *)a, n))!=n)
-		syserror("write");
-	return m;
-}
-
-void
-Seek(int f, long n, int w)
-{
-	if(seek(f, n, w)==-1)
-		syserror("seek");
-}
//GO.SYSIN DD ./sam/sys.c
echo ./sam/xec.c
sed s/.// > ./sam/xec.c <<'//GO.SYSIN DD ./sam/xec.c'
-#include "sam.h"
-#include "parse.h"
-
-int	Glooping;
-int	nest;
-
-int	append(File*, Cmd*, Posn);
-int	display(File*);
-void	looper(File*, Cmd*, int);
-void	filelooper(Cmd*, int);
-void	linelooper(File*, Cmd*);
-
-void
-resetxec(void)
-{
-	Glooping = nest = 0;
-}
-
-int
-cmdexec(File *f, Cmd *cp)
-{
-	int i;
-	Addr *ap;
-	Address a;
-
-	if(f && f->state==Unread)
-		load(f);
-	if(f==0 && (cp->addr==0 || cp->addr->type!='"') &&
-	    !utfrune("bBnqUXY!{", cp->cmdc) &&
-	    cp->cmdc!=('c'|0x100) && !(cp->cmdc=='D' && cp->ctext))
-		error(Enofile);
-	i = lookup(cp->cmdc);
-	if(cmdtab[i].defaddr != aNo){
-		if((ap=cp->addr)==0 && cp->cmdc!='\n'){
-			cp->addr = ap = newaddr();
-			ap->type = '.';
-			if(cmdtab[i].defaddr == aAll)
-				ap->type = '*';
-		}else if(ap && ap->type=='"' && ap->next==0 && cp->cmdc!='\n'){
-			ap->next = newaddr();
-			ap->next->type = '.';
-			if(cmdtab[i].defaddr == aAll)
-				ap->next->type = '*';
-		}
-		if(cp->addr){	/* may be false for '\n' (only) */
-			static Address none = {0,0,0};
-			if(f)
-				addr = address(ap, f->dot, 0);
-			else	/* a " */
-				addr = address(ap, none, 0);
-			f = addr.f;
-		}
-	}
-	current(f);
-	switch(cp->cmdc){
-	case '{':
-		a = cp->addr? address(cp->addr, f->dot, 0): f->dot;
-		for(cp = cp->ccmd; cp; cp = cp->next){
-			a.f->dot = a;
-			cmdexec(a.f, cp);
-		}
-		break;
-	default:
-		i=(*cmdtab[i].fn)(f, cp);
-		return i;
-	}
-	return 1;
-}
-
-
-int
-a_cmd(File *f, Cmd *cp)
-{
-	return append(f, cp, addr.r.p2);
-}
-
-int
-b_cmd(File *f, Cmd *cp)
-{
-	USED(f);
-	f = cp->cmdc=='b'? tofile(cp->ctext) : getfile(cp->ctext);
-	if(f->state == Unread)
-		load(f);
-	else if(nest == 0)
-		filename(f);
-	return TRUE;
-}
-
-int
-c_cmd(File *f, Cmd *cp)
-{
-	Fdelete(f, addr.r.p1, addr.r.p2);
-	f->ndot.r.p1 = f->ndot.r.p2 = addr.r.p2;
-	return append(f, cp, addr.r.p2);
-}
-
-int
-d_cmd(File *f, Cmd *cp)
-{
-	USED(cp);
-	Fdelete(f, addr.r.p1, addr.r.p2);
-	f->ndot.r.p1 = f->ndot.r.p2 = addr.r.p1;
-	return TRUE;
-}
-
-int
-D_cmd(File *f, Cmd *cp)
-{
-	closefiles(f, cp->ctext);
-	return TRUE;
-}
-
-int
-e_cmd(File *f, Cmd *cp)
-{
-	if(getname(f, cp->ctext, cp->cmdc=='e')==0)
-		error(Enoname);
-	edit(f, cp->cmdc);
-	return TRUE;
-}
-
-int
-f_cmd(File *f, Cmd *cp)
-{
-	getname(f, cp->ctext, TRUE);
-	filename(f);
-	return TRUE;
-}
-
-int
-g_cmd(File *f, Cmd *cp)
-{
-	if(f!=addr.f)panic("g_cmd f!=addr.f");
-	compile(cp->re);
-	if(execute(f, addr.r.p1, addr.r.p2) ^ cp->cmdc=='v'){
-		f->dot = addr;
-		return cmdexec(f, cp->ccmd);
-	}
-	return TRUE;
-}
-
-int
-i_cmd(File *f, Cmd *cp)
-{
-	return append(f, cp, addr.r.p1);
-}
-
-int
-k_cmd(File *f, Cmd *cp)
-{
-	USED(cp);
-	f->mark = addr.r;
-	return TRUE;
-}
-
-int
-m_cmd(File *f, Cmd *cp)
-{
-	Address addr2;
-
-	addr2 = address(cp->caddr, f->dot, 0);
-	if(cp->cmdc=='m')
-		move(f, addr2);
-	else
-		copy(f, addr2);
-	return TRUE;
-}
-
-int
-n_cmd(File *f, Cmd *cp)
-{
-	int i;
-	USED(f);
-	USED(cp);
-	for(i = 0; i<file.nused; i++){
-		if(file.filepptr[i] == cmd)
-			continue;
-		f = file.filepptr[i];
-		Strduplstr(&genstr, &f->name);
-		filename(f);
-	}
-	return TRUE;
-}
-
-int
-p_cmd(File *f, Cmd *cp)
-{
-	USED(cp);
-	return display(f);
-}
-
-int
-q_cmd(File *f, Cmd *cp)
-{
-	USED(cp);
-	USED(f);
-	trytoquit();
-	if(downloaded){
-		outT0(Hexit);
-		return TRUE;
-	}
-	return FALSE;
-}
-
-int
-s_cmd(File *f, Cmd *cp)
-{
-	int i, j, c, n;
-	Posn p1, op, didsub = 0, delta = 0;
-
-	n = cp->num;
-	op= -1;
-	compile(cp->re);
-	for(p1 = addr.r.p1; p1<=addr.r.p2 && execute(f, p1, addr.r.p2); ){
-		if(sel.p[0].p1==sel.p[0].p2){	/* empty match? */
-			if(sel.p[0].p1==op){
-				p1++;
-				continue;
-			}
-			p1 = sel.p[0].p2+1;
-		}else
-			p1 = sel.p[0].p2;
-		op = sel.p[0].p2;
-		if(--n>0)
-			continue;
-		Strzero(&genstr);
-		for(i = 0; i<cp->ctext->n; i++)
-			if((c = cp->ctext->s[i])=='\\' && i<cp->ctext->n-1){
-				c = cp->ctext->s[++i];
-				if('1'<=c && c<='9') {
-					j = c-'0';
-					if(sel.p[j].p2-sel.p[j].p1>BLOCKSIZE)
-						error(Elongtag);
-					Fchars(f, genbuf, sel.p[j].p1, sel.p[j].p2);
-					Strinsert(&genstr, tmprstr(genbuf, (sel.p[j].p2-sel.p[j].p1)), genstr.n);
-				}else
-				 	Straddc(&genstr, c);
-			}else if(c!='&')
-				Straddc(&genstr, c);
-			else{
-				if(sel.p[0].p2-sel.p[0].p1>BLOCKSIZE)
-					error(Elongrhs);
-				Fchars(f, genbuf, sel.p[0].p1, sel.p[0].p2);
-				Strinsert(&genstr,
-					tmprstr(genbuf, (int)(sel.p[0].p2-sel.p[0].p1)),
-					genstr.n);
-			}
-		if(sel.p[0].p1!=sel.p[0].p2){
-			Fdelete(f, sel.p[0].p1, sel.p[0].p2);
-			delta-=sel.p[0].p2-sel.p[0].p1;
-		}
-		if(genstr.n){
-			Finsert(f, &genstr, sel.p[0].p2);
-			delta+=genstr.n;
-		}
-		didsub = 1;
-		if(!cp->flag)
-			break;
-	}
-	if(!didsub && nest==0)
-		error(Enosub);
-	f->ndot.r.p1 = addr.r.p1, f->ndot.r.p2 = addr.r.p2+delta;
-	return TRUE;
-}
-
-int
-u_cmd(File *f, Cmd *cp)
-{
-	int n;
-	USED(f);
-	USED(cp);
-	n = cp->num;
-	while(n--)
-		undo();
-	return TRUE;
-}
-
-int
-w_cmd(File *f, Cmd *cp)
-{
-	if(getname(f, cp->ctext, FALSE)==0)
-		error(Enoname);
-	writef(f);
-	return TRUE;
-}
-
-int
-x_cmd(File *f, Cmd *cp)
-{
-	if(cp->re)
-		looper(f, cp, cp->cmdc=='x');
-	else
-		linelooper(f, cp);
-	return TRUE;
-}
-
-int
-X_cmd(File *f, Cmd *cp)
-{
-	USED(f);
-	filelooper(cp, cp->cmdc=='X');
-	return TRUE;
-}
-
-int
-plan9_cmd(File *f, Cmd *cp)
-{
-	plan9(f, cp->cmdc, cp->ctext, nest);
-	return TRUE;
-}
-
-int
-eq_cmd(File *f, Cmd *cp)
-{
-	int charsonly;
-
-	switch(cp->ctext->n){
-	case 1:
-		charsonly = FALSE;
-		break;
-	case 2:
-		if(cp->ctext->s[0]=='#'){
-			charsonly = TRUE;
-			break;
-		}
-	default:
-		SET(charsonly);
-		error(Enewline);
-	}
-	printposn(f, charsonly);
-	return TRUE;
-}
-
-int
-nl_cmd(File *f, Cmd *cp)
-{
-	if(cp->addr == 0){
-		/* First put it on newline boundaries */
-		addr = lineaddr((Posn)0, f->dot, -1);
-		addr.r.p2 = lineaddr((Posn)0, f->dot, 1).r.p2;
-		if(addr.r.p1==f->dot.r.p1 && addr.r.p2==f->dot.r.p2)
-			addr = lineaddr((Posn)1, f->dot, 1);
-		display(f);
-	}else if(downloaded)
-		moveto(f, addr.r);
-	else
-		display(f);
-	return TRUE;
-}
-
-int
-cd_cmd(File *f, Cmd *cp)
-{
-	USED(f);
-	cd(cp->ctext);
-	return TRUE;
-}
-
-int
-append(File *f, Cmd *cp, Posn p)
-{
-	if(cp->ctext->n>0 && cp->ctext->s[cp->ctext->n-1]==0)
-		--cp->ctext->n;
-	if(cp->ctext->n>0)
-		Finsert(f, cp->ctext, p);
-	f->ndot.r.p1 = p;
-	f->ndot.r.p2 = p+cp->ctext->n;
-	return TRUE;
-}
-
-int
-display(File *f)
-{
-	Posn p1, p2;
-	int np, n;
-	char *c;
-
-	p1 = addr.r.p1;
-	p2 = addr.r.p2;
-	while(p1 < p2){
-		np = p2-p1;
-		if(np>BLOCKSIZE-1)
-			np = BLOCKSIZE-1;
-		n = Fchars(f, genbuf, p1, p1+np);
-		if(n <= 0)
-			panic("display");
-		genbuf[n] = 0;
-		c = Strtoc(tmprstr(genbuf, n+1));
-		if(downloaded)
-			termwrite(c);
-		else
-			Write(1, c, strlen(c));
-		free(c);
-		p1+=n;
-	}
-	f->dot = addr;
-	return TRUE;
-}
-
-void
-looper(File *f, Cmd *cp, int xy)
-{
-	Posn p, op;
-	Range r;
-
-	r = addr.r;
-	op= xy? -1 : r.p1;
-	nest++;
-	compile(cp->re);
-	for(p = r.p1; p<=r.p2; ){
-		if(!execute(f, p, r.p2)){ /* no match, but y should still run */
-			if(xy || op>r.p2)
-				break;
-			f->dot.r.p1 = op, f->dot.r.p2 = r.p2;
-			p = r.p2+1;	/* exit next loop */
-		}else{
-			if(sel.p[0].p1==sel.p[0].p2){	/* empty match? */
-				if(sel.p[0].p1==op){
-					p++;
-					continue;
-				}
-				p = sel.p[0].p2+1;
-			}else
-				p = sel.p[0].p2;
-			if(xy)
-				f->dot.r = sel.p[0];
-			else
-				f->dot.r.p1 = op, f->dot.r.p2 = sel.p[0].p1;
-		}
-		op = sel.p[0].p2;
-		cmdexec(f, cp->ccmd);
-		compile(cp->re);
-	}
-	--nest;
-}
-
-void
-linelooper(File *f, Cmd *cp)
-{
-	Posn p;
-	Range r, linesel;
-	Address a3;
-
-	nest++;
-	r = addr.r;
-	a3.f = f;
-	a3.r.p1 = a3.r.p2 = r.p1;
-	for(p = r.p1; p<r.p2; p = a3.r.p2){
-		a3.r.p1 = a3.r.p2;
-/*pjw		if(p!=r.p1 || (linesel = lineaddr((Posn)0, a3, 1)).r.p2==p)*/
-		if(p!=r.p1 || ((linesel = lineaddr((Posn)0, a3, 1).r), linesel.p2==p))
-			linesel = lineaddr((Posn)1, a3, 1).r;
-		if(linesel.p1 >= r.p2)
-			break;
-		if(linesel.p2 >= r.p2)
-			linesel.p2 = r.p2;
-		if(linesel.p2 > linesel.p1)
-			if(linesel.p1>=a3.r.p2 && linesel.p2>a3.r.p2){
-				f->dot.r = linesel;
-				cmdexec(f, cp->ccmd);
-				a3.r = linesel;
-				continue;
-			}
-		break;
-	}
-	--nest;
-}
-
-void
-filelooper(Cmd *cp, int XY)
-{
-	File *f, *cur;
-	int i;
-
-	if(Glooping++)
-		error(EnestXY);
-	nest++;
-	settempfile();
-	cur = curfile;
-	for(i = 0; i<tempfile.nused; i++){
-		f = tempfile.filepptr[i];
-		if(f==cmd)
-			continue;
-		if(cp->re==0 || filematch(f, cp->re)==XY)
-			cmdexec(f, cp->ccmd);
-	}
-	if(cur && whichmenu(cur)>=0)	/* check that cur is still a file */
-		current(cur);
-	--Glooping;
-	--nest;
-}
//GO.SYSIN DD ./sam/xec.c
echo ./sam/unix.c
sed s/.// > ./sam/unix.c <<'//GO.SYSIN DD ./sam/unix.c'
-#include	"sam.h"
-#include	"sys/stat.h"
-#include	"sys/wait.h"
-#include	"signal.h"
-
-#ifdef	NEEDSTDARG
-#include	<stdarg.h>
-#endif
-#ifdef	NEEDVARARG
-#include	<varargs.h>
-#endif
-
-Rune	samname[] = { '~', '~', 's', 'a', 'm', '~', '~', 0 };
-
-static Rune l1[] = { '{', '[', '(', '<', 0};
-static Rune l2[] = { '\n', 0};
-static Rune l3[] = { '\'', '"', '`', 0};
-Rune *left[]= { l1, l2, l3, 0};
-
-static Rune r1[] = {'}', ']', ')', '>', 0};
-static Rune r2[] = {'\n', 0};
-static Rune r3[] = {'\'', '"', '`', 0};
-Rune *right[]= { r1, r2, r3, 0};
-
-char	RSAM[] = RSAMNAME;
-char	SAMTERM[] = TERMNAME;
-char	HOME[] = HOMEDIR;
-char	TMPDIR[] = TMP;
-char	SH[] = SHELLNAME;
-char	SHPATH[] = SHELLPATH;
-char	RX[] = RXNAME;
-char	RXPATH[] = RXPATHNAME;
-
-void
-dprint(char *z, ...)
-{
-	va_list args;
-	char buf[BLOCKSIZE];
-
-	va_start(args, z);
-	vsprintf(buf, z, args);
-	termwrite(buf);
-	va_end(args);
-}
-
-char*
-getuser(void)
-{
-	static char *user = 0;
-
-	if (!user)
-		user = getlogin();
-	if(!user)
-		user = "none";
-	return user;
-}
-
-int
-statfile(char *name, ulong *id, long *time, long *length)
-{
-	struct stat dirb;
-
-	if (stat(name, &dirb) == -1)
-		return -1;
-	if (id)
-		*id = dirb.st_ino;
-	if (time)
-		*time = dirb.st_mtime;
-	if (length)
-		*length = dirb.st_size;
-	return 1;
-}
-
-int
-statfd(int fd, ulong *id, long *time, long *length)
-{
-	struct stat dirb;
-
-	if (fstat(fd, &dirb) == -1)
-		return -1;
-	if (id)
-		*id = dirb.st_ino;
-	if (time)
-		*time = dirb.st_mtime;
-	if (length)
-		*length = dirb.st_size;
-	return 1;
-}
-
-void
-hup(int sig)
-{
-	rescue();
-	exit(1);
-}
-
-void
-interrupt(int sig)
-{
-	signal(SIGINT, interrupt);
-	error(Eintr);
-}
-
-int
-notify (void(*f)(void *, char *))
-{
-	void (*onintr)(int);
-
-	onintr = signal(SIGINT, interrupt);
-	if(onintr != SIG_ERR && onintr != SIG_DFL)
-		signal(SIGINT, onintr);
-	onintr = signal(SIGHUP, hup);
-	if(onintr != SIG_ERR && onintr != SIG_DFL)
-		signal(SIGHUP, onintr);
-	signal(SIGPIPE, SIG_IGN);
-#ifdef	v10
-	close(3);		/* redirect v10 /dev/tty */
-	open("/dev/null", 2);
-#endif
-	return 1;
-}
-
-void
-notifyf(void *a, char *b)	/* never called */
-{
-}
-
-int
-newtmp(int i)
-{
-	FILE *f;
-	f = tmpfile();
-	if (f == 0)
-		return -1;
-	return fileno(f);
-}
-
-void
-samerr(char *buf)
-{
-	int j;
-
-	j = getpid();
-	do sprint(buf, "%s/sam%5d%.6s", TMPDIR, j++, getuser());
-	while (access(buf, 0) == 0);
-}
-
-int
-waitfor(int pid)
-{
-	int wm;
-	int rpid;
-
-	do; while((rpid = wait(&wm)) != pid && rpid != -1);
-	return (WEXITSTATUS(wm));
-}
-
-void*
-emalloc(ulong n)
-{
-	void *p;
-
-	if (n < sizeof(int))
-		n = sizeof(int);
-	p = malloc(n);
-	if(p == 0)
-		panic("malloc fails");
-	memset(p, 0, n);
-	return p;
-}
-
-void*
-erealloc(void *p, ulong n)
-{
-	p = realloc(p, n);
-	if(p == 0)
-		panic("realloc fails");
-	return p;
-}
//GO.SYSIN DD ./sam/unix.c
echo ./samterm/flayer.c
sed s/.// > ./samterm/flayer.c <<'//GO.SYSIN DD ./samterm/flayer.c'
-#include <u.h>
-#include <libg.h>
-#include <frame.h>
-#include "flayer.h"
-#include "samterm.h"
-
-#define	DELTA	10
-
-static Flayer	**llist;	/* front to back */
-static int	nllist;
-static int	nlalloc;
-static Rectangle lDrect;
-
-extern Bitmap	screen;
-extern Mouse	mouse;
-
-Vis		visibility(Flayer *);
-void		newvisibilities(int);
-void		llinsert(Flayer*);
-void		lldelete(Flayer*);
-
-void
-flstart(Rectangle r)
-{
-	lDrect = r;
-}
-
-void
-flnew(Flayer *l, Rune *(*fn)(Flayer*, long, ulong*), int u0, void *u1)
-{
-	if(nllist == nlalloc){
-		nlalloc += DELTA;
-		llist = realloc(llist, nlalloc*sizeof(Flayer**));
-		if(llist == 0)
-			panic("flnew");
-	}
-	l->textfn = fn;
-	l->user0 = u0;
-	l->user1 = u1;
-	llinsert(l);
-}
-
-Rectangle
-flrect(Flayer *l, Rectangle r)
-{
-	rectclip(&r, lDrect);
-	l->entire = r;
-	l->scroll = inset(r, FLMARGIN);
-	r.min.x =
-	 l->scroll.max.x = r.min.x+FLMARGIN+FLSCROLLWID+(FLGAP-FLMARGIN);
-	return r;
-}
-
-void
-flinit(Flayer *l, Rectangle r, Font *ft)
-{
-	lldelete(l);
-	llinsert(l);
-	l->visible = All;
-	l->origin = l->p0 = l->p1 = 0;
-	frinit(&l->f, inset(flrect(l, r), FLMARGIN), ft, &screen);
-	newvisibilities(1);
-	bitblt(&screen, l->entire.min, &screen, l->entire, 0);
-	scrdraw(l, 0L);
-	flborder(l, 0);
-}
-
-void
-flclose(Flayer *l)
-{
-	if(l->visible == All)
-		bitblt(&screen, l->entire.min, &screen, l->entire, 0);
-	else if(l->visible == Some){
-		if(l->f.b == 0)
-			l->f.b = balloc(l->entire, screen.ldepth);
-		if(l->f.b){
-			bitblt(l->f.b, l->entire.min, l->f.b, l->entire, 0);
-			flrefresh(l, l->entire, 0);
-		}
-	}
-	frclear(&l->f);
-	lldelete(l);
-	if(l->f.b && l->visible!=All)
-		bfree(l->f.b);
-	l->textfn = 0;
-	newvisibilities(1);
-}
-
-void
-flborder(Flayer *l, int wide)
-{
-	if(flprepare(l)){
-		border(l->f.b, l->entire, FLMARGIN, 0);
-		border(l->f.b, l->entire, wide? FLMARGIN : 1, F&~D);
-		if(l->visible==Some)
-			flrefresh(l, l->entire, 0);
-	}
-}
-
-Flayer *
-flwhich(Point p)
-{
-	int i;
-
-	if(p.x==0 && p.y==0)
-		return nllist? llist[0] : 0;
-	for(i=0; i<nllist; i++)
-		if(ptinrect(p, llist[i]->entire))
-			return llist[i];
-	return 0;
-}
-
-void
-flupfront(Flayer *l)
-{
-	int v = l->visible;
-
-	lldelete(l);
-	llinsert(l);
-	if(v!=All)
-		newvisibilities(0);
-}
-
-void
-newvisibilities(int redraw)
-	/* if redraw false, we know it's a flupfront, and needn't
-	 * redraw anyone becoming partially covered */
-{
-	int i;
-	Vis ov;
-	Flayer *l;
-
-	for(i = 0; i<nllist; i++){
-		l = llist[i];
-		ov = l->visible;
-		l->visible = visibility(l);
-#define	V(a, b)	(((a)<<2)|((b)))
-		switch(V(ov, l->visible)){
-		case V(Some, None):
-			if(l->f.b)
-				bfree(l->f.b);
-		case V(All, None):
-		case V(All, Some):
-			l->f.b = 0;
-			frclear(&l->f);
-			break;
-
-		case V(Some, Some):
-			if(l->f.b==0 && redraw)
-		case V(None, Some):
-				flprepare(l);
-			if(l->f.b && redraw){
-				flrefresh(l, l->entire, 0);
-				bfree(l->f.b);
-				l->f.b = 0;
-				frclear(&l->f);
-			}
-		case V(None, None):
-		case V(All, All):
-			break;
-
-		case V(Some, All):
-			if(l->f.b){
-				bitblt(&screen, l->entire.min, l->f.b, l->entire, S);
-				bfree(l->f.b);
-				l->f.b = &screen;
-				break;
-			}
-		case V(None, All):
-			flprepare(l);
-			break;
-		}
-		if(ov==None && l->visible!=None)
-			flnewlyvisible(l);
-	}
-}
-
-void
-llinsert(Flayer *l)
-{
-	int i;
-	for(i=nllist; i>0; --i)
-		llist[i]=llist[i-1];
-	llist[0]=l;
-	nllist++;
-}
-
-void
-lldelete(Flayer *l)
-{
-	int i;
-
-	for(i=0; i<nllist; i++)
-		if(llist[i]==l){
-			--nllist;
-			for(; i<nllist; i++)
-				llist[i] = llist[i+1];
-			return;
-		}
-	panic("lldelete");
-}
-
-void
-flinsert(Flayer *l, Rune *sp, Rune *ep, long p0)
-{
-	if(flprepare(l)){
-		frinsert(&l->f, sp, ep, p0-l->origin);
-		scrdraw(l, scrtotal(l));
-		if(l->visible==Some)
-			flrefresh(l, l->entire, 0);
-	}
-}
-
-void
-fldelete(Flayer *l, long p0, long p1)
-{
-	if(flprepare(l)){
-		p0 -= l->origin;
-		if(p0 < 0)
-			p0 = 0;
-		p1 -= l->origin;
-		if(p1<0)
-			p1 = 0;
-		frdelete(&l->f, p0, p1);
-		scrdraw(l, scrtotal(l));
-		if(l->visible==Some)
-			flrefresh(l, l->entire, 0);
-	}
-}
-
-int
-flselect(Flayer *l)
-{
-	int ret = 0;
-	if(l->visible!=All)
-		flupfront(l);
-	frselect(&l->f, &mouse);
-	if(l->f.p0==l->f.p1){
-		if(mouse.msec-l->click<Clicktime && l->f.p0+l->origin==l->p0){
-			ret = 1;
-			l->click = 0;
-		}else
-			l->click = mouse.msec;
-	}else
-		l->click = 0;
-	l->p0 = l->f.p0+l->origin, l->p1 = l->f.p1+l->origin;
-	return ret;
-}
-
-void
-flsetselect(Flayer *l, long p0, long p1)
-{
-	ulong fp0, fp1;
-
-	l->click = 0;
-	if(l->visible==None || !flprepare(l)){
-		l->p0 = p0, l->p1 = p1;
-		return;
-	}
-	l->p0 = p0, l->p1 = p1;
-	flfp0p1(l, &fp0, &fp1);
-	if(fp0==l->f.p0 && fp1==l->f.p1)
-		return;
-	frselectp(&l->f, F&~D);
-	l->f.p0 = fp0, l->f.p1 = fp1;
-	frselectp(&l->f, F&~D);
-	if(l->visible==Some)
-		flrefresh(l, l->entire, 0);
-}
-
-void
-flfp0p1(Flayer *l, ulong *pp0, ulong *pp1)
-{
-	long p0 = l->p0-l->origin, p1 = l->p1-l->origin;
-
-	if(p0 < 0)
-		p0 = 0;
-	if(p1 < 0)
-		p1 = 0;
-	if(p0 > l->f.nchars)
-		p0 = l->f.nchars;
-	if(p1 > l->f.nchars)
-		p1 = l->f.nchars;
-	*pp0 = p0;
-	*pp1 = p1;
-}
-
-Rectangle
-rscale(Rectangle r, Point old, Point new)
-{
-	r.min.x = r.min.x*new.x/old.x;
-	r.min.y = r.min.y*new.y/old.y;
-	r.max.x = r.max.x*new.x/old.x;
-	r.max.y = r.max.y*new.y/old.y;
-	return r;
-}
-
-void
-flreshape(Rectangle dr)
-{
-	int i;
-	Flayer *l;
-	Frame *f;
-	Rectangle r, olDrect;
-	int move;
-
-	olDrect = lDrect;
-	lDrect = dr;
-	move = 0;
-		bitblt(&screen, lDrect.min, &screen, lDrect, 0);
-	for(i=0; i<nllist; i++){
-		l = llist[i];
-		f = &l->f;
-		if(move)
-			r = raddp(rsubp(l->entire, olDrect.min), dr.min);
-		else{
-			r = raddp(rscale(rsubp(l->entire, olDrect.min),
-				sub(olDrect.max, olDrect.min),
-				sub(dr.max, dr.min)), dr.min);
-			if(l->visible==Some && f->b){
-				bfree(f->b);
-				frclear(f);
-			}
-			f->b = 0;
-			if(l->visible!=None)
-				frclear(f);
-		}
-		if(!rectclip(&r, dr))
-			panic("flreshape");
-		if(r.max.x-r.min.x<100)
-			r.min.x = dr.min.x;
-		if(r.max.x-r.min.x<100)
-			r.max.x = dr.max.x;
-		if(r.max.y-r.min.y<2*FLMARGIN+f->font->height)
-			r.min.y = dr.min.y;
-		if(r.max.y-r.min.y<2*FLMARGIN+f->font->height)
-			r.max.y = dr.max.y;
-		if(!move)
-			l->visible = None;
-		frsetrects(f, inset(flrect(l, r), FLMARGIN), f->b);
-		if(!move && f->b)
-			scrdraw(l, scrtotal(l));
-	}
-	newvisibilities(1);
-}
-
-int
-flprepare(Flayer *l)
-{
-	Frame *f;
-	ulong n;
-	Rune *r;
-
-	if(l->visible == None)
-		return 0;
-	f = &l->f;
-	if(f->b == 0){
-		if(l->visible == All)
-			f->b = &screen;
-		else if((f->b = balloc(l->entire, screen.ldepth))==0)
-			return 0;
-		bitblt(f->b, l->entire.min, f->b, l->entire, 0);
-		border(f->b, l->entire, l==llist[0]? FLMARGIN : 1, F&~D);
-		n = f->nchars;
-		frinit(f, f->entire, f->font, f->b);
-		r = (*l->textfn)(l, n, &n);
-		frinsert(f, r, r+n, (ulong)0);
-		frselectp(f, F&~D);
-		flfp0p1(l, &l->f.p0, &l->f.p1);
-		frselectp(f, F&~D);
-		scrdraw(l, scrtotal(l));
-	}
-	return 1;
-}
-
-static	int	somevis, someinvis, justvis;
-
-Vis
-visibility(Flayer *l)
-{
-	somevis = someinvis = 0;
-	justvis = 1;
-	flrefresh(l, l->entire, 0);
-	justvis = 0;
-	if(somevis==0)
-		return None;
-	if(someinvis==0)
-		return All;
-	return Some;
-}
-
-void
-flrefresh(Flayer *l, Rectangle r, int i)
-{
-	Flayer *t;
-	Rectangle s;
-
-    Top:
-	if((t=llist[i++]) == l){
-		if(!justvis)
-			bitblt(&screen, r.min, l->f.b, r, S);
-		somevis = 1;
-	}else{
-		if(!rectXrect(t->entire, r))
-			goto Top;	/* avoid stacking unnecessarily */
-		if(t->entire.min.x>r.min.x){
-			s = r;
-			s.max.x = t->entire.min.x;
-			flrefresh(l, s, i);
-			r.min.x = t->entire.min.x;
-		}
-		if(t->entire.min.y>r.min.y){
-			s = r;
-			s.max.y = t->entire.min.y;
-			flrefresh(l, s, i);
-			r.min.y = t->entire.min.y;
-		}
-		if(t->entire.max.x<r.max.x){
-			s = r;
-			s.min.x = t->entire.max.x;
-			flrefresh(l, s, i);
-			r.max.x = t->entire.max.x;
-		}
-		if(t->entire.max.y<r.max.y){
-			s = r;
-			s.min.y = t->entire.max.y;
-			flrefresh(l, s, i);
-			r.max.y = t->entire.max.y;
-		}
-		/* remaining piece of r is blocked by t; forget about it */
-		someinvis = 1;
-	}
-}
//GO.SYSIN DD ./samterm/flayer.c
echo ./samterm/flayer.h
sed s/.// > ./samterm/flayer.h <<'//GO.SYSIN DD ./samterm/flayer.h'
-typedef enum Vis{
-	None=0,
-	Some,
-	All
-}Vis;
-
-enum{
-	Clicktime=1000		/* one second */
-};
-
-typedef struct Flayer Flayer;
-
-struct Flayer
-{
-	Frame		f;
-	long		origin;	/* offset of first char in flayer */
-	long		p0, p1;
-	long		click;	/* time at which selection click occurred, in HZ */
-	Rune		*(*textfn)(Flayer*, long, ulong*);
-	int		user0;
-	void		*user1;
-	Rectangle	entire;
-	Rectangle	scroll;
-	Vis		visible;
-};
-
-void	flborder(Flayer*, int);
-void	flclose(Flayer*);
-void	fldelete(Flayer*, long, long);
-void	flfp0p1(Flayer*, ulong*, ulong*);
-void	flinit(Flayer*, Rectangle, Font*);
-void	flinsert(Flayer*, Rune*, Rune*, long);
-void	flnew(Flayer*, Rune *(*fn)(Flayer*, long, ulong*), int, void*);
-int	flprepare(Flayer*);
-Rectangle flrect(Flayer*, Rectangle);
-void	flrefresh(Flayer*, Rectangle, int);
-void	flreshape(Rectangle);
-int	flselect(Flayer*);
-void	flsetselect(Flayer*, long, long);
-void	flstart(Rectangle);
-void	flupfront(Flayer*);
-Flayer	*flwhich(Point);
-
-#define	FLMARGIN	4
-#define	FLSCROLLWID	12
-#define	FLGAP		4
//GO.SYSIN DD ./samterm/flayer.h
echo ./samterm/icons.c
sed s/.// > ./samterm/icons.c <<'//GO.SYSIN DD ./samterm/icons.c'
-#include <u.h>
-#include <libg.h>
-
-Cursor bullseye={
-	{-7, -7},
-	{0x1F, 0xF8, 0x3F, 0xFC, 0x7F, 0xFE, 0xFB, 0xDF,
-	 0xF3, 0xCF, 0xE3, 0xC7, 0xFF, 0xFF, 0xFF, 0xFF,
-	 0xFF, 0xFF, 0xFF, 0xFF, 0xE3, 0xC7, 0xF3, 0xCF,
-	 0x7B, 0xDF, 0x7F, 0xFE, 0x3F, 0xFC, 0x1F, 0xF8,},
-	{0x00, 0x00, 0x0F, 0xF0, 0x31, 0x8C, 0x21, 0x84,
-	 0x41, 0x82, 0x41, 0x82, 0x41, 0x82, 0x7F, 0xFE,
-	 0x7F, 0xFE, 0x41, 0x82, 0x41, 0x82, 0x41, 0x82,
-	 0x21, 0x84, 0x31, 0x8C, 0x0F, 0xF0, 0x00, 0x00,}
-};
-Cursor deadmouse={
-	{-7, -7},
-	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	 0x00, 0x00, 0x00, 0x0C, 0x00, 0x8E, 0x1D, 0xC7,
-	 0xFF, 0xE3, 0xFF, 0xF3, 0xFF, 0xFF, 0x7F, 0xFE, 
-	 0x3F, 0xF8, 0x17, 0xF0, 0x03, 0xE0, 0x00, 0x00,},
-	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
-	 0x00, 0x00, 0x00, 0x08, 0x00, 0x04, 0x00, 0x82,
-	 0x04, 0x41, 0xFF, 0xE1, 0x5F, 0xF1, 0x3F, 0xFE, 
-	 0x17, 0xF0, 0x03, 0xE0, 0x00, 0x00, 0x00, 0x00,}
-};
-Cursor lockarrow={
-	{-7, -7},
-	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,},
-	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	 0x00, 0x00, 0x00, 0x00, 0x0F, 0xC0, 0x0F, 0xC0,
-	 0x03, 0xC0, 0x07, 0xC0, 0x0E, 0xC0, 0x1C, 0xC0,
-	 0x38, 0x00, 0x70, 0x00, 0xE0, 0xDB, 0xC0, 0xDB,}
-};
-
-uchar darkgreybits[] = {
-	0xDD, 0xDD, 0x77, 0x77, 0xDD, 0xDD, 0x77, 0x77,
-	0xDD, 0xDD, 0x77, 0x77, 0xDD, 0xDD, 0x77, 0x77,
-	0xDD, 0xDD, 0x77, 0x77, 0xDD, 0xDD, 0x77, 0x77,
-	0xDD, 0xDD, 0x77, 0x77, 0xDD, 0xDD, 0x77, 0x77,
-};
-
-Bitmap	*darkgrey;
-
-void
-iconinit(void)
-{
-	darkgrey = balloc(Rect(0, 0, 16, 16), 0);
-	wrbitmap(darkgrey, 0, 16, darkgreybits);
-}
//GO.SYSIN DD ./samterm/icons.c
echo ./samterm/io.c
sed s/.// > ./samterm/io.c <<'//GO.SYSIN DD ./samterm/io.c'
-#include <u.h>
-#include <libg.h>
-#include <frame.h>
-#include "flayer.h"
-#include "samterm.h"
-
-int	cursorfd;
-int	input;
-int	got;
-int	block;
-int	kbdc;
-int	reshaped;
-uchar	*hostp;
-uchar	*hoststop;
-void	panic(char*);
-
-void
-initio(void){
-	einit(Emouse|Ekeyboard);
-	estart(Ehost, 0, 0);
-}
-
-void
-frgetmouse(void)
-{
-	mouse = emouse();
-}
-
-void
-mouseunblock(void)
-{
-	got &= ~Emouse;
-}
-
-void
-kbdblock(void)
-{		/* ca suffit */
-	block = Ekeyboard;
-}
-
-int
-button(int but)
-{
-	frgetmouse();
-	return mouse.buttons&(1<<(but-1));
-}
-
-int
-waitforio(void)
-{
-	ulong type;
-	static Event e;
-
-	if(got & ~block)
-		return got & ~block;
-	type = eread(~(got|block), &e);
-	switch(type){
-	case Ehost:
-		hostp = e.data;
-		hoststop = hostp + e.n;
-		block = 0;
-		break;
-	case Ekeyboard:
-		kbdc = e.kbdc;
-		break;
-	case Emouse:
-		mouse = e.mouse;
-		break;
-	}
-	got |= type;
-	return got; 
-}
-
-int
-rcvchar(void)
-{
-	int c;
-
-	if(!(got & Ehost))
-		return -1;
-	c = *hostp++;
-	if(hostp == hoststop)
-		got &= ~Ehost;
-	return c;
-}
-
-char*
-rcvstring(void)
-{
-	*hoststop = 0;
-	got &= ~Ehost;
-	return (char*)hostp;
-}
-
-int
-getch(void)
-{
-	int c;
-
-	while((c = rcvchar()) == -1){
-		block = ~Ehost;
-		waitforio();
-		block = 0;
-	}
-	return c;
-}
-
-int
-kbdchar(void)
-{
-	int c;
-
-	if(got & Ekeyboard){
-		c = kbdc;
-		kbdc = -1;
-		got &= ~Ekeyboard;
-		return c;
-	}
-	if(!ecankbd())
-		return -1;
-	return ekbd();
-}
-
-int
-qpeekc(void)
-{
-	return kbdc;
-}
-
-void
-ereshaped(Rectangle r)
-{
-	USED(r);
-
-	reshaped = 1;
-}
-
-int
-RESHAPED(void)
-{
-	if(reshaped){
-		screen.r = bscreenrect(&screen.clipr);
-		reshaped = 0;
-		return 1;
-	}
-	return 0;
-}
-
-void
-mouseexit(void)
-{
-	exits(0);
-}
//GO.SYSIN DD ./samterm/io.c
echo ./samterm/main.c
sed s/.// > ./samterm/main.c <<'//GO.SYSIN DD ./samterm/main.c'
-#include <u.h>
-#include <libg.h>
-#include <frame.h>
-#include "flayer.h"
-#include "samterm.h"
-
-Text	cmd;
-Rune	*scratch;
-long	nscralloc;
-Cursor	*cursor;
-extern Bitmap	screen;
-Mouse	mouse;
-Flayer	*which = 0;
-Flayer	*work = 0;
-long	snarflen;
-long	typestart = -1;
-long	typeend = -1;
-long	typeesc = -1;
-long	modified = 0;		/* strange lookahead for menus */
-char	lock = 1;
-char	hasunlocked = 0;
-
-void
-main(int argc, char *argv[])
-{
-	int got, scr;
-	Text *t;
-	Rectangle r;
-	Flayer *nwhich;
-
-	int fwdbut;
-
-	getscreen(argc, argv);
-	fwdbut = scrollfwdbut();
-	iconinit();
-	initio();
-	scratch = alloc(100*RUNESIZE);
-	nscralloc = 100;
-	r = screen.r;
-	r.max.y = r.min.y+Dy(r)/5;
-	flstart(screen.clipr);
-	rinit(&cmd.rasp);
-	flnew(&cmd.l[0], gettext, 1, &cmd);
-	flinit(&cmd.l[0], r, font);
-	cmd.nwin = 1;
-	which = &cmd.l[0];
-	cmd.tag = Untagged;
-	outTs(Tversion, VERSION);
-	startnewfile(Tstartcmdfile, &cmd);
-
-	got = 0;
-	for(;;got = waitforio()){
-		if(hasunlocked && RESHAPED())
-			reshape();
-		if(got&RHost)
-			rcv();
-		if(got&RKeyboard)
-			if(which)
-				type(which);
-			else
-				kbdblock();
-		if(got&RMouse){
-			if(lock==2 || !ptinrect(mouse.xy, screen.r)){
-				mouseunblock();
-				continue;
-			}
-			nwhich = flwhich(mouse.xy);
-			scr = which && ptinrect(mouse.xy, which->scroll);
-			if(mouse.buttons)
-				flushtyping(1);
-			if(mouse.buttons&1){
-				if(nwhich){
-					if(nwhich!=which)
-						current(nwhich);
-					else if(scr)
-						scroll(which, fwdbut == 3 ? 1 : 3);
-					else{
-						t=(Text *)which->user1;
-						if(flselect(which)){
-							outTsl(Tdclick, t->tag, which->p0);
-							t->lock++;
-						}else if(t!=&cmd)
-							outcmd();
-					}
-				}
-			}else if((mouse.buttons&2) && which){
-				if(scr)
-					scroll(which, 2);
-				else
-					menu2hit();
-			}else if((mouse.buttons&4)){
-				if(scr)
-					scroll(which, fwdbut == 3 ? 3 : 1);
-				else
-					menu3hit();
-			}
-			mouseunblock();
-		}
-	}
-}
-
-
-void
-reshape(void){
-	int i;
-
-	flreshape(screen.clipr);
-	for(i = 0; i<nname; i++)
-		if(text[i])
-			hcheck(text[i]->tag);
-}
-
-void
-current(Flayer *nw)
-{
-	Text *t;
-
-	if(which)
-		flborder(which, 0);
-	if(nw){
-		flushtyping(1);
-		flupfront(nw);
-		flborder(nw, 1);
-		buttons(Up);
-		t=(Text *)nw->user1;
-		t->front = nw-&t->l[0];
-		if(t!=&cmd)
-			work = nw;
-	}
-	which = nw;
-}
-
-void
-closeup(Flayer *l)
-{
-	Text *t=(Text *)l->user1;
-	int m;
-
-	m = whichmenu(t->tag);
-	if(m < 0)
-		return;
-	flclose(l);
-	if(l == which){
-		which = 0;
-		current(flwhich(Pt(0, 0)));
-	}
-	if(l == work)
-		work = 0;
-	if(--t->nwin == 0){
-		rclear(&t->rasp);
-		free((uchar *)t);
-		text[m] = 0;
-	}else if(l == &t->l[t->front]){
-		for(m=0; m<NL; m++)	/* find one; any one will do */
-			if(t->l[m].textfn){
-				t->front = m;
-				return;
-			}
-		panic("close");
-	}
-}
-
-Flayer *
-findl(Text *t)
-{
-	int i;
-	for(i = 0; i<NL; i++)
-		if(t->l[i].textfn==0)
-			return &t->l[i];
-	return 0;
-}
-
-void
-duplicate(Flayer *l, Rectangle r, Font *f, int close)
-{
-	Text *t=(Text *)l->user1;
-	Flayer *nl = findl(t);
-	Rune *rp;
-	ulong n;
-
-	if(nl){
-		flnew(nl, gettext, l->user0, (char *)t);
-		flinit(nl, r, f);
-		nl->origin = l->origin;
-		rp = (*l->textfn)(l, l->f.nchars, &n);
-		flinsert(nl, rp, rp+n, l->origin);
-		flsetselect(nl, l->p0, l->p1);
-		if(close){
-			flclose(l);
-			if(l==which)
-				which = 0;
-		}else
-			t->nwin++;
-		current(nl);
-		hcheck(t->tag);
-	}
-	cursorswitch(cursor);
-}
-
-void
-buttons(int updown)
-{
-	while(((mouse.buttons&7)!=0) != updown)
-		frgetmouse();
-}
-
-int
-getr(Rectangle *rp)
-{
-	Point p;
-	Rectangle r;
-
-	*rp = getrect(3, &mouse);
-	if(rp->max.x && rp->max.x-rp->min.x<=5 && rp->max.y-rp->min.y<=5){
-		p = rp->min;
-		r = cmd.l[cmd.front].entire;
-		*rp = screen.r;
-		if(cmd.nwin==1){
-			if (p.y <= r.min.y)
-				rp->max.y = r.min.y;
-			else if (p.y >= r.max.y)
-				rp->min.y = r.max.y;
-			if (p.x <= r.min.x)
-				rp->max.x = r.min.x;
-			else if (p.x >= r.max.x)
-				rp->min.x = r.max.x;
-		}
-	}
-	return rectclip(rp, screen.r) &&
-	   rp->max.x-rp->min.x>100 && rp->max.y-rp->min.y>40;
-}
-
-void
-snarf(Text *t, int w)
-{
-	Flayer *l = &t->l[w];
-
-	if(l->p1>l->p0){
-		snarflen = l->p1-l->p0;
-		outTsll(Tsnarf, t->tag, l->p0, l->p1);
-	}
-}
-
-void
-cut(Text *t, int w, int save, int check)
-{
-	long p0, p1;
-
-	if((p0 = t->l[w].p0)==(p1 = t->l[w].p1))
-		return;
-	if(p0<0)
-		panic("cut");
-	if(save)
-		snarf(t, w);
-	outTsll(Tcut, t->tag, p0, p1);
-	flsetselect(&t->l[w], p0, p0);
-	t->lock++;
-	hcut(t->tag, p0, p1-p0);
-	if(check)
-		hcheck(t->tag);
-}
-
-void
-paste(Text *t, int w)
-{
-	if(snarflen){
-		cut(t, w, 0, 0);
-		t->lock++;
-		outTsl(Tpaste, t->tag, t->l[w].p0);
-	}
-}
-
-void
-scrorigin(Flayer *l, int but, long p0)
-{
-	Text *t=(Text *)l->user1;
-
-	switch(but){
-	case 1:
-		outTsll(Torigin, t->tag, l->origin, p0);
-		break;
-	case 2:
-		outTsll(Torigin, t->tag, p0, 1L);
-		break;
-	case 3:
-		horigin(t->tag,p0);
-	}
-}
-
-int
-alnum(int c)
-{
-	/*
-	 * Hard to get absolutely right.  Use what we know about ASCII
-	 * and assume anything above the Latin control characters is
-	 * potentially an alphanumeric.
-	 */
-	if(c<=' ')
-		return 0;
-	if(0x7F<=c && c<=0xA0)
-		return 0;
-	if(utfrune("!\"#$%&'()*+,-./:;<=>?@[\\]^`{|}~", c))
-		return 0;
-	return 1;
-}
-
-int
-raspc(Rasp *r, long p)
-{
-	ulong n;
-	rload(r, p, p+1, &n);
-	if(n)
-		return scratch[0];
-	return 0;
-}
-
-long
-ctlw(Rasp *r, long o, long p)
-{
-	int c;
-
-	if(--p < o)
-		return o;
-	if(raspc(r, p)=='\n')
-		return p;
-	for(; p>=o && !alnum(c=raspc(r, p)); --p)
-		if(c=='\n')
-			return p+1;
-	for(; p>o && alnum(raspc(r, p-1)); --p)
-		;
-	return p>=o? p : o;
-}
-
-long
-ctlu(Rasp *r, long o, long p)
-{
-	for(; p-1>=o && raspc(r, p-1)!='\n'; --p)
-		;
-	return p>=o? p : o;
-}
-
-int
-center(Flayer *l, long a)
-{
-	Text *t;
-
-	t = l->user1;
-	if(!t->lock && (a<l->origin || l->origin+l->f.nchars<a)){
-		if(a > t->rasp.nrunes)
-			a = t->rasp.nrunes;
-		outTsll(Torigin, t->tag, a, 2L);
-		return 1;
-	}
-	return 0;
-}
-
-int
-onethird(Flayer *l, long a)
-{
-	Text *t;
-	Rectangle s;
-	long lines;
-
-	t = l->user1;
-	if(!t->lock && (a<l->origin || l->origin+l->f.nchars<a)){
-		if(a > t->rasp.nrunes)
-			a = t->rasp.nrunes;
-		s = inset(l->scroll, 1);
-		lines = ((s.max.y-s.min.y)/l->f.font->height+1)/3;
-		if (lines < 2)
-			lines = 2;
-		outTsll(Torigin, t->tag, a, lines);
-		return 1;
-	}
-	return 0;
-}
-
-void
-flushtyping(int clearesc)
-{
-	Text *t;
-	ulong n;
-
-	if(clearesc)
-		typeesc = -1;	
-	if(typestart == typeend) {
-		modified = 0;
-		return;
-	}
-	modified = 1;
-	t = which->user1;
-	rload(&t->rasp, typestart, typeend, &n);
-	scratch[n] = 0;
-	if(t==&cmd && typeend==t->rasp.nrunes && scratch[typeend-typestart-1]=='\n'){
-		setlock();
-		outcmd();
-	}
-	outTslS(Ttype, t->tag, typestart, scratch);
-	typestart = -1;
-	typeend = -1;
-}
-
-#define	SCROLLKEY	0x80
-#define	ESC		0x1B
-
-void
-type(Flayer *l)	/* what a bloody mess this is */
-{
-	Text *t = (Text *)l->user1;
-	Rune buf[100];
-	Rune *p = buf;
-	int c, backspacing = 0;
-	long a;
-	int scrollkey = qpeekc()==SCROLLKEY;	/* ICK */
-
-	if(lock || t->lock){
-		kbdblock();
-		return;
-	}
-	a = l->p0;
-	if(a!=l->p1 && !scrollkey){
-		flushtyping(1);
-		cut(t, t->front, 1, 1);
-		return;	/* it may now be locked */
-	}
-	c = 0;
-	while(!backspacing && (c = kbdchar())>0 && c!=SCROLLKEY && c!=ESC)
-		switch(c){
-		case '\b':
-		case 0x15:	/* ctrl-u */
-		case 0x17:	/* ctrl-w */
-		case 0x7F:	/* del */
-			backspacing = 1;
-			break;
-
-		default:
-			*p++ = c;
-			if(c == '\n' || p >= buf+sizeof(buf))
-				goto Flush;
-			break;
-		}
-  Flush:
-	if(p > buf){
-		if(typestart < 0)
-			typestart = a;
-		if(typeesc < 0)
-			typeesc = a;
-		hgrow(t->tag, a, p-buf, 0);
-		t->lock++;	/* pretend we Trequest'ed for hdatarune*/
-		hdatarune(t->tag, a, buf, p-buf);
-		a += p-buf;
-		l->p0 = a;
-		l->p1 = a;
-		typeend = a;
-		if(c=='\n' || typeend-typestart>100)
-			flushtyping(0);
-		onethird(l, a);
-	}
-	if(c == SCROLLKEY){
-		flushtyping(0);
-		center(l, l->origin+l->f.nchars+1);
-		/* backspacing immediately after outcmd(): sorry */
-	}else if(backspacing && !lock){
-		if(l->f.p0>0 && a>0){
-			switch(c){
-			case '\b':
-			case 0x7F:	/* del */
-				l->p0 = a-1;
-				break;
-			case 0x15:	/* ctrl-u */
-				l->p0 = ctlu(&t->rasp, l->origin, a);
-				break;
-			case 0x17:	/* ctrl-w */
-				l->p0 = ctlw(&t->rasp, l->origin, a);
-				break;
-			}
-			l->p1 = a;
-			if(l->p1 != l->p0){
-				/* cut locally if possible */
-				if(typestart<=l->p0 && l->p1<=typeend){
-					t->lock++;	/* to call hcut */
-					hcut(t->tag, l->p0, l->p1-l->p0);
-					/* hcheck is local because we know rasp is contiguous */
-					hcheck(t->tag);
-				}else{
-					flushtyping(0);
-					cut(t, t->front, 0, 1);
-				}
-			}
-			if(typeesc >= l->p0)
-				typeesc = l->p0;
-			if(typestart >= 0){
-				if(typestart >= l->p0)
-					typestart = l->p0;
-				typeend = l->p0;
-				if(typestart == typeend){
-					typestart = -1;
-					typeend = -1;
-					modified = 0;
-				}
-			}
-		}
-	}else{
-		if(c==ESC && typeesc>=0){
-			l->p0 = typeesc;
-			l->p1 = a;
-			flushtyping(1);
-		}
-		for(l=t->l; l<&t->l[NL]; l++)
-			if(l->textfn)
-				flsetselect(l, l->p0, l->p1);
-	}
-}
-
-
-void
-outcmd(void){
-	if(work)
-		outTsll(Tworkfile, ((Text *)work->user1)->tag, work->p0, work->p1);
-}
-
-void
-panic(char *s)
-{
-	fprint(2, "samterm:panic: ");
-	perror(s);
-	abort();
-}
-
-Rune*
-gettext(Flayer *l, long n, ulong *np)
-{
-	Text *t;
-
-	t = l->user1;
-	rload(&t->rasp, l->origin, l->origin+n, np);
-	return scratch;
-}
-
-long
-scrtotal(Flayer *l)
-{
-	return ((Text *)l->user1)->rasp.nrunes;
-}
-
-void*
-alloc(ulong n)
-{
-	void *p;
-
-	p = malloc(n);
-	if(p==0)
-		panic("alloc");
-	memset(p, 0, n);
-	return p;
-}
//GO.SYSIN DD ./samterm/main.c
echo ./samterm/menu.c
sed s/.// > ./samterm/menu.c <<'//GO.SYSIN DD ./samterm/menu.c'
-#include <u.h>
-#include <libg.h>
-#include <frame.h>
-#include "flayer.h"
-#include "samterm.h"
-
-uchar	*name[MAXFILES];	/* first byte is ' ' or '\'': modified state */
-Text	*text[MAXFILES];	/* pointer to Text associated with file */
-ushort	tag[MAXFILES];		/* text[i].tag, even if text[i] not defined */
-int	nname;
-int	mw;
-
-char	*genmenu3(int);
-char	*genmenu2(int);
-char	*genmenu2c(int);
-
-enum Menu2
-{
-	Cut,
-	Paste,
-	Snarf,
-	Look,
-	Exch,
-	Search,
-	NMENU2 = Search,
-	Send = Search,
-	NMENU2C
-};
-
-enum Menu3
-{
-	New,
-	Xerox,
-	Reshape,
-	Close,
-	Write,
-	NMENU3
-};
-
-char	*menu2str[] = {
-	"cut",
-	"paste",
-	"snarf",
-	"look",
-	"<exch>",
-	0,		/* storage for last pattern */
-};
-
-char	*menu3str[] = {
-	"new",
-	"xerox",
-	"reshape",
-	"close",
-	"write",
-};
-
-Menu	menu2 =	{0, genmenu2};
-Menu	menu2c ={0, genmenu2c};
-Menu	menu3 =	{0, genmenu3};
-
-void
-menu2hit(void)
-{
-	Text *t=(Text *)which->user1;
-	int w = which-t->l;
-
-	switch(menuhit(2, &mouse, t==&cmd? &menu2c : &menu2)){
-	case Cut:
-		if(!lock && !t->lock)
-			cut(t, w, 1, 1);
-		break;
-
-	case Paste:
-		if(!lock && !t->lock)
-			paste(t, w);
-		break;
-
-	case Snarf:
-		if(!lock && !t->lock)
-			snarf(t, w);
-		break;
-
-	case Exch:
-		outT0(Tstartsnarf);
-		setlock();
-		break;
-
-	case Look:
-		outTsll(Tlook, t->tag, which->p0, which->p1);
-		setlock();
-		break;
-
-	case Search:
-		outcmd();
-		if(t==&cmd)
-			outTsll(Tsend, 0 /*ignored*/, which->p0, which->p1);
-		else
-			outT0(Tsearch);
-		setlock();
-		break;
-	}
-}
-
-void
-menu3hit(void)
-{
-	Rectangle r;
-	Flayer *l;
-	int m, i;
-	Text *t;
-
-	mw = -1;
-	switch(m = menuhit(3, &mouse, &menu3)){
-	case -1:
-		break;
-
-	case New:
-		if(!lock)
-			sweeptext(1, 0);
-		break;
-
-	case Xerox:
-	case Reshape:
-		if(!lock){
-			cursorswitch(&bullseye);
-			buttons(Down);
-			if((mouse.buttons&4) && (l = flwhich(mouse.xy)) && getr(&r))
-				duplicate(l, r, l->f.font, m==Reshape);
-			else
-				cursorswitch(cursor);
-			buttons(Up);
-		}
-		break;
-
-	case Close:
-		if(!lock){
-			cursorswitch(&bullseye);
-			buttons(Down);
-			if((mouse.buttons&4) && (l = flwhich(mouse.xy)) && !lock){
-				t=(Text *)l->user1;
-				if(t!=&cmd || t->nwin>1){
-					if(t->nwin>1)
-						closeup(l);
-					else
-						outTs(Tclose, t->tag);
-				}
-			}
-			cursorswitch(cursor);
-			buttons(Up);
-		}
-		break;
-
-	case Write:
-		if(!lock){
-			cursorswitch(&bullseye);
-			buttons(Down);
-			if((mouse.buttons&4) && (l = flwhich(mouse.xy))){
-				outTs(Twrite, ((Text *)l->user1)->tag);
-				setlock();
-			}else
-				cursorswitch(cursor);
-			buttons(Up);
-		}
-		break;
-
-	default:
-		if(t = text[m-NMENU3]){
-			i = t->front;
-			if(t->nwin==0 || t->l[i].textfn==0)
-				return;	/* not ready yet; try again later */
-			if(t->nwin>1 && which==&t->l[i])
-				do
-					if(++i==NL)
-						i = 0;
-				while(i!=t->front && t->l[i].textfn==0);
-			current(&t->l[i]);
-		}else
-			sweeptext(0, tag[m-NMENU3]);
-		break;
-	}
-}
-
-
-Text *
-sweeptext(int new, int tag)
-{
-	Rectangle r;
-	Text *t;
-
-	if(getr(&r) && (t = malloc(sizeof(Text)))){
-		memset(t, 0, sizeof(Text));
-		current((Flayer *)0);
-		flnew(&t->l[0], gettext, 0, (char *)t);
-		flinit(&t->l[0], r, font);	/*bnl*/
-		t->nwin = 1;
-		rinit(&t->rasp);
-		if(new)
-			startnewfile(Tstartnewfile, t);
-		else{
-			rinit(&t->rasp);
-			t->tag = tag;
-			startfile(t);
-		}
-		return t;
-	}
-	return 0;
-}
-
-int
-whichmenu(int tg)
-{
-	int i;
-
-	for(i=0; i<nname; i++)
-		if(tag[i] == tg)
-			return i;
-	return -1;
-}
-
-void
-menuins(int n, uchar *s, Text *t, int m, int tg)
-{
-	int i;
-
-	if(nname == MAXFILES)
-		panic("menuins");
-	for(i=nname; i>n; --i)
-		name[i]=name[i-1], text[i]=text[i-1], tag[i]=tag[i-1];
-	text[n] = t;
-	tag[n] = tg;
-	name[n] = alloc(strlen((char*)s)+2);
-	name[n][0] = m;
-	strcpy((char*)name[n]+1, (char*)s);
-	nname++;
-	menu3.lasthit = n;
-}
-
-void
-menudel(int n)
-{
-	int i;
-
-	if(nname==0 || n>=nname || text[n])
-		panic("menudel");
-	free(name[n]);
-	--nname;
-	for(i = n; i<nname; i++)
-		name[i]=name[i+1], text[i]=text[i+1], tag[i]=tag[i+1];
-}
-
-void
-setpat(char *s)
-{
-	static char pat[17];
-
-	pat[0] = '/';
-	strncpy(pat+1, s, 15);
-	menu2str[Search] = pat;
-}
-
-#define	NBUF	64
-static uchar buf[NBUF*UTFmax]={' ', ' ', ' ', ' '};
-
-char *
-paren(char *s)
-{
-	uchar *t = buf;
-
-	*t++ = '(';
-	do; while(*t++ = *s++);
-	t[-1] = ')';
-	*t = 0;
-	return (char *)buf;
-}
-char*
-genmenu2(int n)
-{
-	Text *t=(Text *)which->user1;
-	char *p;
-	if(n>=NMENU2+(menu2str[Search]!=0))
-		return 0;
-	p = menu2str[n];
-	if(!lock && !t->lock || n==Search || n==Look)
-		return p;
-	return paren(p);
-}
-char*
-genmenu2c(int n)
-{
-	Text *t=(Text *)which->user1;
-	char *p;
-	if(n >= NMENU2C)
-		return 0;
-	if(n == Send)
-		p="send";
-	else
-		p = menu2str[n];
-	if(!lock && !t->lock)
-		return p;
-	return paren(p);
-}
-char *
-genmenu3(int n)
-{
-	Text *t;
-	int c, i, k, l, w;
-	Rune r;
-	char *p;
-
-	if(n >= NMENU3+nname)
-		return 0;
-	if(n < NMENU3){
-		p = menu3str[n];
-		if(lock)
-			p = paren(p);
-		return p;
-	}
-	n -= NMENU3;
-	if(n == 0)	/* unless we've been fooled, this is cmd */
-		return (char *)&name[n][1];
-	if(mw == -1){
-		mw = 7;	/* strlen("~~sam~~"); */
-		for(i=1; i<nname; i++){
-			w = utflen((char*)name[i]+1)+4;	/* include "'+. " */
-			if(w > mw)
-				mw = w;
-		}
-	}
-	if(mw > NBUF)
-		mw = NBUF;
-	t = text[n];
-	buf[0] = name[n][0];
-	buf[1] = '-';
-	buf[2] = ' ';
-	buf[3] = ' ';
-	if(t){
-		if(t->nwin == 1)
-			buf[1] = '+';
-		else if(t->nwin > 1)
-			buf[1] = '*';
-		if(work && t==(Text *)work->user1) {
-			buf[2]= '.';
-			if(modified)
-				buf[0] = '\'';
-		}
-	}
-	l = utflen((char*)name[n]+1);
-	if(l > NBUF-4-2){
-		i = 4;
-		k = 1;
-		while(i < NBUF/2){
-			k += chartorune(&r, (char*)name[n]+k);
-			i++;
-		}
-		c = name[n][k];
-		name[n][k] = 0;
-		strcpy((char*)buf+4, (char*)name[n]+1);
-		name[n][k] = c;
-		strcat((char*)buf, "...");
-		while((l-i) >= NBUF/2-4){
-			k += chartorune(&r, (char*)name[n]+k);
-			i++;
-		}
-		strcat((char*)buf, (char*)name[n]+k);
-	}else
-		strcpy((char*)buf+4, (char*)name[n]+1);
-	i = utflen((char*)buf);
-	k = strlen((char*)buf);
-	while(i<mw && k<sizeof buf-1){
-		buf[k++] = ' ';
-		i++;
-	}
-	buf[k] = 0;
-	return (char *)buf;
-}
//GO.SYSIN DD ./samterm/menu.c
echo ./samterm/mesg.c
sed s/.// > ./samterm/mesg.c <<'//GO.SYSIN DD ./samterm/mesg.c'
-#include <u.h>
-#include <libg.h>
-#include <frame.h>
-#include "flayer.h"
-#include "samterm.h"
-
-#define	HSIZE	3	/* Type + short count */
-Header	h;
-uchar	indata[DATASIZE+1];	/* room for NUL */
-uchar	outdata[DATASIZE];
-short	outcount;
-int	hversion;
-
-void	inmesg(Hmesg, int);
-int	inshort(int);
-long	inlong(int);
-void	hsetdot(int, long, long);
-void	hmoveto(int, long);
-void	hsetsnarf(int);
-void	clrlock(void);
-int	snarfswap(char*, int, char**);
-
-void
-rcv(void)
-{
-	int c;
-	static state = 0;
-	static count = 0;
-	static i = 0;
-	static int errs = 0;
-
-	while((c=rcvchar()) != -1)
-		switch(state){
-		case 0:
-			h.type = c;
-			state++;
-			break;
-
-		case 1:
-			h.count0 = c;
-			state++;
-			break;
-
-		case 2:
-			h.count1 = c;
-			count = h.count0|(h.count1<<8);
-			i = 0;
-			if(count > DATASIZE){
-				if(++errs < 5){
-					dumperrmsg(count, h.type, h.count0, c);
-					state = 0;
-					continue;
-				}
-				fprint(2, "type %d count %d\n", h.type, count);
-				panic("count>DATASIZE");
-			}
-			if(count == 0)
-				goto zerocount;
-			state++;
-			break;
-
-		case 3:
-			indata[i++] = c;
-			if(i == count){
-		zerocount:
-				indata[i] = 0;
-				inmesg(h.type, count);
-				state = count = 0;
-				continue;
-			}
-			break;
-		}
-}
-
-Text *
-whichtext(int tg)
-{
-	int i;
-
-	for(i=0; i<nname; i++)
-		if(tag[i] == tg)
-			return text[i];
-	panic("whichtext");
-	return 0;
-}
-
-void
-inmesg(Hmesg type, int count)
-{
-	Text *t;
-	int i, m;
-	long l;
-	Flayer *lp;
-
-	m = inshort(0);
-	l = inlong(2);
-	switch(type){
-	case -1:
-		panic("rcv error");
-	default:
-		fprint(2, "type %d\n", type);
-		panic("rcv unknown");
-
-	case Hversion:
-		hversion = m;
-		break;
-
-	case Hbindname:
-		if((i=whichmenu(m)) < 0)
-			break;
-		/* in case of a race, a bindname may already have occurred */
-		if((t=whichtext(m)) == 0)
-			t=(Text *)l;
-		else	/* let the old one win; clean up the new one */
-			while(((Text *)l)->nwin>0)
-				closeup(&((Text *)l)->l[((Text *)l)->front]);
-		text[i] = t;
-		text[i]->tag = m;
-		break;
-
-	case Hcurrent:
-		if(whichmenu(m)<0)
-			break;
-		t = whichtext(m);
-		i = which && ((Text *)which->user1)==&cmd && m!=cmd.tag;
-		if(t==0 && (t = sweeptext(0, m))==0)
-			break;
-		if(t->l[t->front].textfn==0)
-			panic("Hcurrent");
-		lp = &t->l[t->front];
-		if(i){
-			flupfront(lp);
-			flborder(lp, 0);
-			work = lp;
-		}else
-			current(lp);
-		break;
-
-	case Hmovname:
-		if((m=whichmenu(m)) < 0)
-			break;
-		t = text[m];
-		l = tag[m];
-		i = name[m][0];
-		text[m] = 0;	/* suppress panic in menudel */
-		menudel(m);
-		if(t == &cmd)
-			m = 0;
-		else{
-			if (nname>0 && text[0]==&cmd)
-				m = 1;
-			else m = 0;
-			for(; m<nname; m++)
-				if(strcmp((char*)indata+2, (char*)name[m]+1)<0)
-					break;
-		}
-		menuins(m, indata+2, t, i, (int)l);
-		break;
-
-	case Hgrow:
-		if(whichmenu(m) >= 0)
-			hgrow(m, l, inlong(6), 1);
-		break;
-
-	case Hnewname:
-		menuins(0, (uchar *)"", (Text *)0, ' ', m);
-		break;
-
-	case Hcheck0:
-		if(whichmenu(m)>=0)
-			outTs(Tcheck, m);
-		break;
-
-	case Hcheck:
-		if(whichmenu(m)>=0)
-			hcheck(m);
-		break;
-
-	case Hunlock:
-		clrlock();
-		break;
-
-	case Hdata:
-		if(whichmenu(m) >= 0)
-			l += hdata(m, l, indata+6, count-6);
-	Checkscroll:
-		if(m == cmd.tag){
-			for(i=0; i<NL; i++){
-				lp = &cmd.l[i];
-				if(lp->textfn)
-					center(lp, l>=0? l : lp->p1);
-			}
-		}
-		break;
-
-	case Horigin:
-		if(whichmenu(m) >= 0)
-			horigin(m, l);
-		break;
-
-	case Hunlockfile:
-		if(whichmenu(m)>=0 && (t = whichtext(m))->lock){
-			--t->lock;
-			l = -1;
-			goto Checkscroll;
-		}
-		break;
-
-	case Hsetdot:
-		if(whichmenu(m) >= 0)
-			hsetdot(m, l, inlong(6));
-		break;
-
-	case Hgrowdata:
-		if(whichmenu(m)<0)
-			break;
-		hgrow(m, l, inlong(6), 0);
-		whichtext(m)->lock++;	/* fake the request */
-		l += hdata(m, l, indata+10, count-10);
-		goto Checkscroll;
-
-	case Hmoveto:
-		if(whichmenu(m)>=0)
-			hmoveto(m, l);
-		break;
-
-	case Hclean:
-		if((m = whichmenu(m)) >= 0)
-			name[m][0] = ' ';
-		break;
-
-	case Hdirty:
-		if((m = whichmenu(m))>=0)
-			name[m][0] = '\'';
-		break;
-
-	case Hdelname:
-		if((m=whichmenu(m)) >= 0)
-			menudel(m);
-		break;
-
-	case Hcut:
-		if(whichmenu(m) >= 0)
-			hcut(m, l, inlong(6));
-		break;
-
-	case Hclose:
-		if(whichmenu(m)<0 || (t = whichtext(m))==0)
-			break;
-		for(i = 0,lp = t->l; i<NL; i++,lp++)
-			if(lp->textfn)
-				closeup(lp);
-		break;
-
-	case Hsetpat:
-		setpat((char *)indata);
-		break;
-
-	case Hsetsnarf:
-		hsetsnarf(m);
-		break;
-
-	case Hsnarflen:
-		snarflen = inlong(0);
-		break;
-
-	case Hack:
-		outT0(Tack);
-		break;
-
-	case Hexit:
-		outT0(Texit);
-		mouseexit();
-		break;
-	}
-}
-
-void
-setlock(void)
-{
-	lock++;
-	cursorswitch(cursor = &lockarrow);
-}
-
-void
-clrlock(void)
-{
-	hasunlocked = 1;
-	if(lock > 0)
-		lock--;
-	if(lock == 0)
-		cursorswitch(cursor=(Cursor *)0);
-}
-
-void
-startfile(Text *t)
-{
-	outTsl(Tstartfile, t->tag, (long)t);
-	setlock();
-}
-
-void
-startnewfile(int type, Text *t)
-{
-	t->tag = Untagged;
-	outTl(type, (long)t);
-}
-
-int
-inshort(int n)
-{
-	return indata[n]|(indata[n+1]<<8);
-}
-
-long
-inlong(int n)
-{
-	return indata[n]|(indata[n+1]<<8)|
-		((long)indata[n+2]<<16)|((long)indata[n+3]<<24);
-}
-
-void
-outT0(Tmesg type)
-{
-	outstart(type);
-	outsend();
-}
-
-void
-outTl(Tmesg type, long l)
-{
-	outstart(type);
-	outlong(l);
-	outsend();
-}
-
-void
-outTs(Tmesg type, int s)
-{
-	outstart(type);
-	outshort(s);
-	outsend();
-}
-
-void
-outTss(Tmesg type, int s1, int s2)
-{
-	outstart(type);
-	outshort(s1);
-	outshort(s2);
-	outsend();
-}
-
-void
-outTsll(Tmesg type, int s1, long l1, long l2)
-{
-	outstart(type);
-	outshort(s1);
-	outlong(l1);
-	outlong(l2);
-	outsend();
-}
-
-void
-outTsl(Tmesg type, int s1, long l1)
-{
-	outstart(type);
-	outshort(s1);
-	outlong(l1);
-	outsend();
-}
-
-void
-outTslS(Tmesg type, int s1, long l1, Rune *s)
-{
-	char buf[DATASIZE*3+1];
-	char *c;
-
-	outstart(type);
-	outshort(s1);
-	outlong(l1);
-	c = buf;
-	while(*s)
-		c += runetochar(c, s++);
-	*c++ = 0;
-	outcopy(c-buf, (uchar *)buf);
-	outsend();
-}
-
-void
-outTsls(Tmesg type, int s1, long l1, int s2)
-{
-	outstart(type);
-	outshort(s1);
-	outlong(l1);
-	outshort(s2);
-	outsend();
-}
-
-void
-outstart(Tmesg type)
-{
-	outdata[0] = type;
-	outcount = 0;
-}
-
-void
-outcopy(int count, uchar *data)
-{
-	while(count--)
-		outdata[HSIZE+outcount++] = *data++;	
-}
-
-void
-outshort(int s)
-{
-	uchar buf[2];
-
-	buf[0]=s;
-	buf[1]=s>>8;
-	outcopy(2, buf);
-}
-
-void
-outlong(long l)
-{
-	uchar buf[4];
-
-	buf[0]=l;
-	buf[1]=l>>8;
-	buf[2]=l>>16;
-	buf[3]=l>>24;
-	outcopy(4, buf);
-}
-
-void
-outsend(void)
-{
-	if(outcount>DATASIZE-HSIZE)
-		panic("outcount>sizeof outdata");
-	outdata[1]=outcount;
-	outdata[2]=outcount>>8;
-	if(write(1, (char *)outdata, outcount+HSIZE)!=outcount+HSIZE)
-		exits("write error");
-}
-
-
-void
-hsetdot(int m, long p0, long p1)
-{
-	Text *t = whichtext(m);
-	Flayer *l = &t->l[t->front];
-
-	flushtyping(1);
-	flsetselect(l, p0, p1);
-}
-
-void
-horigin(int m, long p0)
-{
-	Text *t = whichtext(m);
-	Flayer *l = &t->l[t->front];
-	long a;
-	ulong n;
-	Rune *r;
-
-	if(!flprepare(l)){
-		l->origin = p0;
-		return;
-	}
-	a = p0-l->origin;
-	if(a>=0 && a<l->f.nchars)
-		frdelete(&l->f, 0, a);
-	else if(a<0 && -a<l->f.nchars){
-		r = rload(&t->rasp, p0, l->origin, &n);
-		frinsert(&l->f, r, r+n, 0);
-	}else
-		frdelete(&l->f, 0, l->f.nchars);
-	l->origin = p0;
-	scrdraw(l, t->rasp.nrunes);
-	if(l->visible==Some)
-		flrefresh(l, l->entire, 0);
-	hcheck(m);
-}
-
-void
-hmoveto(int m, long p0)
-{
-	Text *t = whichtext(m);
-	Flayer *l = &t->l[t->front];
-
-	if(p0<l->origin || p0-l->origin>l->f.nchars*9/10)
-		outTsll(Torigin, m, p0, 2L);
-}
-
-void
-hcheck(int m)
-{
-	Flayer *l;
-	Text *t;
-	int reqd = 0, i;
-	long n, nl, a;
-	Rune *r;
-
-	if(m == Untagged)
-		return;
-	t = whichtext(m);
-	if(t == 0)		/* possible in a half-built window */
-		return;
-	for(l = &t->l[0], i = 0; i<NL; i++, l++){
-		if(l->textfn==0 || !flprepare(l))	/* BUG: don't
-							   need this if BUG below
-							   is fixed */
-			continue;
-		a = t->l[i].origin;
-		n = rcontig(&t->rasp, a, a+l->f.nchars, 1);
-		if(n<l->f.nchars)	/* text missing in middle of screen */
-			a+=n;
-		else{			/* text missing at end of screen? */
-        Again:
-		 	if(l->f.lastlinefull)
-				goto Checksel;	/* all's well */
-			a = t->l[i].origin+l->f.nchars;
-			n = t->rasp.nrunes-a;
-			if(n==0)
-				goto Checksel;
-			if(n>TBLOCKSIZE)
-				n = TBLOCKSIZE;
-			n = rcontig(&t->rasp, a, a+n, 1);
-			if(n>0){
-				rload(&t->rasp, a, a+n, 0);
-				nl = l->f.nchars;
-				r = scratch;
-				flinsert(l, r, r+n, l->origin+nl);
-				if(nl == l->f.nchars)	/* made no progress */
-					goto Checksel;
-				goto Again;
-			}
-		}
-		if(!reqd){
-			n = rcontig(&t->rasp, a, a+TBLOCKSIZE, 0);
-			if(n <= 0)
-				panic("hcheck request==0");
-			outTsls(Trequest, m, a, (int)n);
-			outTs(Tcheck, m);
-			t->lock++;
-			reqd++;
-		}
-	    Checksel:
-		flsetselect(l, l->p0, l->p1);
-	}
-}
-
-void
-flnewlyvisible(Flayer *l)
-{
-	hcheck(((Text *)l->user1)->tag);
-}
-
-void
-hsetsnarf(int nc)
-{
-	char *s2;
-	char *s1;
-	int i;
-	int n;
-
-	cursorswitch(&deadmouse);
-	s2 = alloc(nc+1);
-	for(i=0; i<nc; i++)
-		s2[i] = getch();
-	s2[nc] = 0;
-	n = snarfswap(s2, nc, &s1);
-	if (n >= 0) {
-		if (!s1)
-			n = 0;
-		snarflen = n;
-		outTs(Tsetsnarf, n);
-		if(n>0 && write(1, s1, n)!=n)
-			exits("write error");
-		if (s1)
-			free(s1);
-	}
-	free(s2);
-	cursorswitch(cursor);
-}
-
-void
-hgrow(int m, long a, long new, int req)
-{
-	int i;
-	Flayer *l;
-	Text *t = whichtext(m);
-	long o, b;
-
-	if(new <= 0)
-		panic("hgrow");
-	rresize(&t->rasp, a, 0L, new);
-	for(l = &t->l[0], i = 0; i<NL; i++, l++){
-		if(l->textfn == 0)
-			continue;
-		o = l->origin;
-		b = a-o-rmissing(&t->rasp, o, a);
-		if(a < o)
-			l->origin+=new;
-		if(a < l->p0)
-			l->p0+=new;
-		if(a < l->p1)
-			l->p1+=new;
-		/* must prevent b temporarily becoming unsigned */
-		if(!req || a<o || (b>0 && b>l->f.nchars) ||
-		    (l->f.nchars==0 && a-o>0))
-			continue;
-		if(new>TBLOCKSIZE)
-			new = TBLOCKSIZE;
-		outTsls(Trequest, m, a, (int)new);
-		t->lock++;
-		req = 0;
-	}
-}
-
-int
-hdata1(Text *t, long a, Rune *r, int len)
-{
-	int i;
-	Flayer *l;
-	long o, b;
-
-	for(l = &t->l[0], i=0; i<NL; i++, l++){
-		if(l->textfn==0)
-			continue;
-		o = l->origin;
-		b = a-o-rmissing(&t->rasp, o, a);
-		/* must prevent b temporarily becoming unsigned */
-		if(a<o || (b>0 && b>l->f.nchars))
-			continue;
-		flinsert(l, r, r+len, o+b);
-	}
-	rdata(&t->rasp, a, a+len, r);
-	rclean(&t->rasp);
-	return len;
-}
-
-int
-hdata(int m, long a, uchar *s, int len)
-{
-	int i, w;
-	Text *t = whichtext(m);
-	Rune buf[DATASIZE], *r;
-
-	if(t->lock)
-		--t->lock;
-	if(len == 0)
-		return 0;
-	r = buf;
-	for(i=0; i<len; i+=w,s+=w)
-		w = chartorune(r++, (char*)s);
-if(i != len) panic("i!=len");
-	return hdata1(t, a, buf, r-buf);
-}
-
-int
-hdatarune(int m, long a, Rune *r, int len)
-{
-	Text *t = whichtext(m);
-
-	if(t->lock)
-		--t->lock;
-	if(len == 0)
-		return 0;
-	return hdata1(t, a, r, len);
-}
-
-void
-hcut(int m, long a, long old)
-{
-	Flayer *l;
-	Text *t = whichtext(m);
-	int i;
-	long o, b;
-
-	if(t->lock)
-		--t->lock;
-	for(l = &t->l[0], i = 0; i<NL; i++, l++){
-		if(l->textfn == 0)
-			continue;
-		o = l->origin;
-		b = a-o-rmissing(&t->rasp, o, a);
-		/* must prevent b temporarily becoming unsigned */
-		if((b<0 || b<l->f.nchars) && a+old>=o){
-			fldelete(l, b<0? o : o+b,
-			    a+old-rmissing(&t->rasp, o, a+old));
-		}
-		if(a+old<o)
-			l->origin-=old;
-		else if(a<=o)
-			l->origin = a;
-		if(a+old<l->p0)
-			l->p0-=old;
-		else if(a<=l->p0)
-			l->p0 = a;
-		if(a+old<l->p1)
-			l->p1-=old;
-		else if(a<=l->p1)
-			l->p1 = a;
-	}
-	rresize(&t->rasp, a, old, 0L);
-	rclean(&t->rasp);
-}
//GO.SYSIN DD ./samterm/mesg.c
echo ./samterm/rasp.c
sed s/.// > ./samterm/rasp.c <<'//GO.SYSIN DD ./samterm/rasp.c'
-#include <u.h>
-#include <libg.h>
-#include <frame.h>
-#include "flayer.h"
-#include "samterm.h"
-
-void
-rinit(Rasp *r)
-{
-	r->nrunes=0;
-	r->sect=0;
-}
-
-void
-rclear(Rasp *r)
-{
-	Section *s, *ns;
-
-	for(s=r->sect; s; s=ns){
-		ns = s->next;
-		free(s->text);
-		free(s);
-	}
-	r->sect = 0;
-}
-
-Section*
-rsinsert(Rasp *r, Section *s)	/* insert before s */
-{
-	Section *t;
-	Section *u;
-
-	t = alloc(sizeof(Section));
-	if(r->sect == s){	/* includes empty list case: r->sect==s==0 */
-		r->sect = t;
-		t->next = s;
-	}else{
-		u = r->sect;
-		if(u == 0)
-			panic("rsinsert 1");
-		do{
-			if(u->next == s){
-				t->next = s;
-				u->next = t;
-				goto Return;
-			}
-			u=u->next;
-		}while(u);
-		panic("rsinsert 2");
-	}
-    Return:
-	return t;
-}
-
-void
-rsdelete(Rasp *r, Section *s)
-{
-	Section *t;
-
-	if(s == 0)
-		panic("rsdelete");
-	if(r->sect == s){
-		r->sect = s->next;
-		goto Free;
-	}
-	for(t=r->sect; t; t=t->next)
-		if(t->next == s){
-			t->next = s->next;
-	Free:
-			if(s->text)
-				free(s->text);
-			free(s);
-			return;
-		}
-	panic("rsdelete 2");
-}
-
-void
-splitsect(Rasp *r, Section *s, long n0)
-{
-	if(s == 0)
-		panic("splitsect");
-	rsinsert(r, s->next);
-	if(s->text == 0)
-		s->next->text = 0;
-	else{
-		s->next->text = alloc(RUNESIZE*(TBLOCKSIZE+1));
-		Strcpy(s->next->text, s->text+n0);
-		s->text[n0] = 0;
-	}
-	s->next->nrunes = s->nrunes-n0;
-	s->nrunes = n0;
-}
-
-Section *
-findsect(Rasp *r, Section *s, long p, long q)	/* find sect containing q and put q on a sect boundary */
-{
-	if(s==0 && p!=q)
-		panic("findsect");
-	for(; s && p+s->nrunes<=q; s=s->next)
-		p += s->nrunes;
-	if(p != q){
-		splitsect(r, s, q-p);
-		s = s->next;
-	}
-	return s;
-}
-
-void
-rresize(Rasp *r, long a, long old, long new)
-{
-	Section *s, *t, *ns;
-
-	s = findsect(r, r->sect, 0L, a);
-	t = findsect(r, s, a, a+old);
-	for(; s!=t; s=ns){
-		ns=s->next;
-		rsdelete(r, s);
-	}
-	/* now insert the new piece before t */
-	if(new > 0){
-		ns=rsinsert(r, t);
-		ns->nrunes=new;
-		ns->text=0;
-	}
-	r->nrunes += new-old;
-}
-
-void
-rdata(Rasp *r, long p0, long p1, Rune *cp)
-{
-	Section *s, *t, *ns;
-
-	s = findsect(r, r->sect, 0L, p0);
-	t = findsect(r, s, p0, p1);
-	for(; s!=t; s=ns){
-		ns=s->next;
-		if(s->text)
-			panic("rdata");
-		rsdelete(r, s);
-	}
-	p1 -= p0;
-	s = rsinsert(r, t);
-	s->text = alloc(RUNESIZE*(TBLOCKSIZE+1));
-	memmove(s->text, cp, RUNESIZE*p1);
-	s->text[p1] = 0;
-	s->nrunes = p1;
-}
-
-void
-rclean(Rasp *r)
-{
-	Section *s;
-
-	for(s=r->sect; s; s=s->next)
-		while(s->next && (s->text!=0)==(s->next->text!=0)){
-			if(s->text){
-				if(s->nrunes+s->next->nrunes>TBLOCKSIZE)
-					break;
-				Strcpy(s->text+s->nrunes, s->next->text);
-			}
-			s->nrunes += s->next->nrunes;
-			rsdelete(r, s->next);
-		}
-}
-
-void
-Strcpy(Rune *to, Rune *from)
-{
-	do; while(*to++ = *from++);
-}
-
-Rune*
-rload(Rasp *r, ulong p0, ulong p1, ulong *nrp)
-{
-	Section *s;
-	long p;
-	int n, nb;
-
-	nb = 0;
-	Strgrow(&scratch, &nscralloc, p1-p0+1);
-	scratch[0] = 0;
-	for(p=0,s=r->sect; s && p+s->nrunes<=p0; s=s->next)
-		p += s->nrunes;
-	while(p<p1 && s){
-		/*
-		 * Subtle and important.  If we are preparing to handle an 'rdata'
-		 * call, it's because we have an 'rresize' hole here, so the
-		 * screen doesn't have data for that space anyway (it got cut
-		 * first).  So pretend it isn't there.
-		 */
-		if(s->text){
-			n = s->nrunes-(p0-p);
-			if(n>p1-p0)	/* all in this section */
-				n = p1-p0;
-			memmove(scratch+nb, s->text+(p0-p), n*RUNESIZE);
-			nb += n;
-			scratch[nb] = 0;
-		}
-		p += s->nrunes;
-		p0 = p;
-		s = s->next;
-	}
-	if(nrp)
-		*nrp = nb;
-	return scratch;
-}
-
-int
-rmissing(Rasp *r, ulong p0, ulong p1)
-{
-	Section *s;
-	long p;
-	int n, nm=0;
-
-	for(p=0,s=r->sect; s && p+s->nrunes<=p0; s=s->next)
-		p += s->nrunes;
-	while(p<p1 && s){
-		if(s->text == 0){
-			n = s->nrunes-(p0-p);
-			if(n > p1-p0)	/* all in this section */
-				n = p1-p0;
-			nm += n;
-		}
-		p += s->nrunes;
-		p0 = p;
-		s = s->next;
-	}
-	return nm;
-}
-
-int
-rcontig(Rasp *r, ulong p0, ulong p1, int text)
-{
-	Section *s;
-	long p, n;
-	int np=0;
-
-	for(p=0,s=r->sect; s && p+s->nrunes<=p0; s=s->next)
-		p += s->nrunes;
-	while(p<p1 && s && (text? (s->text!=0) : (s->text==0))){
-		n = s->nrunes-(p0-p);
-		if(n > p1-p0)	/* all in this section */
-			n = p1-p0;
-		np += n;
-		p += s->nrunes;
-		p0 = p;
-		s = s->next;
-	}
-	return np;
-}
-
-void
-Strgrow(Rune **s, long *n, int want)	/* can always toss the old data when called */
-{
-	if(*n >= want)
-		return;
-	free(*s);
-	*s = alloc(RUNESIZE*want);
-	*n = want;
-}
//GO.SYSIN DD ./samterm/rasp.c
echo ./samterm/samterm.h
sed s/.// > ./samterm/samterm.h <<'//GO.SYSIN DD ./samterm/samterm.h'
-#define	SAMTERM
-
-#define	RUNESIZE	sizeof(Rune)
-#define	MAXFILES	256
-#define	NL	5
-
-enum{
-	Up,
-	Down
-};
-
-typedef struct Text	Text;
-typedef struct Section	Section;
-typedef struct Rasp	Rasp;
-
-struct Section
-{
-	long	nrunes;
-	Rune	*text;		/* if null, we haven't got it */
-	Section	*next;
-};
-
-struct Rasp
-{
-	long	nrunes;
-	Section	*sect;
-};
-
-#define	Untagged	((ushort)65535)
-
-struct Text
-{
-	Rasp	rasp;
-	short	nwin;
-	short	front;		/* input window */
-	ushort	tag;
-	char	lock;
-	Flayer	l[NL];		/* screen storage */
-};
-
-enum Resource
-{
-	Ehost		= 0x04,
-	RHost		= Ehost,
-	RKeyboard	= Ekeyboard,
-	RMouse		= Emouse
-};
-
-extern Text	*text[];
-extern uchar	*name[];
-extern ushort	tag[];
-extern int	nname;
-extern Cursor	bullseye;
-extern Cursor	deadmouse;
-extern Cursor	lockarrow;
-extern Cursor	*cursor;
-extern Flayer	*which;
-extern Flayer	*work;
-extern Text	cmd;
-extern Rune	*scratch;
-extern long	nscralloc;
-extern char	lock;
-extern char	hasunlocked;
-extern long	snarflen;
-extern Mouse	mouse;
-extern long	modified;
-
-Rune	*gettext(Flayer*, long, ulong*);
-void	*alloc(ulong n);
-
-void	iconinit(void);
-void	getscreen(int, char**);
-void	initio(void);
-void	setlock(void);
-void	outcmd(void);
-void	rinit(Rasp*);
-void	startnewfile(int, Text*);
-void	cursorset(Point);
-void	getmouse(void);
-void	mouseunblock(void);
-void	kbdblock(void);
-int	button(int but);
-int	load(char*, int);
-int	waitforio(void);
-int	rcvchar(void);
-int	getch(void);
-int	kbdchar(void);
-int	qpeekc(void);
-void	mouseexit(void);
-void	cut(Text*, int, int, int);
-void	paste(Text*, int);
-void	snarf(Text*, int);
-int	center(Flayer*, long);
-int	xmenuhit(int, Menu*);
-void	buttons(int);
-int	getr(Rectangle*);
-void	current(Flayer*);
-void	duplicate(Flayer*, Rectangle, Font*, int);
-void	startfile(Text*);
-void	panic(char*);
-void	closeup(Flayer*);
-void	Strgrow(Rune**, long*, int);
-int	RESHAPED(void);
-void	reshape(void);
-void	rcv(void);
-void	type(Flayer*);
-void	menu2hit(void);
-void	menu3hit(void);
-void	scroll(Flayer*, int);
-void	hcheck(int);
-void	rclear(Rasp*);
-int	whichmenu(int);
-void	hcut(int, long, long);
-void	horigin(int, long);
-void	hgrow(int, long, long, int);
-int	hdata(int, long, uchar*, int);
-int	hdatarune(int, long, Rune*, int);
-Rune	*rload(Rasp*, ulong, ulong, ulong*);
-void	menuins(int, uchar*, Text*, int, int);
-void	menudel(int);
-Text	*sweeptext(int, int);
-void	setpat(char*);
-void	scrdraw(Flayer*, long tot);
-int	rcontig(Rasp*, ulong, ulong, int);
-int	rmissing(Rasp*, ulong, ulong);
-void	rresize(Rasp *, long, long, long);
-void	rdata(Rasp*, long, long, Rune*);
-void	rclean(Rasp*);
-void	scrorigin(Flayer*, int, long);
-long	scrtotal(Flayer*);
-void	flnewlyvisible(Flayer*);
-char	*rcvstring(void);
-void	Strcpy(Rune*, Rune*);
-void	Strncpy(Rune*, Rune*, long);
-void	flushtyping(int);
-void	dumperrmsg(int, int, int, int);
-
-#include "../sam/mesg.h"
-
-void	outTs(Tmesg, int);
-void	outT0(Tmesg);
-void	outTl(Tmesg, long);
-void	outTslS(Tmesg, int, long, Rune*);
-void	outTsll(Tmesg, int, long, long);
-void	outTsl(Tmesg, int, long);
-void	outstart(Tmesg);
-void	outcopy(int, uchar*);
-void	outshort(int);
-void	outlong(long);
-void	outsend(void);
//GO.SYSIN DD ./samterm/samterm.h
echo ./samterm/scroll.c
sed s/.// > ./samterm/scroll.c <<'//GO.SYSIN DD ./samterm/scroll.c'
-#include <u.h>
-#include <libg.h>
-#include <frame.h>
-#include "flayer.h"
-#include "samterm.h"
-
-extern Bitmap *darkgrey;
-extern Mouse mouse;
-
-Rectangle
-scrpos(Rectangle r, long p0, long p1, long tot)
-{
-	long h;
-	Rectangle q;
-
-	q = inset(r, 1);
-	h = q.max.y-q.min.y;
-	if(tot == 0)
-		return q;
-	if(tot > 1024L*1024L)
-		tot>>=10, p0>>=10, p1>>=10;
-	if(p0 > 0)
-		q.min.y += h*p0/tot;
-	if(p1 < tot)
-		q.max.y -= h*(tot-p1)/tot;
-	if(q.max.y < q.min.y+2){
-		if(q.min.y+2 <= r.max.y)
-			q.max.y = q.min.y+2;
-		else
-			q.min.y = q.max.y-2;
-	}
-	return q;
-}
-
-void
-scrflip(Flayer *l, Rectangle r)
-{
-	if(rectclip(&r, l->scroll))
-		bitblt(l->f.b, r.min, l->f.b, r, F&~D);
-}
-
-void
-scrdraw(Flayer *l, long tot)
-{
-	Rectangle r, r1, r2;
-	Bitmap *b;
-	static Bitmap *x;
-
-	if(l->f.b == 0)
-		panic("scrdraw");
-	r = l->scroll;
-	r.min.x += 1;	/* border between margin and bar */
-	r1 = r;
-	if(l->visible == All){
-		if(x == 0){
-			x = balloc(Rect(0, 0, 32, 1024), l->f.b->ldepth);
-			if(x == 0)
-				panic("scrdraw balloc");
-		}
-		b = x;
-		r1.min.x = 0;
-		r1.max.x = Dx(r);
-	}else
-		b = l->f.b;
-	bitblt(b, r1.min, b, r1, F);
-	texture(b, inset(r1, 1), darkgrey, S);
-	r2 = scrpos(r1, l->origin, l->origin+l->f.nchars, tot);
-	bitblt(b, r2.min, b, r2, 0);
-	if(b!=l->f.b)
-		bitblt(l->f.b, r.min, b, r1, S);
-}
-
-void
-scroll(Flayer *l, int but)
-{
-	int in = 0, oin;
-	long tot = scrtotal(l);
-	Rectangle scr, r, s, rt;
-	int x, y, my, oy, h;
-	long p0;
-
-	s = inset(l->scroll, 1);
-	x = s.min.x+FLSCROLLWID/2;
-	scr = scrpos(l->scroll, l->origin, l->origin+l->f.nchars, tot);
-	r = scr;
-	y = scr.min.y;
-	my = mouse.xy.y;
-	do{
-		oin = in;
-		in = abs(x-mouse.xy.x)<=FLSCROLLWID/2;
-		if(oin != in)
-			scrflip(l, r);
-		if(in){
-			oy = y;
-			my = mouse.xy.y;
-			if(my < s.min.y)
-				my = s.min.y;
-			if(my >= s.max.y)
-				my = s.max.y;
-			if(!eqpt(mouse.xy, Pt(x, my)))
-				cursorset(Pt(x, my));
-			if(but == 1){
-				p0 = l->origin-frcharofpt(&l->f, Pt(s.max.x, my));
-				rt = scrpos(l->scroll, p0, p0+l->f.nchars, tot);
-				y = rt.min.y;
-			}else if(but == 2){
-				y = my;
-				if(y > s.max.y-2)
-					y = s.max.y-2;
-			}else if(but == 3){
-				p0 = l->origin+frcharofpt(&l->f, Pt(s.max.x, my));
-				rt = scrpos(l->scroll, p0, p0+l->f.nchars, tot);
-				y = rt.min.y;
-			}
-			if(y != oy){
-				scrflip(l, r);
-				r = raddp(scr, Pt(0, y-scr.min.y));
-				scrflip(l, r);
-			}
-		}
-	}while(button(but));
-	if(in){
-		h = s.max.y-s.min.y;
-		scrflip(l, r);
-		p0 = 0;
-		if(but == 1)
-			p0 = (long)(my-s.min.y)/l->f.font->height+1;
-		else if(but == 2){
-			if(tot > 1024L*1024L)
-				p0 = ((tot>>10)*(y-s.min.y)/h)<<10;
-			else
-				p0 = tot*(y-s.min.y)/h;
-		}else if(but == 3){
-			p0 = l->origin+frcharofpt(&l->f, Pt(s.max.x, my));
-			if(p0 > tot)
-				p0 = tot;
-		}
-		scrorigin(l, but, p0);
-	}
-}
//GO.SYSIN DD ./samterm/scroll.c
echo ./samterm/unix.c
sed s/.// > ./samterm/unix.c <<'//GO.SYSIN DD ./samterm/unix.c'
-#include <u.h>
-#include <libg.h>
-#include <frame.h>
-#include "flayer.h"
-#include "samterm.h"
-#ifdef  SUNOS
-#include	<stdarg.h>
-#endif
-
-void
-getscreen(int argc, char **argv)
-{
-	int fd;
-	Rectangle r;
-
-	xtbinit(0, "Sam", &argc, argv);
-	r = inset(screen.r, 4);
-	bitblt(&screen, r.min, &screen, r, 0);
-}
-
-void
-dumperrmsg(int count, int type, int count0, int c)
-{
-	uchar *cp;
-	int i;
-
-	cp = (uchar *) rcvstring();
-	fprint(2, "samterm: host mesg: count %d %ux %ux %ux %s...ignored\n",
-		count, type, count0, c, cp);
-	i = 0;
-	while (*cp) {
-		fprint(2, "%x ", *cp);
-		if (i++ >= 20) {
-			fprint(2, "\n");
-			i = 0;
-		}
-		cp++;
-	}
-}
//GO.SYSIN DD ./samterm/unix.c
echo ./libframe/frbox.c
sed s/.// > ./libframe/frbox.c <<'//GO.SYSIN DD ./libframe/frbox.c'
-#include <u.h>
-#include <libg.h>
-#include <frame.h>
-
-#define	SLOP	25
-
-void
-_fraddbox(Frame *f, int bn, int n)	/* add n boxes after bn, shift the rest up,
-				 * box[bn+n]==box[bn] */
-{
-	int i;
-
-	if(bn > f->nbox)
-		berror("_fraddbox");
-	if(f->nbox+n > f->nalloc)
-		_frgrowbox(f, n+SLOP);
-	for(i=f->nbox; --i>=bn; )
-		f->box[i+n] = f->box[i];
-	f->nbox+=n;
-}
-
-void
-_frclosebox(Frame *f, int n0, int n1)	/* inclusive */
-{
-	int i;
-
-	if(n0>=f->nbox || n1>=f->nbox || n1<n0)
-		berror("_frclosebox");
-	n1++;
-	for(i=n1; i<f->nbox; i++)
-		f->box[i-(n1-n0)] = f->box[i];
-	f->nbox -= n1-n0;
-}
-
-void
-_frdelbox(Frame *f, int n0, int n1)	/* inclusive */
-{
-	if(n0>=f->nbox || n1>=f->nbox || n1<n0)
-		berror("_frdelbox");
-	_frfreebox(f, n0, n1);
-	_frclosebox(f, n0, n1);
-}
-
-void
-_frfreebox(Frame *f, int n0, int n1)	/* inclusive */
-{
-	int i;
-
-	if(n1<n0)
-		return;
-	if(n0>=f->nbox || n1>=f->nbox)
-		berror("_frfreebox");
-	n1++;
-	for(i=n0; i<n1; i++)
-		if(f->box[i].nrune >= 0)
-			free(f->box[i].a.ptr);
-}
-
-void
-_frgrowbox(Frame *f, int delta)
-{
-	f->nalloc += delta;
-	f->box = realloc(f->box, f->nalloc*sizeof(Frbox));
-	if(f->box == 0)
-		berror("_frgrowbox");
-}
-
-static
-void
-dupbox(Frame *f, int bn)
-{
-	uchar *p;
-
-	if(f->box[bn].nrune < 0)
-		berror("dupbox");
-	_fraddbox(f, bn, 1);
-	if(f->box[bn].nrune >= 0){
-		p = _frallocstr(NBYTE(&f->box[bn])+1);
-		strcpy((char*)p, (char*)f->box[bn].a.ptr);
-		f->box[bn+1].a.ptr = p;
-	}
-}
-
-static
-uchar*
-runeindex(uchar *p, int n)
-{
-	int i, w;
-	Rune rune;
-
-	for(i=0; i<n; i++,p+=w)
-		if(*p < Runeself)
-			w = 1;
-		else{
-			w = chartorune(&rune, (char*)p);
-			USED(rune);
-		}
-	return p;
-}
-
-static
-void
-truncatebox(Frame *f, Frbox *b, int n)	/* drop last n chars; no allocation done */
-{
-	if(b->nrune<0 || b->nrune<n)
-		berror("truncatebox");
-	b->nrune -= n;
-	runeindex(b->a.ptr, b->nrune)[0] = 0;
-	b->wid = strwidth(f->font, (char *)b->a.ptr);
-}
-
-static
-void
-chopbox(Frame *f, Frbox *b, int n)	/* drop first n chars; no allocation done */
-{
-	if(b->nrune<0 || b->nrune<n)
-		berror("chopbox");
-	strcpy((char*)b->a.ptr, (char*)runeindex(b->a.ptr, n));
-	b->nrune -= n;
-	b->wid = strwidth(f->font, (char *)b->a.ptr);
-}
-
-void
-_frsplitbox(Frame *f, int bn, int n)
-{
-	dupbox(f, bn);
-	truncatebox(f, &f->box[bn], f->box[bn].nrune-n);
-	chopbox(f, &f->box[bn+1], n);
-}
-
-void
-_frmergebox(Frame *f, int bn)		/* merge bn and bn+1 */
-{
-	Frbox *b;
-
-	b = &f->box[bn];
-	_frinsure(f, bn, NBYTE(&b[0])+NBYTE(&b[1])+1);
-	strcpy((char*)runeindex(b[0].a.ptr, b[0].nrune), (char*)b[1].a.ptr);
-	b[0].wid += b[1].wid;
-	b[0].nrune += b[1].nrune;
-	_frdelbox(f, bn+1, bn+1);
-}
-
-int
-_frfindbox(Frame *f, int bn, ulong p, ulong q)	/* find box containing q and put q on a box boundary */
-{
-	Frbox *b;
-
-	for(b = &f->box[bn]; bn<f->nbox && p+NRUNE(b)<=q; bn++, b++)
-		p += NRUNE(b);
-	if(p != q)
-		_frsplitbox(f, bn++, (int)(q-p));
-	return bn;
-}
//GO.SYSIN DD ./libframe/frbox.c
echo ./libframe/frdraw.c
sed s/.// > ./libframe/frdraw.c <<'//GO.SYSIN DD ./libframe/frdraw.c'
-#include <u.h>
-#include <libg.h>
-#include <frame.h>
-
-void
-_frredraw(Frame *f, Point pt)
-{
-	Frbox *b;
-	int nb;
-	for(nb=0,b=f->box; nb<f->nbox; nb++, b++){
-		_frcklinewrap(f, &pt, b);
-		if(b->nrune >= 0)
-			string(f->b, pt, f->font, (char *)b->a.ptr, S^D);
-		pt.x += b->wid;
-	}
-}
-
-Point
-_frdraw(Frame *f, Point pt)
-{
-	Frbox *b;
-	int nb, n;
-
-	for(b=f->box,nb=0; nb<f->nbox; nb++, b++){
-		_frcklinewrap0(f, &pt, b);
-		if(pt.y == f->r.max.y){
-			f->nchars -= _frstrlen(f, nb);
-			_frdelbox(f, nb, f->nbox-1);
-			break;
-		}
-		if(b->nrune > 0){
-			n = _frcanfit(f, pt, b);
-			if(n == 0)
-				berror("draw: _frcanfit==0");
-			if(n != b->nrune){
-				_frsplitbox(f, nb, n);
-				b = &f->box[nb];
-			}
-			pt.x += b->wid;
-		}else{
-			if(b->a.b.bc == '\n')
-				pt.x = f->left, pt.y+=f->font->height;
-			else
-				pt.x += _frnewwid(f, pt, b);
-		}
-	}
-	return pt;
-}
-int
-_frstrlen(Frame *f, int nb)
-{
-	int n;
-
-	for(n=0; nb<f->nbox; nb++)
-		n += NRUNE(&f->box[nb]);
-	return n;
-}
//GO.SYSIN DD ./libframe/frdraw.c
echo ./libframe/frdelete.c
sed s/.// > ./libframe/frdelete.c <<'//GO.SYSIN DD ./libframe/frdelete.c'
-#include <u.h>
-#include <libg.h>
-#include <frame.h>
-
-int
-frdelete(Frame *f, ulong p0, ulong p1)
-{
-	Point pt0, pt1, ppt0;
-	Frbox *b;
-	int n0, n1, n;
-	Rectangle r;
-	int nn0;
-
-	if(p0>=f->nchars || p0==p1 || f->b==0)
-		return 0;
-	if(p1 > f->nchars)
-		p1 = f->nchars;
-	n0 = _frfindbox(f, 0, (unsigned long)0, p0);
-	n1 = _frfindbox(f, n0, p0, p1);
-	pt0 = _frptofcharnb(f, p0, n0);
-	pt1 = frptofchar(f, p1);
-	if(f->p0!=p0 || f->p1!=p1)	/* likely they ARE equal */
-		frselectp(f, F&~D);	/* can do better some day */
-	frselectf(f, pt0, pt1, 0);
-	if(n0 == f->nbox)
-		berror("off end in frdelete");
-	nn0 = n0;
-	ppt0 = pt0;
-	_frfreebox(f, n0, n1-1);
-	f->modified = 1;
-
-	/*
-	 * Invariants:
-	 *  pt0 points to beginning, pt1 points to end
-	 *  n0 is box containing beginning of stuff being deleted
-	 *  n1, b are box containing beginning of stuff to be kept after deletion
-	 *  region between pt0 and pt1 is clear
-	 */
-	b = &f->box[n1];
-	while(pt1.x!=pt0.x && n1<f->nbox){
-		_frcklinewrap0(f, &pt0, b);
-		_frcklinewrap(f, &pt1, b);
-		if(b->nrune > 0){
-			n = _frcanfit(f, pt0, b);
-			if(n==0)
-				berror("_frcanfit==0");
-			if(n != b->nrune){
-				_frsplitbox(f, n1, n);
-				b = &f->box[n1];
-			}
-			r.min = pt1;
-			r.max = pt1;
-			r.max.x += b->wid;
-			r.max.y += f->font->height;
-			bitblt(f->b, pt0, f->b, r, S);
-			if(pt0.y == pt1.y)
-				r.min.x = r.max.x-(pt1.x-pt0.x);
-			bitblt(f->b, r.min, f->b, r, 0);
-		}
-		_fradvance(f, &pt1, b);
-		pt0.x += _frnewwid(f, pt0, b);
-		f->box[n0++] = f->box[n1++];
-		b++;
-	}
-	if(pt1.y != pt0.y){
-		Point pt2;
-
-		pt2 = _frptofcharptb(f, 32767, pt1, n1);
-		if(pt2.y > f->r.max.y)
-			berror("frptofchar in frdelete");
-		if(n1 < f->nbox){
-			int q0, q1, q2;
-
-			q0 = pt0.y+f->font->height;
-			q1 = pt1.y+f->font->height;
-			q2 = pt2.y+f->font->height;
-			bitblt(f->b, pt0, f->b, Rect(pt1.x, pt1.y, f->r.max.x, q1), S);
-			bitblt(f->b, Pt(f->r.min.x, q0), f->b, Rect(f->r.min.x, q1, f->r.max.x, q2), S);
-			frselectf(f, Pt(pt2.x, pt2.y-(pt1.y-pt0.y)), pt2, 0);
-		}else
-			frselectf(f, pt0, pt2, 0);
-	}
-	_frclosebox(f, n0, n1-1);
-	if(nn0>0 && f->box[nn0-1].nrune>=0 && ppt0.x-f->box[nn0-1].wid>=(int)f->left){
-		--nn0;
-		ppt0.x -= f->box[nn0].wid;
-	}
-	_frclean(f, ppt0, nn0, n0<f->nbox-1? n0+1 : n0);
-	if(f->p1 > p1)
-		f->p1 -= p1-p0;
-	else if(f->p1 > p0)
-		f->p1 = p0;
-	if(f->p0 > p1)
-		f->p0 -= p1-p0;
-	else if(f->p0 > p0)
-		f->p0 = p0;
-	frselectp(f, F&~D);
-	f->nchars -= p1-p0;
-	pt0 = frptofchar(f, f->nchars);
-	n = f->nlines;
-	f->nlines = (pt0.y-f->r.min.y)/f->font->height+(pt0.x>f->left);
-	return n - f->nlines;
-}
//GO.SYSIN DD ./libframe/frdelete.c
echo ./libframe/frinit.c
sed s/.// > ./libframe/frinit.c <<'//GO.SYSIN DD ./libframe/frinit.c'
-#include <u.h>
-#include <libg.h>
-#include <frame.h>
-
-void
-frinit(Frame *f, Rectangle r, Font *ft, Bitmap *b)
-{
-	f->font = ft;
-	f->maxtab = 8*charwidth(ft, '0');
-	f->nbox = 0;
-	f->nalloc = 0;
-	f->nchars = 0;
-	f->nlines = 0;
-	f->p0 = 0;
-	f->p1 = 0;
-	f->box = 0;
-	f->lastlinefull = 0;
-	frsetrects(f, r, b);
-}
-
-void
-frsetrects(Frame *f, Rectangle r, Bitmap *b)
-{
-	f->b = b;
-	f->entire = r;
-	f->r = r;
-	f->r.max.y -= (r.max.y-r.min.y)%f->font->height;
-	f->left = r.min.x+1;
-	f->maxlines = (r.max.y-r.min.y)/f->font->height;
-}
-
-void
-frclear(Frame *f)
-{
-	if(f->nbox)
-		_frdelbox(f, 0, f->nbox-1);
-	if(f->box)
-		free(f->box);
-	f->box = 0;
-}
//GO.SYSIN DD ./libframe/frinit.c
echo ./libframe/frinsert.c
sed s/.// > ./libframe/frinsert.c <<'//GO.SYSIN DD ./libframe/frinsert.c'
-#include <u.h>
-#include <libg.h>
-#include <frame.h>
-
-#define	DELTA	25
-#define	TMPSIZE	256
-static Frame		frame;
-
-static
-Point
-bxscan(Frame *f, Rune *sp, Rune *ep, Point *ppt)
-{
-	int w, c, nb, delta, nl, nr, rw;
-	Frbox *b;
-	char *s, tmp[TMPSIZE+3];	/* +3 for rune overflow */
-	uchar *p;
-
-	frame.r = f->r;
-	frame.b = f->b;
-	frame.font = f->font;
-	frame.maxtab = f->maxtab;
-	frame.left = f->left;
-	frame.nbox = 0;
-	frame.nchars = 0;
-	delta = DELTA;
-	nl = 0;
-	for(nb=0; sp<ep && nl<=f->maxlines; nb++,frame.nbox++){
-		if(nb == frame.nalloc){
-			_frgrowbox(&frame, delta);
-			if(delta < 10000)
-				delta *= 2;
-		}
-		b = &frame.box[nb];
-		c = *sp;
-		if(c=='\t' || c=='\n'){
-			b->a.b.bc = c;
-			b->wid = 5000;
-			b->a.b.minwid = (c=='\n')? 0 : charwidth(frame.font, ' ');
-			b->nrune = -1;
-			if(c=='\n')
-				nl++;
-			frame.nchars++;
-			sp++;
-		}else{
-			s = tmp;
-			nr = 0;
-			w = 0;
-			while(sp < ep){
-				rw = runetochar(s, sp);
-				if(s+rw >= tmp+TMPSIZE)
-					break;
-				w += charwidth(frame.font, c);
-				sp++;
-				s += rw;
-				nr++;
-				c = *sp;
-				if(c=='\t' || c=='\n')
-					break;
-			}
-			*s++ = 0;
-			p = _frallocstr(s-tmp);
-			b = &frame.box[nb];
-			b->a.ptr = p;
-			memmove(p, tmp, s-tmp);
-			b->wid = w;
-			b->nrune = nr;
-			frame.nchars += nr;
-		}
-	}
-	_frcklinewrap0(f, ppt, &frame.box[0]);
-	return _frdraw(&frame, *ppt);
-}
-
-static
-void
-chopframe(Frame *f, Point pt, ulong p, int bn)
-{
-	Frbox *b;
-
-	for(b = &f->box[bn]; ; b++){
-		if(b >= &f->box[f->nbox])
-			berror("endofframe");
-		_frcklinewrap(f, &pt, b);
-		if(pt.y >= f->r.max.y)
-			break;
-		p += NRUNE(b);
-		_fradvance(f, &pt, b);
-	}
-	f->nchars = p;
-	f->nlines = f->maxlines;
-	if(b<&f->box[f->nbox])				/* BUG */
-		_frdelbox(f, (int)(b-f->box), f->nbox-1);
-}
-
-void
-frinsert(Frame *f, Rune *sp, Rune *ep, ulong p0)
-{
-	Point pt0, pt1, ppt0, ppt1, pt;
-	Frbox *b;
-	int n, n0, nn0, y;
-	Rectangle r;
-	static struct{
-		Point pt0, pt1;
-	}*pts;
-	static int nalloc=0;
-	int npts;
-
-	if(p0>f->nchars || sp==ep || f->b==0)
-		return;
-	n0 = _frfindbox(f, 0, 0, p0);
-	nn0 = n0;
-	pt0 = _frptofcharnb(f, p0, n0);
-	ppt0 = pt0;
-	pt1 = bxscan(f, sp, ep, &ppt0);
-	ppt1 = pt1;
-	if(n0 < f->nbox){
-		_frcklinewrap(f, &pt0, b = &f->box[n0]);	/* for frselectf() */
-		_frcklinewrap0(f, &ppt1, b);
-	}
-	f->modified = 1;
-	/*
-	 * ppt0 and ppt1 are start and end of insertion as they will appear when
-	 * insertion is complete. pt0 is current location of insertion position
-	 * (p0); pt1 is terminal point (without line wrap) of insertion.
-	 */
-	if(p0==f->p0 && p0==f->p1)		/* quite likely */
-		frselectf(f, pt0, pt0, F&~D);
-	else
-		frselectp(f, F&~D);
-	/*
-	 * Find point where old and new x's line up
-	 * Invariants:
-	 *	pt0 is where the next box (b, n0) is now
-	 *	pt1 is where it will be after then insertion
-	 * If pt1 goes off the rectangle, we can toss everything from there on
-	 */
-	for(b = &f->box[n0],npts=0;
-	     pt1.x!=pt0.x && pt1.y!=f->r.max.y && n0<f->nbox; b++,n0++,npts++){
-		_frcklinewrap(f, &pt0, b);
-		_frcklinewrap0(f, &pt1, b);
-		if(b->nrune > 0){
-			n = _frcanfit(f, pt1, b);
-			if(n == 0)
-				berror("_frcanfit==0");
-			if(n != b->nrune){
-				_frsplitbox(f, n0, n);
-				b = &f->box[n0];
-			}
-		}
-		if(npts == nalloc){
-			pts = realloc(pts, (npts+DELTA)*sizeof(pts[0]));
-			nalloc += DELTA;
-			b = &f->box[n0];
-		}
-		pts[npts].pt0 = pt0;
-		pts[npts].pt1 = pt1;
-		/* has a text box overflowed off the frame? */
-		if(pt1.y == f->r.max.y)
-			break;
-		_fradvance(f, &pt0, b);
-		pt1.x += _frnewwid(f, pt1, b);
-	}
-	if(pt1.y > f->r.max.y)
-		berror("frinsert pt1 too far");
-	if(pt1.y==f->r.max.y && n0<f->nbox){
-		f->nchars -= _frstrlen(f, n0);
-		_frdelbox(f, n0, f->nbox-1);
-	}
-	if(n0 == f->nbox)
-		f->nlines = (pt1.y-f->r.min.y)/f->font->height+(pt1.x>f->left);
-	else if(pt1.y!=pt0.y){
-		int q0, q1;
-
-		y = f->r.max.y;
-		q0 = pt0.y+f->font->height;
-		q1 = pt1.y+f->font->height;
-		f->nlines += (q1-q0)/f->font->height;
-		if(f->nlines > f->maxlines)
-			chopframe(f, ppt1, p0, nn0);
-		if(pt1.y < y){
-			r = f->r;
-			r.min.y = q0;
-			r.max.y = y-(q1-q0);
-			if(q1 < y)
-				bitblt(f->b, Pt(f->r.min.x, q1), f->b, r, S);
-			r.min = pt0;
-			r.max.y = q0;
-			bitblt(f->b, pt1, f->b, r, S);
-		}
-	}
-	/*
-	 * Move the old stuff down to make room.  The loop will move the stuff
-	 * between the insertion and the point where the x's lined up.
-	 * The bitblts above moved everything down after the point they lined up.
-	 */
-	for((y=pt1.y==f->r.max.y?pt1.y:0),b = &f->box[n0-1]; --npts>=0; --b){
-		pt = pts[npts].pt1;
-		if(b->nrune > 0){
-			r.min = pts[npts].pt0;
-			r.max = r.min;
-			r.max.x += b->wid;
-			r.max.y += f->font->height;
-			bitblt(f->b, pt, f->b, r, S);
-			if(pt.y < y){	/* clear bit hanging off right */
-				r.min = pt;
-				r.max = pt;
-				r.min.x += b->wid;
-				r.max.x = f->r.max.x;
-				r.max.y += f->font->height;
-				bitblt(f->b, r.min, f->b, r, 0);
-			}
-			y = pt.y;
-		}else{
-			r.min = pt;
-			r.max = pt;
-			r.max.x += b->wid;
-			r.max.y += f->font->height;
-			if(r.max.x >= f->r.max.x)
-				r.max.x = f->r.max.x;
-			bitblt(f->b, r.min, f->b, r, 0);
-			y = (pt.x == f->left)? pt.y : 0;
-		}
-	}
-	frselectf(f, ppt0, ppt1, 0);
-	_frredraw(&frame, ppt0);
-	_fraddbox(f, nn0, frame.nbox);
-	for(n=0; n<frame.nbox; n++)
-		f->box[nn0+n] = frame.box[n];
-	if(nn0>0 && f->box[nn0-1].nrune>=0 && ppt0.x-f->box[nn0-1].wid>=(int)f->left){
-		--nn0;
-		ppt0.x -= f->box[nn0].wid;
-	}
-	n0 += frame.nbox;
-	_frclean(f, ppt0, nn0, n0<f->nbox-1? n0+1 : n0);
-	f->nchars += frame.nchars;
-	if(f->p0 >= p0)
-		f->p0 += frame.nchars;
-	if(f->p0 > f->nchars)
-		f->p0 = f->nchars;
-	if(f->p1 >= p0)
-		f->p1 += frame.nchars;
-	if(f->p1 > f->nchars)
-		f->p1 = f->nchars;
-	frselectp(f, F&~D);
-}
//GO.SYSIN DD ./libframe/frinsert.c
echo ./libframe/frptofchar.c
sed s/.// > ./libframe/frptofchar.c <<'//GO.SYSIN DD ./libframe/frptofchar.c'
-#include <u.h>
-#include <libg.h>
-#include <frame.h>
-
-Point
-_frptofcharptb(Frame *f, ulong p, Point pt, int bn)
-{
-	uchar *s;
-	Frbox *b;
-	int w, l;
-	Rune r;
-
-	for(b = &f->box[bn]; bn<f->nbox; bn++,b++){
-		_frcklinewrap(f, &pt, b);
-		if(p < (l=NRUNE(b))){
-			if(b->nrune > 0)
-				for(s=b->a.ptr; p>0; s+=w, p--){
-					if((r = *s) < Runeself)
-						w = 1;
-					else
-						w = chartorune(&r, (char*)s);
-					pt.x += charwidth(f->font, r);
-					if(r==0 || pt.x>f->r.max.x)
-						berror("frptofchar");
-				}
-			break;
-		}
-		p -= l;
-		_fradvance(f, &pt, b);
-	}
-	return pt;
-}
-
-Point
-frptofchar(Frame *f, ulong p)
-{
-	return _frptofcharptb(f, p, Pt(f->left, f->r.min.y), 0);
-}
-
-Point
-_frptofcharnb(Frame *f, ulong p, int nb)	/* doesn't do final _fradvance to next line */
-{
-	Point pt;
-	int nbox;
-
-	nbox = f->nbox;
-	f->nbox = nb;
-	pt = _frptofcharptb(f, p, Pt(f->left, f->r.min.y), 0);
-	f->nbox = nbox;
-	return pt;
-}
-
-static
-Point
-_frgrid(Frame *f, Point p)
-{
-	p.y -= f->r.min.y;
-	p.y -= p.y%f->font->height;
-	p.y += f->r.min.y;
-	if(p.x > f->r.max.x)
-		p.x = f->r.max.x;
-	return p;
-}
-
-ulong
-frcharofpt(Frame *f, Point pt)
-{
-	Point qt;
-	int w, bn;
-	uchar *s;
-	Frbox *b;
-	ulong p;
-	Rune r;
-
-	pt = _frgrid(f, pt);
-	qt.x = f->left;
-	qt.y = f->r.min.y;
-	for(b=f->box,bn=0,p=0; bn<f->nbox && qt.y<pt.y; bn++,b++){
-		_frcklinewrap(f, &qt, b);
-		if(qt.y >= pt.y)
-			break;
-		_fradvance(f, &qt, b);
-		p += NRUNE(b);
-	}
-	for(; bn<f->nbox && qt.x<=pt.x; bn++,b++){
-		_frcklinewrap(f, &qt, b);
-		if(qt.y > pt.y)
-			break;
-		if(qt.x+b->wid > pt.x){
-			if(b->nrune < 0)
-				_fradvance(f, &qt, b);
-			else{
-				s = b->a.ptr;
-				for(;;){
-					if((r = *s) < Runeself)
-						w = 1;
-					else
-						w = chartorune(&r, (char*)s);
-					if(r == 0)
-						berror("end of string in frcharofpt");
-					s += w;
-					qt.x += charwidth(f->font, r);
-					if(qt.x > pt.x)
-						break;
-					p++;
-				}
-			}
-		}else{
-			p += NRUNE(b);
-			_fradvance(f, &qt, b);
-		}
-	}
-	return p;
-}
//GO.SYSIN DD ./libframe/frptofchar.c
echo ./libframe/frselect.c
sed s/.// > ./libframe/frselect.c <<'//GO.SYSIN DD ./libframe/frselect.c'
-#include <u.h>
-#include <libg.h>
-#include <frame.h>
-
-void
-frselect(Frame *f, Mouse *m)	/* when called, button 1 is down */
-{
-	ulong p0, p1, q;
-	Point mp, pt0, pt1, qt;
-
-	mp = m->xy;
-
-    Again:
-	f->modified = 0;
-	frselectp(f, F&~D);
-	p0 = p1 = frcharofpt(f, mp);
-	pt0 = frptofchar(f, p0);
-	pt1 = frptofchar(f, p1);
-	frselectf(f, pt0, pt1, F&~D);
-	do{
-		if(f->modified)	/* special hack so 8 can frselect in parallel */
-			goto Again;
-		q = frcharofpt(f, m->xy);
-		if(p1 != q){
-			if(p0 == p1)
-				frselectf(f, pt0, pt1, F&~D);
-			qt = frptofchar(f, q);
-			if(p1 < q)
-				frselectf(f, pt1, qt, F&~D);
-			else
-				frselectf(f, qt, pt1, F&~D);
-			p1 = q;
-			pt1 = qt;
-			if(p0 == p1)
-				frselectf(f, pt0, pt1, F&~D);
-		}
-		f->modified = 0;
-		if(p0 < p1)
-			f->p0 = p0, f->p1 = p1;
-		else
-			f->p0 = p1, f->p1 = p0;
-		frgetmouse();
-	}while(m->buttons & 1);
-}
-/* it is assumed p0<=p1 and both were generated by frptofchar() */
-void
-frselectf(Frame *f, Point p0, Point p1, Fcode c)
-{
-	int n;
-	Point q0, q1;
-
-	if(p0.x == f->left)
-		p0.x = f->r.min.x;
-	if(p1.x == f->left)
-		p1.x = f->r.min.x;
-	q0 = p0;
-	q1 = p1;
-	q0.y += f->font->height;
-	q1.y += f->font->height;
-	n = (p1.y-p0.y)/f->font->height;
-	if(f->b == 0)
-		berror("frselectf b==0");
-	if(p0.y == f->r.max.y)
-		return;
-	if(n == 0){
-		if(p0.x == p1.x)
-			if(p0.x == f->r.min.x)
-				q1.x++;
-			else
-				p0.x--;
-		bitblt(f->b, p0, f->b, Rpt(p0, q1), c);
-	}else{
-		if(p0.x >= f->r.max.x)
-			p0.x = f->r.max.x-1;
-		bitblt(f->b, p0, f->b, Rect(p0.x, p0.y, f->r.max.x, q0.y), c);
-		if(n > 1)
-			bitblt(f->b, Pt(f->r.min.x, q0.y),
-				f->b, Rect(f->r.min.x, q0.y, f->r.max.x, p1.y), c);
-		bitblt(f->b, Pt(f->r.min.x, p1.y),
-				f->b, Rect(f->r.min.x, p1.y, q1.x, q1.y), c);
-	}
-}
-
-void
-frselectp(Frame *f, Fcode c)
-{
-	Point pt0, pt1;
-
-	pt0 = frptofchar(f, f->p0);
-	pt1 = (f->p0==f->p1)? pt0 : frptofchar(f, f->p1);
-	frselectf(f, pt0, pt1, c);
-}
//GO.SYSIN DD ./libframe/frselect.c
echo ./libframe/frstr.c
sed s/.// > ./libframe/frstr.c <<'//GO.SYSIN DD ./libframe/frstr.c'
-#include <u.h>
-#include <libg.h>
-#include <frame.h>
-
-/*
- * The code here and elsewhere requires that strings not be gcalloc()ed
- */
-
-#define	CHUNK	16
-#define	ROUNDUP(n)	((n+CHUNK)&~(CHUNK-1))
-
-uchar *
-_frallocstr(unsigned n)
-{
-	uchar *p;
-
-	p = malloc(ROUNDUP(n));
-	if(p == 0)
-		berror("out of memory");
-	return p;
-}
-
-void
-_frinsure(Frame *f, int bn, unsigned n)
-{
-	Frbox *b;
-	uchar *p;
-
-	b = &f->box[bn];
-	if(b->nrune < 0)
-		berror("_frinsure");
-	if(ROUNDUP(b->nrune) > n)	/* > guarantees room for terminal NUL */
-		return;
-	p = _frallocstr(n);
-	b = &f->box[bn];
-	memmove(p, b->a.ptr, NBYTE(b)+1);
-	free(b->a.ptr);
-	b->a.ptr = p;
-}
//GO.SYSIN DD ./libframe/frstr.c
echo ./libframe/frutil.c
sed s/.// > ./libframe/frutil.c <<'//GO.SYSIN DD ./libframe/frutil.c'
-#include <u.h>
-#include <libg.h>
-#include <frame.h>
-
-int
-_frcanfit(Frame *f, Point pt, Frbox *b)
-{
-	int left, w, nr;
-	uchar *p;
-	Rune r;
-
-	left = f->r.max.x-pt.x;
-	if(b->nrune < 0)
-		return b->a.b.minwid <= left;
-	if(left >= b->wid)
-		return b->nrune;
-	for(nr=0,p=b->a.ptr; *p; p+=w,nr++){
-		r = *p;
-		if(r < Runeself)
-			w = 1;
-		else
-			w = chartorune(&r, (char*)p);
-		left -= charwidth(f->font, r);
-		if(left < 0)
-			return nr;
-	}
-	berror("_frcanfit can't");
-	return 0;
-}
-
-void
-_frcklinewrap(Frame *f, Point *p, Frbox *b)
-{
-	if((b->nrune<0? b->a.b.minwid : b->wid) > f->r.max.x-p->x){
-		p->x = f->left;
-		p->y += f->font->height;
-	}
-}
-
-void
-_frcklinewrap0(Frame *f, Point *p, Frbox *b)
-{
-	if(_frcanfit(f, *p, b) == 0){
-		p->x = f->left;
-		p->y += f->font->height;
-	}
-}
-
-void
-_fradvance(Frame *f, Point *p, Frbox *b)
-{
-	if(b->nrune<0 && b->a.b.bc=='\n'){
-		p->x = f->left;
-		p->y += f->font->height;
-	}else
-		p->x += b->wid;
-}
-
-int
-_frnewwid(Frame *f, Point pt, Frbox *b)
-{
-	int c, x;
-
-	c = f->r.max.x;
-	x = pt.x;
-	if(b->nrune >= 0)
-		return b->wid;
-	if(b->a.b.bc == '\t'){
-		if(x+b->a.b.minwid > c)
-			x = pt.x = f->left;
-		x += f->maxtab;
-		x -= (x-f->left)%f->maxtab;
-		if(x-pt.x<b->a.b.minwid || x>c)
-			x = pt.x+b->a.b.minwid;
-		b->wid = x-pt.x;
-	}
-	return b->wid;
-}
-
-void
-_frclean(Frame *f, Point pt, int n0, int n1)	/* look for mergeable boxes */
-{
-	Frbox *b;
-	int nb, c;
-
-	c = f->r.max.x;
-	for(nb=n0; nb<n1-1; nb++){
-		b = &f->box[nb];
-		_frcklinewrap(f, &pt, b);
-		while(b[0].nrune>=0 && nb<n1-1 && b[1].nrune>=0 && pt.x+b[0].wid+b[1].wid<c){
-			_frmergebox(f, nb);
-			n1--;
-			b = &f->box[nb];
-		}
-		_fradvance(f, &pt, &f->box[nb]);
-	}
-	for(; nb<f->nbox; nb++){
-		b = &f->box[nb];
-		_frcklinewrap(f, &pt, b);
-		_fradvance(f, &pt, &f->box[nb]);
-	}
-	f->lastlinefull = 0;
-	if(pt.y >= f->r.max.y)
-		f->lastlinefull = 1;
-}
//GO.SYSIN DD ./libframe/frutil.c
echo ./libframe/frame.h
sed s/.// > ./libframe/frame.h <<'//GO.SYSIN DD ./libframe/frame.h'
-#pragma	lib	"libframe.a"
-
-typedef struct Frbox Frbox;
-typedef struct Frame Frame;
-
-struct Frbox
-{
-	long		wid;		/* in pixels */
-	long		nrune;		/* <0 ==> negate and treat as break char */
-	union{
-		uchar	*ptr;
-		struct{
-			short	bc;	/* break char */
-			short	minwid;
-		}b;
-	}a;
-};
-
-struct Frame
-{
-	Font		*font;		/* of chars in the frame */
-	Bitmap		*b;		/* on which frame appears */
-	Rectangle	r;		/* in which text appears */
-	Rectangle	entire;		/* of full frame */
-	Frbox		*box;
-	ulong		p0, p1;		/* selection */
-	short		left;		/* left edge of text */
-	ushort		nbox, nalloc;
-	ushort		maxtab;		/* max size of tab, in pixels */
-	ushort		nchars;		/* # runes in frame */
-	ushort		nlines;		/* # lines with text */
-	ushort		maxlines;	/* total # lines in frame */
-	ushort		lastlinefull;	/* last line fills frame */
-	ushort		modified;	/* changed since frselect() */
-};
-
-ulong	frcharofpt(Frame*, Point);
-Point	frptofchar(Frame*, ulong);
-int	frdelete(Frame*, ulong, ulong);
-void	frinsert(Frame*, Rune*, Rune*, ulong);
-void	frselect(Frame*, Mouse*);
-void	frselectp(Frame*, Fcode);
-void	frselectf(Frame*, Point, Point, Fcode);
-void	frinit(Frame*, Rectangle, Font*, Bitmap*);
-void	frsetrects(Frame*, Rectangle, Bitmap*);
-void	frclear(Frame*);
-void	frgetmouse(void);
-
-uchar	*_frallocstr(unsigned);
-void	_frinsure(Frame*, int, unsigned);
-Point	_frdraw(Frame*, Point);
-void	_frgrowbox(Frame*, int);
-void	_frfreebox(Frame*, int, int);
-void	_frmergebox(Frame*, int);
-void	_frdelbox(Frame*, int, int);
-void	_frsplitbox(Frame*, int, int);
-int	_frfindbox(Frame*, int, ulong, ulong);
-void	_frclosebox(Frame*, int, int);
-int	_frcanfit(Frame*, Point, Frbox*);
-void	_frcklinewrap(Frame*, Point*, Frbox*);
-void	_frcklinewrap0(Frame*, Point*, Frbox*);
-void	_fradvance(Frame*, Point*, Frbox*);
-int	_frnewwid(Frame*, Point, Frbox*);
-void	_frclean(Frame*, Point, int, int);
-void	_frredraw(Frame*, Point);
-void	_fraddbox(Frame*, int, int);
-Point	_frptofcharptb(Frame*, ulong, Point, int);
-Point	_frptofcharnb(Frame*, ulong, int);
-int	_frstrlen(Frame*, int);
-
-#define	NRUNE(b)	((b)->nrune<0? 1 : (b)->nrune)
-#define	NBYTE(b)	strlen((char*)(b)->a.ptr)
//GO.SYSIN DD ./libframe/frame.h
echo ./libframe/misc.c
sed s/.// > ./libframe/misc.c <<'//GO.SYSIN DD ./libframe/misc.c'
-#include	<u.h>
-#ifdef	NEEDSTDARG
-#include	<stdarg.h>
-#endif
-#ifdef	NEEDVARARG
-#include	<varargs.h>
-#endif
-
-void
-fprint(int fd, char *z, ...)
-{
-	va_list args;
-	char buf[2048];			/* pick reasonable blocksize */
-
-	va_start(args, z);
-	vsprintf(buf, z, args);
-	write(fd, buf, strlen(buf));
-	va_end(args);
-}
-
-int errstr(char *buf)
-{
-	extern int errno;
-
-	strncpy(buf, strerror(errno), ERRLEN);
-	return 1;
-}
-
-#ifdef NEEDSTRERROR
-char *
-strerror(int n)
-{
-	extern char *sys_errlist[];
-	return sys_errlist[n];
-}
-#endif /* NEEDSTRERROR */
-
-
-#ifdef NEEDMEMMOVE
-/*
- * memcpy is probably fast, but may not work with overlap
- */
-void*
-memmove(void *a1, const void *a2, size_t n)
-{
-	char *s1;
-	const char *s2;
-
-	s1 = a1;
-	s2 = a2;
-	if(s1 > s2)
-		goto back;
-	if(s1 + n <= s2)
-		return memcpy(a1, a2, n);
-	while(n > 0) {
-		*s1++ = *s2++;
-		n--;
-	}
-	return a1;
-
-back:
-	s2 += n;
-	if(s2 <= s1)
-		return memcpy(a1, a2, n);
-	s1 += n;
-	while(n > 0) {
-		*--s1 = *--s2;
-		n--;
-	}
-	return a1;
-}
-#endif /* NEEDMEMMOVE */
//GO.SYSIN DD ./libframe/misc.c
echo ./libframe/rune.c
sed s/.// > ./libframe/rune.c <<'//GO.SYSIN DD ./libframe/rune.c'
-#include	<u.h>
-
-enum
-{
-	Bit1	= 7,
-	Bitx	= 6,
-	Bit2	= 5,
-	Bit3	= 4,
-	Bit4	= 3,
-
-	T1	= ((1<<(Bit1+1))-1) ^ 0xFF,	/* 0000 0000 */
-	Tx	= ((1<<(Bitx+1))-1) ^ 0xFF,	/* 1000 0000 */
-	T2	= ((1<<(Bit2+1))-1) ^ 0xFF,	/* 1100 0000 */
-	T3	= ((1<<(Bit3+1))-1) ^ 0xFF,	/* 1110 0000 */
-	T4	= ((1<<(Bit4+1))-1) ^ 0xFF,	/* 1111 0000 */
-
-	Rune1	= (1<<(Bit1+0*Bitx))-1,		/* 0000 0000 0111 1111 */
-	Rune2	= (1<<(Bit2+1*Bitx))-1,		/* 0000 0111 1111 1111 */
-	Rune3	= (1<<(Bit3+2*Bitx))-1,		/* 1111 1111 1111 1111 */
-
-	Maskx	= (1<<Bitx)-1,			/* 0011 1111 */
-	Testx	= Maskx ^ 0xFF,			/* 1100 0000 */
-
-	Bad	= Runeerror
-};
-
-int
-chartorune(Rune *rune, char *str)
-{
-	int c, c1, c2;
-	long l;
-
-	/*
-	 * one character sequence
-	 *	00000-0007F => T1
-	 */
-	c = *(uchar*)str;
-	if(c < Tx) {
-		*rune = c;
-		return 1;
-	}
-
-	/*
-	 * two character sequence
-	 *	0080-07FF => T2 Tx
-	 */
-	c1 = *(uchar*)(str+1) ^ Tx;
-	if(c1 & Testx)
-		goto bad;
-	if(c < T3) {
-		if(c < T2)
-			goto bad;
-		l = ((c << Bitx) | c1) & Rune2;
-		if(l <= Rune1)
-			goto bad;
-		*rune = l;
-		return 2;
-	}
-
-	/*
-	 * three character sequence
-	 *	0800-FFFF => T3 Tx Tx
-	 */
-	c2 = *(uchar*)(str+2) ^ Tx;
-	if(c2 & Testx)
-		goto bad;
-	if(c < T4) {
-		l = ((((c << Bitx) | c1) << Bitx) | c2) & Rune3;
-		if(l <= Rune2)
-			goto bad;
-		*rune = l;
-		return 3;
-	}
-
-	/*
-	 * bad decoding
-	 */
-bad:
-	*rune = Bad;
-	return 1;
-}
-
-int
-runetochar(char *str, Rune *rune)
-{
-	long c;
-
-	/*
-	 * one character sequence
-	 *	00000-0007F => 00-7F
-	 */
-	c = *rune;
-	if(c <= Rune1) {
-		str[0] = c;
-		return 1;
-	}
-
-	/*
-	 * two character sequence
-	 *	0080-07FF => T2 Tx
-	 */
-	if(c <= Rune2) {
-		str[0] = T2 | (c >> 1*Bitx);
-		str[1] = Tx | (c & Maskx);
-		return 2;
-	}
-
-	/*
-	 * three character sequence
-	 *	0800-FFFF => T3 Tx Tx
-	 */
-	str[0] = T3 |  (c >> 2*Bitx);
-	str[1] = Tx | ((c >> 1*Bitx) & Maskx);
-	str[2] = Tx |  (c & Maskx);
-	return 3;
-}
-
-int
-runelen(long c)
-{
-	Rune rune;
-	char str[10];
-
-	rune = c;
-	return runetochar(str, &rune);
-}
-
-int
-fullrune(char *str, int n)
-{
-	int c;
-
-	if(n > 0) {
-		c = *(uchar*)str;
-		if(c < Tx)
-			return 1;
-		if(n > 1)
-			if(c < T3 || n > 2)
-				return 1;
-	}
-	return 0;
-}
-
-char*
-utfrune(char *s, long c)
-{
-	long c1;
-	Rune r;
-	int n;
-
-	if(c < Runesync)		/* not part of utf sequence */
-		return strchr(s, c);
-
-	for(;;) {
-		c1 = *(uchar*)s;
-		if(c1 < Runeself) {	/* one byte rune */
-			if(c1 == 0)
-				return 0;
-			if(c1 == c)
-				return s;
-			s++;
-			continue;
-		}
-		n = chartorune(&r, s);
-		if(r == c)
-			return s;
-		s += n;
-	}
-	return 0;
-}
-
-long
-utflen(char *s)
-{
-	int c;
-	long n;
-	Rune rune;
-
-	n = 0;
-	for(;;) {
-		c = *(uchar*)s;
-		if(c < Runeself) {
-			if(c == 0)
-				return n;
-			s++;
-		} else
-			s += chartorune(&rune, s);
-		n++;
-	}
-	return 0;
-}
//GO.SYSIN DD ./libframe/rune.c
echo ./libframe/u.h
sed s/.// > ./libframe/u.h <<'//GO.SYSIN DD ./libframe/u.h'
-#include <stdlib.h>
-#include <string.h>
-#include <sys/types.h>
-#include <setjmp.h>
-#include <stdio.h>
-#include <unistd.h>
-#include <fcntl.h>
-
-#ifndef	__sgi
-typedef	unsigned short	ushort;
-typedef unsigned long	ulong;
-#endif
-typedef	unsigned char	uchar;
-
-typedef	ushort	Rune;
-
-#define	sprint				sprintf
-#define	dup(a,b)			dup2(a,b)
-#define	seek(a,b,c)			lseek(a,b,c)
-#define	create(name, mode, perm)	creat(name, perm)
-#define	exec(a,b)			execv(a,b)
-#define	USED(a)
-#define SET(a)
-
-#define	exits(v)			if (v) exit(1); else exit(0)
-#define	_exits(v)			if (v) _exit(1); else _exit(0)
-
-enum
-{
-	OREAD	=	0,		/* open for read */
-	OWRITE	=	1,		/* open for write */
-	ORDWR	=	2,		/* open for read/write */
-	ERRLEN	=	64		/* length of error message */
-};
-
-enum
-{
-	UTFmax		= 3,		/* maximum bytes per rune */
-	Runesync	= 0x21,		/* cannot represent part of a utf sequence (<) */
-	Runeself	= 0xA0,		/* rune and utf sequences are the same (<) */
-	Runeerror	= 0x80		/* decoding error in utf */
-};
-
-/*
- * new rune routines
- */
-extern	int	runetochar(char*, Rune*);
-extern	int	chartorune(Rune*, char*);
-extern	int	runelen(long);
-extern	int	fullrune(char*, int);
-
-/*
- * rune routines from converted str routines
- */
-extern	long	utflen(char*);		/* was countrune */
-extern	char*	utfrune(char*, long);
-extern	char*	utfrrune(char*, long);
-extern	char*	utfutf(char*, char*);
-/*
- *	Miscellaneous functions
- */
-extern	void	fprint(int, char *, ...);
-extern	int	notify (void(*)(void *, char *));
-extern	int	errstr(char *);
-
-#ifdef	SYSVR3
-#include	<malloc.h>
-#define	remove(v)			unlink(v)
-#define	WEXITSTATUS(s)			(((s)>>8)&0xFF)
-extern	char *getenv(char*);
-extern	char *getlogin(void);
-extern	char *strerror(int);
-extern	void *memmove(void*, const void*, size_t);
-#define	NEEDMEMMOVE
-#define	NEEDSTRERROR
-#define	NEEDVARARG
-#endif	/* SYSVR3 */
-
-#ifdef	IRIX
-extern	void *memmove(void*, const void*, size_t);
-#define	NEEDMEMMOVE
-#define	NEEDSTDARG
-#endif	/* IRIX */
-
-#ifdef	UMIPS
-#define	const				/* mips compiler doesn't support const */
-extern	char *strerror(int);
-extern	void *memmove(void*, const void*, size_t);
-#define	NEEDMEMMOVE
-#define	NEEDSTRERROR
-#define	NEEDVARARG
-#endif	/* UMIPS */
-
-#ifdef	SUNOS
-extern	char *strerror(int);
-extern	void *memmove(void*, const void*, size_t);
-#define	NEEDMEMMOVE
-#define	NEEDSTRERROR
-#define	NEEDSTDARG
-#endif	/* SUNOS */
//GO.SYSIN DD ./libframe/u.h
echo ./libXg/Gwin.h
sed s/.// > ./libXg/Gwin.h <<'//GO.SYSIN DD ./libXg/Gwin.h'
-#ifndef GWIN_H
-#define GWIN_H
-
-/* New resource names */
-
-#define XtNscrollForwardR "scrollForwardR"
-#define XtCScrollForwardR "ScrollForwardR"
-#define XtNreshaped "reshaped"
-#define XtCReshaped "Reshaped"
-#define XtNgotchar "gotchar"
-#define XtCGotchar "Gotchar"
-#define XtNgotmouse "gotmouse"
-#define XtCGotmouse "Gotmouse"
-
-/* External reference to the class record pointer */
-extern WidgetClass gwinWidgetClass;
-
-/* Type definition for gwin widgets */
-typedef struct _GwinRec *GwinWidget;
-
-/* Type definition for gwin resources */
-typedef struct {
-		int buttons;
-		struct {
-			int x;
-			int y;
-		} xy;
-		unsigned long msec;
-	} Gwinmouse;
-
-typedef void (*Reshapefunc)(int, int, int, int);
-typedef void (*Charfunc)(int);
-typedef void (*Mousefunc)(Gwinmouse*);
-
-/* Method declarations */
-extern String GwinSelectionSwap(Widget, String);
-
-#endif /* GWIN_H */
//GO.SYSIN DD ./libXg/Gwin.h
echo ./libXg/GwinP.h
sed s/.// > ./libXg/GwinP.h <<'//GO.SYSIN DD ./libXg/GwinP.h'
-#ifndef GWINP_H
-#define GWINP_H
-
-#include "Gwin.h"
-
-/* Gwin is derived from Core */
-
-/* Gwin instance part */
-typedef struct {
-	/* New resource fields */
-	Pixel		foreground;
-	Font		font;
-	Boolean		forwardr;	/* does right button scroll forward? */
-	Reshapefunc	reshaped;	/* Notify app of reshape */
-	Charfunc	gotchar;	/* Notify app of char arrival */
-	Mousefunc	gotmouse;	/* Notify app of mouse change */
-	String		selection;	/* Current selection */
-} GwinPart;
-
-/* Full instance record */
-typedef struct _GwinRec {
-	CorePart	core;
-	GwinPart	gwin;
-} GwinRec;
-
-/* New type for class methods */
-typedef String (*SelSwapProc)(Widget, String);
-
-/* Class part */
-typedef struct {
-	SelSwapProc	select_swap;
-	XtPointer	extension;
-} GwinClassPart;
-
-/* Full class record */
-typedef struct _GwinClassRec {
-	CoreClassPart	core_class;
-	GwinClassPart	gwin_class;
-} GwinClassRec, *GwinWidgetClass;
-
-/* External definition for class record */
-extern GwinClassRec gwinClassRec;
-
-#endif /* GWINP_H */
//GO.SYSIN DD ./libXg/GwinP.h
echo ./libXg/arc.c
sed s/.// > ./libXg/arc.c <<'//GO.SYSIN DD ./libXg/arc.c'
-#include "libg.h"
-#include "libgint.h"
-#include <math.h>
-
-#define rad2deg(x) 180*((x)/3.1415926535897932384626433832795028841971693993751)
-
-void
-arc(Bitmap *b, Point p0, Point p1, Point p2, int v, Fcode f)
-{
-	unsigned int d;
-	int x, y, r, start, end, delta;
-	GC g;
-
-	p1.x -= p0.x;
-	p1.y -= p0.y;
-	p2.x -= p0.x;
-	p2.y -= p0.y;
-	r = (int)sqrt((double)(p1.x*p1.x + p1.y*p1.y));
-	start = (int)(64*rad2deg(atan2(-p2.y, p2.x)));
-	end = (int)(64*rad2deg(atan2(-p1.y, p1.x)));
-	if(start < 0)
-		start += 64*360;
-	if(end < 0)
-		end += 64*360;
-	delta = end - start;
-	if(delta < 0)
-		delta += 64*360;
-	x = p0.x - r;
-	y = p0.y - r;
-	if(b->flag&SHIFT){
-		x -= b->r.min.x;
-		y -= b->r.min.y;
-	}
-	d = 2*r;
-	g = _getfillgc(f, b, v);
-	/*
-	 * delta is positive, so this draws counterclockwise arc
-	 * from start to start+delta
-	 */
-	XDrawArc(_dpy, (Drawable)b->id, g, x, y, d, d, start, delta);
-}
-
//GO.SYSIN DD ./libXg/arc.c
echo ./libXg/arith.c
sed s/.// > ./libXg/arith.c <<'//GO.SYSIN DD ./libXg/arith.c'
-#include "libg.h"
-
-Point
-add(Point a, Point b)
-{
-	a.x += b.x;
-	a.y += b.y;
-	return a;
-}
-
-Point
-sub(Point a, Point b)
-{
-	a.x -= b.x;
-	a.y -= b.y;
-	return a;
-}
-
-Rectangle
-inset(Rectangle r, int n)
-{
-	r.min.x += n;
-	r.min.y += n;
-	r.max.x -= n;
-	r.max.y -= n;
-	return r;
-}
-
-Point
-divpt(Point a, int b)
-{
-	a.x /= b;
-	a.y /= b;
-	return a;
-}
-
-Point
-mul(Point a, int b)
-{
-	a.x *= b;
-	a.y *= b;
-	return a;
-}
-
-Rectangle
-rsubp(Rectangle r, Point p)
-{
-	r.min.x -= p.x;
-	r.min.y -= p.y;
-	r.max.x -= p.x;
-	r.max.y -= p.y;
-	return r;
-}
-
-Rectangle
-raddp(Rectangle r, Point p)
-{
-	r.min.x += p.x;
-	r.min.y += p.y;
-	r.max.x += p.x;
-	r.max.y += p.y;
-	return r;
-}
-
-Rectangle
-rmul(Rectangle r, int a)
-{
-	if (a != 1) {
-		r.min.x *= a;
-		r.min.y *= a;
-		r.max.x *= a;
-		r.max.y *= a;
-	}
-	return r;
-}
-
-Rectangle
-rdiv(Rectangle r, int a)
-{
-	if (a != 1) {
-		r.min.x /= a;
-		r.min.y /= a;
-		r.max.x /= a;
-		r.max.y /= a;
-	}
-	return r;
-}
-
-Rectangle
-rshift(Rectangle r, int a)
-{
-	if (a > 0) {
-		r.min.x <<= a;
-		r.min.y <<= a;
-		r.max.x <<= a;
-		r.max.y <<= a;
-	}
-	else if (a < 0) {
-		a = -a;
-		r.min.x >>= a;
-		r.min.y >>= a;
-		r.max.x >>= a;
-		r.max.y >>= a;
-	}
-	return r;
-}
-
-eqpt(Point p, Point q)
-{
-	return p.x==q.x && p.y==q.y;
-}
-
-eqrect(Rectangle r, Rectangle s)
-{
-	return r.min.x==s.min.x && r.max.x==s.max.x &&
-	       r.min.y==s.min.y && r.max.y==s.max.y;
-}
-
-rectXrect(Rectangle r, Rectangle s)
-{
-	return r.min.x<s.max.x && s.min.x<r.max.x &&
-	       r.min.y<s.max.y && s.min.y<r.max.y;
-}
-
-ptinrect(Point p, Rectangle r)
-{
-	return p.x>=r.min.x && p.x<r.max.x &&
-	       p.y>=r.min.y && p.y<r.max.y;
-}
-
-Rectangle
-rcanon(Rectangle r)
-{
-	int t;
-	if (r.max.x < r.min.x) {
-		t = r.min.x;
-		r.min.x = r.max.x;
-		r.max.x = t;
-	}
-	if (r.max.y < r.min.y) {
-		t = r.min.y;
-		r.min.y = r.max.y;
-		r.max.y = t;
-	}
-	return r;
-}
-
-Rectangle
-Rect(int x1, int y1, int x2, int y2)
-{
-	Rectangle r;
-
-	r.min.x = x1;
-	r.min.y = y1;
-	r.max.x = x2;
-	r.max.y = y2;
-	return r;
-}
-
-Rectangle
-Rpt(Point p1, Point p2)
-{
-	Rectangle r;
-
-	r.min = p1;
-	r.max = p2;
-	return r;
-}
-
-Point
-Pt(int x, int y)
-{
-	Point p;
-
-	p.x = x;
-	p.y = y;
-	return p;
-}
//GO.SYSIN DD ./libXg/arith.c
echo ./libXg/balloc.c
sed s/.// > ./libXg/balloc.c <<'//GO.SYSIN DD ./libXg/balloc.c'
-#include "libg.h"
-#include "libgint.h"
-
-Bitmap*
-balloc(Rectangle r, int ldepth)
-{
-	Bitmap *b;
-
-	b = _balloc(r, ldepth);
-	bitblt(b, r.min, b, r, Zero);
-	return b;
-}
-
-Bitmap*
-_balloc(Rectangle r, int ldepth)
-{
-	int id;
-	Bitmap *b;
-
-	b = (Bitmap *)malloc(sizeof(Bitmap));
-	if(b == 0)
-		berror("balloc malloc");
-	if(!(ldepth == 0 || ldepth == screen.ldepth))
-		berror("balloc unsupported ldepth");
-	id = (int) XCreatePixmap(_dpy, (Drawable)screen.id,
-			Dx(r), Dy(r), _ld2d[ldepth]);
-	b->ldepth = ldepth;
-	b->r = r;
-	b->clipr = r;
-	b->id = id;
-	b->cache = 0;
-	if(ldepth == 0)
-		b->flag = DP1|BL1;
-	else
-		b->flag = screen.flag&BL1;
-	if(r.min.x==0 && r.min.y ==0)
-		b->flag |= ZORG;
-	else
-		b->flag |= SHIFT;
-	return b;
-}
-
-void
-bfree(Bitmap *b)
-{
-	XFreePixmap(_dpy, (Pixmap)b->id);
-	free(b);
-}
//GO.SYSIN DD ./libXg/balloc.c
echo ./libXg/bitblt.c
sed s/.// > ./libXg/bitblt.c <<'//GO.SYSIN DD ./libXg/bitblt.c'
-#include "libg.h"
-#include "libgint.h"
-
-void
-bitblt(Bitmap *d, Point p, Bitmap *s, Rectangle r, Fcode f)
-{
-	int sx, sy, dx, dy, bfunc;
-	GC g;
-	unsigned long plane;
-	Bitmap *btmp;
-
-	if(Dx(r)<=0 || Dy(r)<=0)
-		return;
-	sx = r.min.x;
-	sy = r.min.y;
-	if(s->flag&SHIFT){
-		sx -= s->r.min.x;
-		sy -= s->r.min.y;
-	}
-	dx = p.x;
-	dy = p.y;
-	if(d->flag&SHIFT){
-		dx -= d->r.min.x;
-		dy -= d->r.min.y;
-	}
-	g = _getcopygc(f, d, s, &bfunc);
-	if(bfunc == UseCopyArea)
-		XCopyArea(_dpy, (Drawable)s->id, (Drawable)d->id, g,
-			sx, sy, Dx(r), Dy(r), dx, dy);
-	else if(bfunc == UseFillRectangle){
-		XFillRectangle(_dpy, (Drawable)s->id, g,
-			dx, dy, Dx(r), Dy(r));
-	}else{
-		/* bfunc == UseCopyPlane */
-		plane = _ld2dmask[s->ldepth];
-		plane &= ~(plane>>1);
-		if(0/*f == S*/)
-			XCopyPlane(_dpy, (Drawable)s->id, (Drawable)d->id, g,
-				sx, sy, Dx(r), Dy(r), dx, dy, plane);
-		else {
-			/*
-			 * CopyPlane can only do func code S,
-			 * so copy src rect into a bitmap with the same depth
-			 * as the dest, then do the bitblt from the tmp.
-			 * This won't recurse again because we only get
-			 * UseCopyPlane with differing bitmap depths
-			 */
-			btmp = _balloc(Rect(0,0,Dx(r),Dy(r)), d->ldepth);
-			XCopyPlane(_dpy, (Drawable)s->id, (Drawable)btmp->id, g,
-				sx, sy, Dx(r), Dy(r), 0, 0, plane);
-			bitblt(d, p, btmp, btmp->r, f);
-			bfree(btmp);
-		}
-	}
-
-}
//GO.SYSIN DD ./libXg/bitblt.c
echo ./libXg/bitbltclip.c
sed s/.// > ./libXg/bitbltclip.c <<'//GO.SYSIN DD ./libXg/bitbltclip.c'
-#include "libg.h"
-
-void
-bitbltclip(void *vp)
-{
-	int dx, dy;
-	int i;
-	struct bbcarg {
-		Bitmap *dm;
-		Point p;
-		Bitmap *sm;
-		Rectangle r;
-		Fcode f;
-	}*bp = (struct bbcarg *)vp;
-	dx = Dx(bp->r);
-	dy = Dy(bp->r);
-	if(bp->p.x < bp->dm->r.min.x){
-		i = bp->dm->r.min.x-bp->p.x;
-		bp->r.min.x += i;
-		bp->p.x += i;
-		dx -= i;
-	}
-	if(bp->p.y < bp->dm->r.min.y){
-		i = bp->dm->r.min.y-bp->p.y;
-		bp->r.min.y += i;
-		bp->p.y += i;
-		dy -= i;
-	}
-	if(bp->p.x+dx > bp->dm->r.max.x)
-		bp->r.max.x -= bp->p.x+dx-bp->dm->r.max.x;
-	if(bp->p.y+dy > bp->dm->r.max.y)
-		bp->r.max.y -= bp->p.y+dy-bp->dm->r.max.y;
-	if(bp->r.min.x < bp->sm->r.min.x){
-		i = bp->sm->r.min.x-bp->r.min.x;
-		bp->p.x += i;
-		bp->r.min.x += i;
-	}
-	if(bp->r.min.y < bp->sm->r.min.y){
-		i = bp->sm->r.min.y-bp->r.min.y;
-		bp->p.y += i;
-		bp->r.min.y += i;
-	}
-	if(bp->r.max.x > bp->sm->r.max.x)
-		bp->r.max.x = bp->sm->r.max.x;
-	if(bp->r.max.y > bp->sm->r.max.y)
-		bp->r.max.y = bp->sm->r.max.y;
-}
//GO.SYSIN DD ./libXg/bitbltclip.c
echo ./libXg/border.c
sed s/.// > ./libXg/border.c <<'//GO.SYSIN DD ./libXg/border.c'
-#include "libg.h"
-
-void
-border(Bitmap *l, Rectangle r, int i, Fcode c)
-{
-	if(i > 0){
-		bitblt(l, r.min,
-			l, Rect(r.min.x, r.min.y, r.max.x, r.min.y+i), c);
-		bitblt(l, Pt(r.min.x, r.max.y-i),
-			l, Rect(r.min.x, r.max.y-i, r.max.x, r.max.y), c);
-		bitblt(l, Pt(r.min.x, r.min.y+i),
-			l, Rect(r.min.x, r.min.y+i, r.min.x+i, r.max.y-i), c);
-		bitblt(l, Pt(r.max.x-i, r.min.y+i),
-			l, Rect(r.max.x-i, r.min.y+i, r.max.x, r.max.y-i), c);
-	}else if(i < 0){
-		bitblt(l, Pt(r.min.x, r.min.y+i),
-			l, Rect(r.min.x, r.min.y+i, r.max.x, r.min.y), c);
-		bitblt(l, Pt(r.min.x, r.max.y),
-			l, Rect(r.min.x, r.max.y, r.max.x, r.max.y-i), c);
-		bitblt(l, Pt(r.min.x+i, r.min.y+i),
-			l, Rect(r.min.x+i, r.min.y+i, r.min.x, r.max.y-i), c);
-		bitblt(l, Pt(r.max.x, r.min.y+i),
-			l, Rect(r.max.x, r.min.y+i, r.max.x-i, r.max.y-i), c);
-	}
-}
//GO.SYSIN DD ./libXg/border.c
echo ./libXg/bscreenrect.c
sed s/.// > ./libXg/bscreenrect.c <<'//GO.SYSIN DD ./libXg/bscreenrect.c'
-#include "libg.h"
-#include "libgint.h"
-
-/*
- * The screen data structure should always be up to date
- * (Not true in the Plan 9 library, which is why this
- * function exists).
- */
-Rectangle
-bscreenrect(Rectangle *clipr)
-{
-	if(clipr)
-		*clipr = screen.clipr;
-	return screen.r;
-}
//GO.SYSIN DD ./libXg/bscreenrect.c
echo ./libXg/circle.c
sed s/.// > ./libXg/circle.c <<'//GO.SYSIN DD ./libXg/circle.c'
-#include "libg.h"
-#include "libgint.h"
-
-void
-circle(Bitmap *b, Point p, int r, int v, Fcode f)
-{
-	unsigned int d;
-	int x, y;
-	GC g;
-
-	x = p.x - r;
-	y = p.y - r;
-	if (b->flag&SHIFT){
-		x -= b->r.min.x;
-		y -= b->r.min.y;
-	}
-	d = 2*r;
-	g = _getfillgc(f, b, v);
-	XDrawArc(_dpy, (Drawable)b->id, g, x, y, d, d, 0, 23040/* 360 deg */);
-}
//GO.SYSIN DD ./libXg/circle.c
echo ./libXg/clipline.c
sed s/.// > ./libXg/clipline.c <<'//GO.SYSIN DD ./libXg/clipline.c'
-#include "libg.h"
-#include "libgint.h"
-
-typedef struct Linedesc
-{
-	int	x0;
-	int	y0;
-	char	xmajor;
-	char	slopeneg;
-	long	dminor;
-	long	dmajor;
-} Linedesc;
-
-int	 _clipline(Rectangle, Point*, Point*, Linedesc*);
-
-#define	XYswap(p)	t=(p)->x, (p)->x=(p)->y, (p)->y=t
-#define	Swap(x, y)	t=x, x=y, y=t
-
-static long
-lfloor(long x, long y)	/* first integer <= x/y */
-{
-	if(y <= 0){
-		if(y == 0)
-			return x;
-		y = -y;
-		x = -x;
-	}
-	if(x < 0){	/* be careful; C div. is undefined */
-		x = -x;
-		x += y-1;
-		return -(x/y);
-	}
-	return x/y;
-}
-
-static long
-lceil(long x, long y)	/* first integer >= x/y */
-{
-	if(y <= 0){
-		if(y == 0)
-			return x;
-		y = -y;
-		x = -x;
-	}
-	if(x < 0){
-		x = -x;
-		return -(x/y);
-	}
-	x += y-1;
-	return x/y;
-}
-
-int
-_gminor(long x, Linedesc *l)
-{
-	long y;
-
-	y = 2*(x-l->x0)*l->dminor + l->dmajor;
-	y = lfloor(y, 2*l->dmajor) + l->y0;
-	return l->slopeneg? -y : y;
-}
-
-int
-_gmajor(long y, Linedesc *l)
-{
-	long x;
-
-	x = 2*((l->slopeneg? -y : y)-l->y0)*l->dmajor - l->dminor;
-	x = lceil(x, 2*l->dminor) + l->x0;
-	if(l->dminor)
-		while(_gminor(x-1, l) == y)
-			x--;
-	return x;
-}
-
-void
-gsetline(Point *pp0, Point *pp1, Linedesc *l)
-{
-	long dx, dy, t;
-	Point endpt;
-	int swapped;
-	Point p0, p1;
-
-	swapped = 0;
-	p0 = *pp0;
-	p1 = *pp1;
-	l->xmajor = 1;
-	l->slopeneg = 0;
-	dx = p1.x - p0.x;
-	dy = p1.y - p0.y;
-	if(abs(dy) > abs(dx)){	/* Steep */
-		l->xmajor = 0;
-		XYswap(&p0);
-		XYswap(&p1);
-		Swap(dx, dy);
-	}
-	if(dx < 0){
-		swapped++;
-		Swap(p0.x, p1.x);
-		Swap(p0.y, p1.y);
-		dx = -dx;
-		dy = -dy;
-	}
-	if(dy < 0){
-		l->slopeneg = 1;
-		dy = -dy;
-		p0.y = -p0.y;
-	}
-	l->dminor = dy;
-	l->dmajor = dx;
-	l->x0 = p0.x;
-	l->y0 = p0.y;
-	p1.x = swapped? p0.x+1 : p1.x-1;
-	p1.y = _gminor(p1.x, l);
-	if(l->xmajor == 0){
-		XYswap(&p0);
-		XYswap(&p1);
-	}
-	if(pp0->x > pp1->x){
-		*pp1 = *pp0;
-		*pp0 = p1;
-	}else
-		*pp1 = p1;
-}
-/*
- * Modified clip-to-rectangle algorithm
- *	works in bitmaps
- *	Everything in SCREEN coordinates.
- *
- *	Newman & Sproull 124 (1st edition)
- */
-
-static
-code(Point *p, Rectangle *r)
-{
-	return( (p->x<r->min.x? 1 : p->x>=r->max.x? 2 : 0) |
-		(p->y<r->min.y? 4 : p->y>=r->max.y? 8 : 0));
-}
-
-int
-clipline(Rectangle r, Point *p0, Point *p1)
-{
-	Linedesc l;
-
-	return _clipline(r, p0, p1, &l);
-}
-
-int
-_clipline(Rectangle r, Point *p0, Point *p1, Linedesc *l)
-{
-	int c0, c1, n;
-	long t, ret;
-	Point temp;
-	int swapped;
-
-	if(p0->x==p1->x && p0->y==p1->y)
-		return 0;
-	gsetline(p0, p1, l);
-	/* line is now closed */
-	if(l->xmajor == 0){
-		XYswap(p0);
-		XYswap(p1);
-		XYswap(&r.min);
-		XYswap(&r.max);
-	}
-	c0 = code(p0, &r);
-	c1 = code(p1, &r);
-	ret = 1;
-	swapped = 0;
-	n = 0;
-	while(c0 | c1){
-		if(c0 & c1){	/* no point of line in r */
-			ret = 0;
-			goto Return;
-		}
-		if(++n > 10){	/* horrible points; overflow etc. etc. */
-			ret = 0;
-			goto Return;
-		}
-		if(c0 == 0){	/* swap points */
-			temp = *p0;
-			*p0 = *p1;
-			*p1 = temp;
-			Swap(c0, c1);
-			swapped ^= 1;
-		}
-		if(c0 == 0)
-			break;
-		if(c0 & 1){		/* push towards left edge */
-			p0->x = r.min.x;
-			p0->y = _gminor(p0->x, l);
-		}else if(c0 & 2){	/* push towards right edge */
-			p0->x = r.max.x-1;
-			p0->y = _gminor(p0->x, l);
-		}else if(c0 & 4){	/* push towards top edge */
-			p0->y = r.min.y;
-			if(l->slopeneg)
-				p0->x = _gmajor(p0->y-1, l)-1;
-			else
-				p0->x = _gmajor(p0->y, l);
-		}else if(c0 & 8){	/* push towards bottom edge */
-			p0->y = r.max.y-1;
-			if(l->slopeneg)
-				p0->x = _gmajor(p0->y, l);
-			else
-				p0->x = _gmajor(p0->y+1, l)-1;
-		}
-		c0 = code(p0, &r);
-	}
-
-    Return:
-	if(l->xmajor == 0){
-		XYswap(p0);
-		XYswap(p1);
-	}
-	if(swapped){
-		temp = *p0;
-		*p0 = *p1;
-		*p1 = temp;
-	}
-	return ret;
-}
//GO.SYSIN DD ./libXg/clipline.c
echo ./libXg/clipr.c
sed s/.// > ./libXg/clipr.c <<'//GO.SYSIN DD ./libXg/clipr.c'
-#include "libg.h"
-#include "libgint.h"
-
-int
-clipr(Bitmap *d, Rectangle r)
-{
-	if(rectclip(&r, d->r) == 0)
-		return 0;
-	d->clipr = r;
-	if(r.min.x != d->r.min.x ||
-	   r.min.y != d->r.min.y ||
-	   r.max.y != d->r.max.y ||
-	   r.max.y != d->r.max.y)
-		d->flag |= CLIP;
-	else
-		d->flag &= ~CLIP;
-	return 1;
-}
//GO.SYSIN DD ./libXg/clipr.c
echo ./libXg/cursorset.c
sed s/.// > ./libXg/cursorset.c <<'//GO.SYSIN DD ./libXg/cursorset.c'
-#include "libg.h"
-#include "libgint.h"
-
-/*
- * Only allow cursor to move within screen Bitmap
- */
-void
-cursorset(Point p)
-{
-	/* motion will be relative to window origin */
-	p = sub(p, screen.r.min);
-	XWarpPointer(_dpy, None, (Window)screen.id, 0, 0, 0, 0, p.x, p.y);
-}
//GO.SYSIN DD ./libXg/cursorset.c
echo ./libXg/cursorswitch.c
sed s/.// > ./libXg/cursorswitch.c <<'//GO.SYSIN DD ./libXg/cursorswitch.c'
-#include "libg.h"
-#include "libgint.h"
-
-/*
- * Use the id field in Cursor to hold the X id corresponding
- * to the cursor, so that it doesn't have to be recreated on
- * each cursorswitch.  This doesn't quite match the semantics
- * of Plan9 libg, since the user could create a cursor (say
- * with malloc) with garbage in the id field; or the user
- * could change the contents of the other fields and we
- * wouldn't know about it.  Neither of these happen in
- * existing uses of libg.
- */
-static Cursor arrow =
-{
-	{-1, -1},
-	{0xFF, 0xE0, 0xFF, 0xE0, 0xFF, 0xC0, 0xFF, 0x00,
-	 0xFF, 0x00, 0xFF, 0x80, 0xFF, 0xC0, 0xFF, 0xE0,
-	 0xE7, 0xF0, 0xE3, 0xF8, 0xC1, 0xFC, 0x00, 0xFE,
-	 0x00, 0x7F, 0x00, 0x3E, 0x00, 0x1C, 0x00, 0x08,
-	},
-	{0x00, 0x00, 0x7F, 0xC0, 0x7F, 0x00, 0x7C, 0x00,
-	 0x7E, 0x00, 0x7F, 0x00, 0x6F, 0x80, 0x67, 0xC0,
-	 0x43, 0xE0, 0x41, 0xF0, 0x00, 0xF8, 0x00, 0x7C,
-	 0x00, 0x3E, 0x00, 0x1C, 0x00, 0x08, 0x00, 0x00,
-	}
-};
-
-static Bitmap *bsrc, *bmask;
-static Rectangle crect = { 0, 0, 16, 16 };
-
-void
-cursorswitch(Cursor *c)
-{
-	if(c == 0)
-		c = &arrow;
-	if(c->id == 0){
-		if(bsrc == 0){
-			bsrc = balloc(crect, 0);
-			bmask = balloc(crect, 0);
-		}
-		/*
-		 * Cursor should have fg where "set" is 1,
-		 * and bg where "clr" is 1 and "set" is 0,
-		 * and should leave places alone where "set" and "clr" are both 0
-		 */
-		wrbitmap(bsrc, 0, 16, c->set);
-#ifdef CURSORBUG
-		/*
-		 * Some X servers (e.g., Sun X-on-news for some color
-		 * monitors) don't do XCreatePixmapCursor properly:
-		 * only the mask gets displayed, all black
-		 */
-		wrbitmap(bmask, 0, 16, c->set);
-#else
-		wrbitmap(bmask, 0, 16, c->clr);
-		bitblt(bmask, Pt(0,0), bsrc, crect, S|D);
-#endif
-		c->id = (int) XCreatePixmapCursor(_dpy, (Pixmap)bsrc->id, (Pixmap)bmask->id,
-			&_fgcolor, &_bgcolor, -c->offset.x, -c->offset.y);
-	}
-	XDefineCursor(_dpy, (Window)screen.id, (xCursor)c->id);
-}
//GO.SYSIN DD ./libXg/cursorswitch.c
echo ./libXg/disc.c
sed s/.// > ./libXg/disc.c <<'//GO.SYSIN DD ./libXg/disc.c'
-#include "libg.h"
-#include "libgint.h"
-
-void
-disc(Bitmap *b, Point p, int r, int v, Fcode f)
-{
-	unsigned int d;
-	int x, y;
-	GC g;
-
-	x = p.x - r;
-	y = p.y - r;
-	if (b->flag&SHIFT){
-		x -= b->r.min.x;
-		y -= b->r.min.y;
-	}
-	d = 2*r;
-	g = _getfillgc(f, b, v);
-	XFillArc(_dpy, (Drawable)b->id, g, x, y, d, d, 0, 23040/* 360 deg */);
-}
//GO.SYSIN DD ./libXg/disc.c
echo ./libXg/ellipse.c
sed s/.// > ./libXg/ellipse.c <<'//GO.SYSIN DD ./libXg/ellipse.c'
-#include "libg.h"
-#include "libgint.h"
-
-/* e(x,y) = b*b*x*x + a*a*y*y - a*a*b*b */
-
-void
-ellipse(Bitmap *bp, Point p, int a, int b, int v, Fcode f)
-{
-	int x, y;
-	GC g;
-
-	x = p.x - a;
-	y = p.y - b;
-	if (bp->flag&SHIFT){
-		x -= bp->r.min.x;
-		y -= bp->r.min.y;
-	}
-	g = _getfillgc(f, bp, v);
-	XDrawArc(_dpy, (Drawable)bp->id, g, x, y, 2*a, 2*b, 0, 23040/* 360 deg */);
-}
//GO.SYSIN DD ./libXg/ellipse.c
echo ./libXg/gcs.c
sed s/.// > ./libXg/gcs.c <<'//GO.SYSIN DD ./libXg/gcs.c'
-#include "libg.h"
-#include "libgint.h"
-
-/*
- * Libg applications are written assuming that black is ~0
- * and white is 0.  Some screens use the reverse convention.
- * We get the effect the application desired by seeing what
- * happens if both the source and dest are converted to the
- * black==~0 convention, and then converting the dest back
- * to whatever convention it uses.
- *
- * Offscreen bitmaps of depth 1 use the black==~0 convention.
- *
- * Bitmaps of depth > 1 are probably in color.  Libg operations that
- * would produce a 1 should produce the foreground color, and
- * libg operations that would produce a 0 should produce the background
- * color.  Operations that use bitmaps of depth > 1 as source
- * should interpret the foreground pixel as "black" (1) and the
- * background pixel as "white" (0).  It is hard to make this work,
- * but the important cases are Fcodes Zero, F, S, and S^D, so
- * we make sure that those work.  When a fill value is given for
- * a bitmap of depth > 1, assume ~0 means foreground, but otherwise
- * take any other value literally (assume it came from rgbpix).
- * This may be wrong for the case of 0, but libg programmers
- * usually use Fcode Zero instead of passing 0 with Fcode S.
- *
- * We assume there are at most two depths of bitmaps: depth 1
- * and depth of the screen.
- */
-
-/*
- * gx func code corresponding to libg func code when both
- * source and dest use 1 for black.  This is a straight translation.
- */
-static int gx[16] = {
-	GXclear,		/* Zero */
-	GXnor,			/* DnorS */
-	GXandInverted,		/* DandnotS */
-	GXcopyInverted,		/* notS */
-	GXandReverse,		/* notDandS */
-	GXinvert,		/* notD */
-	GXxor,			/* DxorS */
-	GXnand,			/* DnandS */
-	GXand,			/* DandS */
-	GXequiv,		/* DxnorS */
-	GXnoop,			/* D */
-	GXorInverted,		/* DornotS */
-	GXcopy,			/* S */
-	GXorReverse,		/* notDorS */
-	GXor,			/* DorS */
-	GXset,			/* F */
-};
-
-/*
- * gx func code corresponding to libg func code when 0 means black
- * in dst and 1 means black in src. These means the table has op'
- * where dst <- dst op' src == not ( not(dst)  op  src ).
- * The comment on each line is op, in Fcode terms.
- */
-static int d0s1gx[16] = {
-	GXset,			/* Zero */
-	GXorReverse,		/* DnorS */
-	GXor,			/* DandnotS */
-	GXcopy,			/* notS */
-	GXnand,			/* notDandS */
-	GXinvert,		/* notD */
-	GXxor,			/* DxorS */
-	GXandReverse,		/* DnandS */
-	GXorInverted,		/* DandS */
-	GXequiv,		/* DxnorS */
-	GXnoop,			/* D */
-	GXand,			/* DornotS */
-	GXcopyInverted,		/* S */
-	GXnor,			/* notDorS */
-	GXandInverted,		/* DorS */
-	GXclear,		/* F */
-};
-/*
- * gx func code corresponding to libg func code when 1 means black
- * in dst and 0 means black in src. These means the table has op'
- * where dst <- dst op' src == dst  op  not(src) )
- * The comment on each line is op, in Fcode terms.
- */
-static int d1s0gx[16] = {
-	GXclear,		/* Zero */
-	GXandReverse,		/* DnorS */
-	GXand,			/* DandnotS */
-	GXcopy,			/* notS */
-	GXnor,			/* notDandS */
-	GXinvert,		/* notD */
-	GXequiv,		/* DxorS */
-	GXorReverse,		/* DnandS */
-	GXandInverted,		/* DandS */
-	GXxor,			/* DxnorS */
-	GXnoop,			/* D */
-	GXor,			/* DornotS */
-	GXcopyInverted,		/* S */
-	GXnand,			/* notDorS */
-	GXorInverted,		/* DorS */
-	GXset,			/* F */
-};
-
-/*
- * gx func code corresponding to libg func code when 0 means black
- * in both the src and the dst. These means the table has op'
- * where dst <- dst op' src == not (not(dst)  op  not(src)) )
- * The comment on each line is op, in Fcode terms.
- */
-static int d0s0gx[16] = {
-	GXset,			/* Zero */
-	GXnand,			/* DnorS */
-	GXorInverted,		/* DandnotS */
-	GXcopyInverted,		/* notS */
-	GXorReverse,		/* notDandS */
-	GXinvert,		/* notD */
-	GXequiv,		/* DxorS */
-	GXnor,			/* DnandS */
-	GXor,			/* DandS */
-	GXxor,			/* DxnorS */
-	GXnoop,			/* D */
-	GXandInverted,		/* DornotS */
-	GXcopy,			/* S */
-	GXandReverse,		/* notDorS */
-	GXand,			/* DorS */
-	GXclear,		/* F */
-};
-
-/*
- * 1 for those Fcodes that are degenerate (don't involve src)
- */
-static int degengc[16] = {
-	1,			/* Zero */
-	0,			/* DnorS */
-	0,			/* DandnotS */
-	0,			/* notS */
-	0,			/* notDandS */
-	1,			/* notD */
-	0,			/* DxorS */
-	0,			/* DnandS */
-	0,			/* DandS */
-	0,			/* DxnorS */
-	1,			/* D */
-	0,			/* DornotS */
-	0,			/* S */
-	0,			/* notDorS */
-	0,			/* DorS */
-	1,			/* F */
-};
-
-/*
- * GCs are all for same screen, and depth is either 1 or screen depth.
- * Return a GC for the depth of b, with values as specified by gcv.
- *
- * Also, set (or unset) the clip rectangle if necessary.
- * (This implementation should be improved if setting a clip rectangle is not rare).
- */
-static GC
-getgc(Bitmap *b, unsigned long gcvm, XGCValues *pgcv)
-{
-	static GC gc0, gcn;
-	static clipset = 0;
-	GC g;
-	XRectangle xr;
-
-	g = (b->ldepth==0)? gc0 : gcn;
-	if(!g){
-		g = XCreateGC(_dpy, (Drawable)b->id, gcvm, pgcv);
-		if(b->ldepth==0)
-			gc0 = g;
-		else
-			gcn = g;
-	} else
-		XChangeGC(_dpy, g, gcvm, pgcv);
-	if(b->flag&CLIP){
-		xr.x = b->clipr.min.x;
-		xr.y = b->clipr.min.y;
-		xr.width = Dx(b->clipr);
-		xr.height = Dy(b->clipr);
-		if(b->flag&SHIFT){
-			xr.x -= b->r.min.x;
-			xr.y -= b->r.min.y;
-		}
-		XSetClipRectangles(_dpy, g, 0, 0, &xr, 1, YXBanded);
-		clipset = 1;
-	}else if(clipset){
-		pgcv->clip_mask = None;
-		XChangeGC(_dpy, g, GCClipMask, pgcv);
-		clipset = 0;
-	}
-	return g;
-}
-
-/*
- * Return a GC that will fill bitmap b using a pixel value v and Fcode f.
- * Pixel value v is according to libg convention, so 0 means
- * white (or background) and ~0 means black (or foreground).
- */
-GC
-_getfillgc(Fcode f, Bitmap *b, unsigned long val)
-{
-	int xf, m;
-	unsigned long v, fg, bg, spix, vmax;
-	XGCValues gcv;
-
-	f &= F;
-	vmax = _ld2dmask[b->ldepth];
-	v = val & vmax;
-	spix = v;
-	xf = GXcopy;
-	m = b->flag;
-	if(m & DP1){
-		xf = (m&BL1)? gx[f] : d0s1gx[f];
-	}else{
-		fg = _fgpixel;
-		bg = _bgpixel;
-		switch(f){
-		case Zero:
-	    labZero:
-			spix = bg;
-			break;
-		case F:
-	    labF:
-			spix = fg;
-			break;
-		case D:
-	    labD:
-			xf = GXnoop;
-			break;
-		case notD:
-	    labnotD:
-			xf = GXxor;
-			spix = fg^bg;
-			break;
-		case S:
-			if(val == ~0)
-				spix = fg;
-			else
-				spix = v;
-			break;
-		case notS:
-			if(val == ~0)
-				spix = bg;
-			else
-				spix = v;
-			break;
-		case DxorS:
-			xf = GXxor;
-			if(val == ~0)
-				spix = fg^bg;
-			else
-				spix = v;
-			break;
-		case DxnorS:
-			xf = GXxor;
-			if(val == 0)
-				spix = fg^bg;
-			else
-				spix = v;
-			break;
-		default:
-			/* hard to do anything other than v==0 or v==~0 case */
-			if(v < vmax-v){
-				/* v is closer to 0 than vmax */
-				switch(f&~S){
-				case D&~S:	goto labD;
-				case notD&~S:	goto labnotD;
-				case Zero&~S:	goto labZero;
-				case F&~S:	goto labF;
-				}
-			}else{
-				/* v is closer to vmax than 0 */
-				switch(f&S){
-				case D&S:	goto labD;
-				case notD&S:	goto labnotD;
-				case Zero&S:	goto labZero;
-				case F&S:	goto labF;
-				}
-			}
-			
-		}
-	}
-	gcv.foreground = spix;
-	gcv.function = xf;
-	return getgc(b, GCForeground|GCFunction, &gcv);
-}
-
-/*
- * Return a GC to be used to copy an area from bitmap sb to
- * bitmap db.  Sometimes the calling function shouldn't use
- * XCopyArea, but instead should use XCopyPlane or XFillRectangle.
- * The *bltfunc arg is set to one of UseCopyArea, UseCopyPlane,
- * UseFillRectangle.
- */
-GC
-_getcopygc(Fcode f, Bitmap *db, Bitmap *sb, int *bltfunc)
-{
-	unsigned long spix, bg, fg, df, sf;
-	int xf, c;
-	XGCValues gcv;
-	unsigned long gcvm;
-
-	f &= F;
-	gcvm = 0;
-	df = db->flag;
-	if(degengc[f]){
-		*bltfunc = UseFillRectangle;
-		if(df&SCR || !(df&DP1)){
-			fg = _fgpixel;
-			bg = _bgpixel;
-		}else{
-			/* must be DP1 and BL1 */
-			fg = 1;
-			bg = 0;
-		}
-		switch(f){
-		case Zero:
-			xf = GXcopy;
-			spix = bg;
-			break;
-		case F:
-			xf = GXcopy;
-			spix = fg;
-			break;
-		case D:
-			xf = GXnoop;
-			spix = fg;
-			break;
-		case notD:
-			xf = GXxor;
-			spix = fg^bg;
-			break;
-		}
-		gcv.function = xf;
-		gcv.foreground = spix;
-		gcvm = GCFunction|GCForeground;
-	}else{
-		/* src is involved in f */
-
-#define code(f1,f2) ((((f1)&(DP1|BL1))<<2)|((f2)&(DP1|BL1)))
-
-		sf = sb->flag;
-		c = code(df,sf);
-		*bltfunc = UseCopyArea;
-		switch(code(df,sf)){
-		case code(DP1|BL1,DP1|BL1):
-		case code(BL1,BL1):
-			xf = gx[f];
-			break;
-		case code(DP1|BL1,DP1):
-			xf = d1s0gx[f];
-			break;
-		case code(DP1,DP1|BL1):
-			xf = d0s1gx[f];
-			break;
-		case code(DP1,DP1):
-		case code(0,0):
-			xf = d0s0gx[f];
-			break;
-		default:
-			/*
-			 * One bitmap has depth 1, the other has screen depth.
-			 * We know the bitmap must have BL1.
-			 * CopyPlane must be used; it won't really work
-			 * for more than fcode==S.
-			 */
-
-			*bltfunc = UseCopyPlane;
-			xf = GXcopy;
-			switch(c){
-
-			case code(0,DP1|BL1):
-			case code(BL1,DP1|BL1):
-				fg = _fgpixel;
-				bg = _bgpixel;
-				break;
-			case code(DP1|BL1,0):
-				fg = 0;
-				bg = 1;
-				break;
-			case code(DP1|BL1,BL1):
-				fg = 1;
-				bg = 0;
-				break;
-			default:
-				berror("bad combination of copy bitmaps");
-			}
-			gcv.foreground = fg;
-			gcv.background = bg;
-			gcvm |= GCForeground|GCBackground;
-		}
-		gcv.function = xf;
-		gcvm |= GCFunction;
-	
-#undef code
-	}
-
-	return getgc(db, gcvm, &gcv);
-}
//GO.SYSIN DD ./libXg/gcs.c
echo ./libXg/getrect.c
sed s/.// > ./libXg/getrect.c <<'//GO.SYSIN DD ./libXg/getrect.c'
-#include "libg.h"
-#include "libgint.h"
-
-static Cursor sweep={
-	{-7, -7},
-	{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x07,
-	 0xE0, 0x07, 0xE0, 0x07, 0xE3, 0xF7, 0xE3, 0xF7,
-	 0xE3, 0xE7, 0xE3, 0xF7, 0xE3, 0xFF, 0xE3, 0x7F,
-	 0xE0, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,},
-	{0x00, 0x00, 0x7F, 0xFE, 0x40, 0x02, 0x40, 0x02,
-	 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x41, 0xE2,
-	 0x41, 0xC2, 0x41, 0xE2, 0x41, 0x72, 0x40, 0x38,
-	 0x40, 0x1C, 0x40, 0x0E, 0x7F, 0xE6, 0x00, 0x00,}
-};
-
-Rectangle
-getrect(int but, Mouse *m){
-	Rectangle r, rc;
-
-	but = 1<<(but-1);
-	cursorswitch(&sweep);
-	while(m->buttons)
-		*m = emouse();
-	while(!(m->buttons & but)){
-		*m = emouse();
-		if(m->buttons & (7^but))
-			goto Return;
-	}
-	r.min = m->xy;
-	r.max = m->xy;
-	do{
-		rc = rcanon(r);
-		border(&screen, rc, 2, F&~D);
-		*m = emouse();
-		border(&screen, rc, 2, F&~D);
-		r.max = m->xy;
-	}while(m->buttons & but);
-
-    Return:
-	cursorswitch((Cursor *)0);
-	if(m->buttons & (7^but)){
-		rc.min.x = rc.max.x = 0;
-		while(m->buttons)
-			*m = emouse();
-	}
-	return rc;
-}
//GO.SYSIN DD ./libXg/getrect.c
echo ./libXg/gwin.c
sed s/.// > ./libXg/gwin.c <<'//GO.SYSIN DD ./libXg/gwin.c'
-#ifdef	v10
-typedef	char*	caddr_t;
-#endif
-#include <X11/Xos.h>
-#include <X11/IntrinsicP.h>
-#include <X11/StringDefs.h>
-#include <X11/Xatom.h>
-#include <X11/keysym.h>
-
-#ifndef XtSpecificationRelease
-#define R3
-#define XtPointer caddr_t
-#define XtOffsetOf(s_type,field) XtOffset(s_type*,field)
-#define XtExposeCompressMultiple TRUE
-#endif
-
-#include "GwinP.h"
-
-/* Forward declarations */
-static void Realize(Widget, XtValueMask *, XSetWindowAttributes *);
-static void Resize(Widget);
-static void Redraw(Widget, XEvent *, Region);
-static void Keyaction(Widget, XEvent *, String *, Cardinal*);
-static void Mouseaction(Widget, XEvent *, String *, Cardinal*);
-static String SelectSwap(Widget, String);
-
-/* Data */
-
-#define Offset(field) XtOffsetOf(GwinRec, gwin.field)
-
-static XtResource resources[] = {
-	{XtNforeground, XtCForeground, XtRPixel, sizeof(Pixel),
-		Offset(foreground), XtRString, (XtPointer)XtDefaultForeground},
-	{XtNfont,  XtCFont, XtRFontStruct, sizeof(XFontStruct *),
-		Offset(font),XtRString, (XtPointer)XtDefaultFont},
-	{XtNscrollForwardR, XtCScrollForwardR, XtRBoolean, sizeof(Boolean),
-		Offset(forwardr), XtRImmediate, (XtPointer)TRUE},
-	{XtNreshaped, XtCReshaped, XtRFunction, sizeof(Reshapefunc),
-		Offset(reshaped), XtRFunction, (XtPointer) NULL},
-	{XtNgotchar, XtCGotchar, XtRFunction, sizeof(Charfunc),
-		Offset(gotchar), XtRFunction, (XtPointer) NULL},
-	{XtNgotmouse, XtCGotmouse, XtRFunction, sizeof(Mousefunc),
-		Offset(gotmouse), XtRFunction, (XtPointer) NULL},
-	{XtNselection, XtCSelection, XtRString, sizeof(String),
-		Offset(selection), XtRString, (XtPointer) NULL}
-};
-#undef Offset
-
-
-static XtActionsRec actions[] = {
-	{"key", Keyaction},
-	{"mouse", Mouseaction}
-};
-
-static char tms[] =
-	"<Key> : key() \n\
-	<Motion> : mouse() \n\
-	<BtnDown> : mouse() \n\
-	<BtnUp> : mouse() \n";
-
-/* Class record declaration */
-
-GwinClassRec gwinClassRec = {
-  /* Core class part */
-   {
-    /* superclass         */    (WidgetClass)&widgetClassRec,
-    /* class_name         */    "Gwin",
-    /* widget_size        */    sizeof(GwinRec),
-    /* class_initialize   */    NULL,
-    /* class_part_initialize*/  NULL,
-    /* class_inited       */    FALSE,
-    /* initialize         */    NULL,
-    /* initialize_hook    */    NULL,
-    /* realize            */    Realize,
-    /* actions            */    actions,
-    /* num_actions        */    XtNumber(actions),
-    /* resources          */    resources,
-    /* num_resources      */    XtNumber(resources),
-    /* xrm_class          */    NULLQUARK,
-    /* compress_motion    */    FALSE,
-    /* compress_exposure  */    XtExposeCompressMultiple,
-    /* compress_enterleave*/    TRUE,
-    /* visible_interest   */    FALSE,
-    /* destroy            */    NULL,
-    /* resize             */    Resize,
-    /* expose             */    Redraw,
-    /* set_values         */    NULL,
-    /* set_values_hook    */    NULL,
-    /* set_values_almost  */    XtInheritSetValuesAlmost,
-    /* get_values_hook    */    NULL,
-    /* accept_focus       */    XtInheritAcceptFocus,
-    /* version            */    XtVersion,
-    /* callback_offsets   */    NULL,
-    /* tm_table           */    tms,
-    /* query_geometry       */  XtInheritQueryGeometry,
-    /* display_accelerator  */  NULL,
-    /* extension            */  NULL
-   },
-  /* Gwin class part */
-   {
-    /* select_swap	  */    SelectSwap,
-   }
-};
-
-/* Class record pointer */
-WidgetClass gwinWidgetClass = (WidgetClass) &gwinClassRec;
-
-static void
-Realize(Widget w, XtValueMask *valueMask, XSetWindowAttributes *attrs)
-{
-	Display			*dpy;
-	Visual			*v;
-	Window			root;
-	Arg			args[10];
-	int			n;
-	XtValueMask		mask;
-
-	dpy = XtDisplay(w);
-	v = DefaultVisual(dpy, DefaultScreen(dpy));
-	root = RootWindow(dpy, DefaultScreen(dpy));
-
-	*valueMask |= CWBackingStore;
-	attrs->backing_store = Always;
-
-	XtCreateWindow(w, InputOutput, (Visual *)0, *valueMask, attrs);
-	XtSetKeyboardFocus(w->core.parent, w);
-
-	Resize(w);
-}
-
-static void
-Resize(Widget w)
-{
-	if(XtIsRealized(w))
-		(*(XtClass(w)->core_class.expose))(w, (XEvent *)NULL, (Region)NULL);
-}
-
-static void
-Redraw(Widget w, XEvent *e, Region r)
-{
-	Reshapefunc f;
-
-	f = ((GwinWidget)w)->gwin.reshaped;
-	if(f)
-		(*f)(w->core.x, w->core.y,
-			w->core.x+w->core.width, w->core.y+w->core.height);
-}
-
-#define STUFFCOMPOSE() \
-				f = ((GwinWidget)w)->gwin.gotchar; \
-				if (f) \
-					for (c = 0; c < composing; c++) \
-						(*f)(compose[c])
-
-static void
-Keyaction(Widget w, XEvent *e, String *p, Cardinal *np)
-{
-	static unsigned char compose[5];
-	static int composing = -1;
-
-	int c;
-	KeySym k;
-	Charfunc f;
-	Modifiers md;
-
-	/*
-	 * I tried using XtGetActionKeysym, but it didn't seem to
-	 * do case conversion properly
-	 * (at least, with Xterminal servers and R4 intrinsics)
-	 */
-	if(e->xany.type != KeyPress)
-		return;
-	XtTranslateKeycode(e->xany.display, (KeyCode)e->xkey.keycode,
-		        e->xkey.state, &md, &k);
-	if(k == NoSymbol)
-		return;
-	if(k&0xFF00){
-		switch(k){
-		case XK_BackSpace:
-		case XK_Tab:
-		case XK_Escape:
-		case XK_Delete:
-		case XK_KP_0:
-		case XK_KP_1:
-		case XK_KP_2:
-		case XK_KP_3:
-		case XK_KP_4:
-		case XK_KP_5:
-		case XK_KP_6:
-		case XK_KP_7:
-		case XK_KP_8:
-		case XK_KP_9:
-		case XK_KP_Divide:
-		case XK_KP_Multiply:
-		case XK_KP_Subtract:
-		case XK_KP_Add:
-		case XK_KP_Decimal:
-			k &= 0x7F;
-			break;
-		case XK_Linefeed:
-			k = '\r';
-			break;
-		case XK_KP_Enter:
-		case XK_Return:
-			k = '\n';
-			break;
-		case XK_Left:
-		case XK_Down:
-		case XK_Right:
-		case XK_Next:
-			k = 0x80; /* "Scroll" */
-			break;
-		default:
-			return;	/* not ISO-1 or tty control */
-		}
-	}
-	/* Compensate for servers that call a minus a hyphen */
-	if(k == XK_hyphen)
-		k = XK_minus;
-	/* Do control mapping ourselves if translator doesn't */
-	if((e->xkey.state&ControlMask) && !(md&ControlMask))
-		k &= 0x9f;
-	if (e->xkey.state & Mod1Mask)
-	{
-		compose[++composing] = k;
-		if ((*compose == 'X') && (composing > 0))
-		{
-			if ((k < '0') || (k > 'f') ||
-					((k > '9') && (k < 'a')))
-			{
-				STUFFCOMPOSE();
-				c = (unsigned short)k;
-				composing = -1;
-			}
-			else if (composing == 4)
-			{
-				c = (int)unicode(compose);
-				if (c == -1)
-				{
-					STUFFCOMPOSE();
-					c = (unsigned short)compose[4];
-				}
-				composing = -1;
-			}
-		}
-		else if (composing == 1)
-		{
-			c = (int)latin1(compose);
-			if (c == -1)
-			{
-				STUFFCOMPOSE();
-				c = (unsigned short)compose[1];
-			}
-			composing = -1;
-		}
-	}
-	else
-	{
-		if (composing >= 0)
-		{
-			composing++;
-			STUFFCOMPOSE();
-		}
-		c = (unsigned short)k;
-		composing = -1;
-	}
-
-	if (composing >= 0)
-		return;
-
-	f = ((GwinWidget)w)->gwin.gotchar;
-	if(f)
-		(*f)(c);
-}
-
-static void
-Mouseaction(Widget w, XEvent *e, String *p, Cardinal *np)
-{
-	int s;
-	XButtonEvent *be;
-	XMotionEvent *me;
-	Gwinmouse m;
-	Mousefunc f;
-
-	switch(e->type){
-	case ButtonPress:
-		be = (XButtonEvent *)e;
-		m.xy.x = be->x;
-		m.xy.y = be->y;
-		m.msec = be->time;
-		s = be->state;	/* the previous state */
-		switch(be->button){
-		case 1:	s |= Button1Mask; break;
-		case 2:	s |= Button2Mask; break;
-		case 3:	s |= Button3Mask; break;
-		}
-		break;
-	case ButtonRelease:
-		be = (XButtonEvent *)e;
-		m.xy.x = be->x;
-		m.xy.y = be->y;
-		m.msec = be->time;
-		s = be->state;
-		switch(be->button){
-		case 1:	s &= ~Button1Mask; break;
-		case 2:	s &= ~Button2Mask; break;
-		case 3:	s &= ~Button3Mask; break;
-		}
-		break;
-	case MotionNotify:
-		me = (XMotionEvent *)e;
-		m.xy.x = me->x;
-		m.xy.y = me->y;
-		m.msec = me->time;
-		s = me->state;
-		break;
-	default:
-		return;
-	}
-	m.buttons = 0;
-	if(s & Button1Mask) m.buttons |= 1;
-	if(s & Button2Mask) m.buttons |= 2;
-	if(s & Button3Mask) m.buttons |= 4;
-	f = ((GwinWidget)w)->gwin.gotmouse;
-	if(f)
-		(*f)(&m);
-}
-
-static void
-SelCallback(Widget w, XtPointer cldata, Atom *sel, Atom *seltype,
-	XtPointer val, unsigned long *len, int *fmt)
-{
-	String s;
-	int n;
-	GwinWidget gw = (GwinWidget)w;
-
-	if(gw->gwin.selection)
-		XtFree(gw->gwin.selection);
-	if(*seltype != XA_STRING)
-		n = 0;
-	else
-		n = (*len) * (*fmt/8);
-	s = (String)XtMalloc(n+1);
-	if(n > 0)
-		memcpy(s, (char *)val, n);
-	s[n] = 0;
-	gw->gwin.selection = s;
-	XtFree(val);
-}
-
-static Boolean
-SendSel(Widget w, Atom *sel, Atom *target, Atom *rtype, XtPointer *ans,
-		unsigned long *anslen, int *ansfmt)
-{
-	GwinWidget gw = (GwinWidget)w;
-	static Atom targets = 0;
-	XrmValue src, dst;
-	char *s;
-
-	if(*target == XA_STRING){
-		s = gw->gwin.selection;
-		if(!s)
-			s = "";
-		*rtype = XA_STRING;
-		*ans = (XtPointer) XtNewString(s);
-		*anslen = strlen(*ans);
-		*ansfmt = 8;
-		return TRUE;
-	}
-#ifndef R3
-	if(targets == 0){
-		src.addr = "TARGETS";
-		src.size = strlen(src.addr)+1;
-		dst.size = sizeof(Atom);
-		dst.addr = (XtPointer) &targets;
-		XtConvertAndStore(w, XtRString, &src, XtRAtom, &dst);
-	}
-	if(*target == targets){
-		*rtype = XA_ATOM;
-		*ans = (XtPointer) XtNew(Atom);
-		*(Atom*) *ans = XA_STRING;
-		*anslen = 1;
-		*ansfmt = 32;
-		return TRUE;
-	}
-#endif
-	return FALSE;
-}
-
-static String
-SelectSwap(Widget w, String s)
-{
-	GwinWidget gw;
-	String ans;
-
-	gw = (GwinWidget)w;
-	if(gw->gwin.selection){
-		XtFree(gw->gwin.selection);
-		gw->gwin.selection = 0;
-	}
-#ifdef R3
-	XtGetSelectionValue(w, XA_PRIMARY, XA_STRING, SelCallback, 0,
-			CurrentTime);
-#else
-	XtGetSelectionValue(w, XA_PRIMARY, XA_STRING, SelCallback, 0,
-			XtLastTimestampProcessed(XtDisplay(w)));
-#endif
-	while(gw->gwin.selection == 0)
-		XtAppProcessEvent(XtWidgetToApplicationContext(w) , XtIMAll);
-	ans = gw->gwin.selection;
-	gw->gwin.selection = XtMalloc(strlen(s)+1);
-	strcpy(gw->gwin.selection, s);
-#ifdef R3
-	XtOwnSelection(w, XA_PRIMARY, CurrentTime, SendSel, NULL, NULL);
-#else
-	XtOwnSelection(w, XA_PRIMARY, XtLastTimestampProcessed(XtDisplay(w)),
-			SendSel, NULL, NULL);
-#endif
-	return ans;
-}
-
-/* The returned answer should be free()ed when no longer needed */
-String
-GwinSelectionSwap(Widget w, String s)
-{
-	XtCheckSubclass(w, gwinWidgetClass, NULL);
-	return (*((GwinWidgetClass) XtClass(w))->gwin_class.select_swap)(w, s);
-}
-
//GO.SYSIN DD ./libXg/gwin.c
echo ./libXg/libg.h
sed s/.// > ./libXg/libg.h <<'//GO.SYSIN DD ./libXg/libg.h'
-#ifndef _LIBG_H
-#define _LIBG_H
-
-#ifndef _LIBXG_EXTENSION
-    This header file is not defined in pure ANSI/POSIX
-#endif
-/*
- *  Like Plan9's libg.h, but suitable for inclusion on non-Plan9 machines
- */
-
-enum{ EMAXMSG = 128+8192 };	/* max event size */
-
-/*
- * Types
- */
-
-typedef	struct	Bitmap		Bitmap;
-typedef struct	Point		Point;
-typedef struct	Rectangle 	Rectangle;
-typedef struct	Cursor		Cursor;
-typedef struct	Mouse		Mouse;
-typedef struct	Menu		Menu;
-typedef struct	Font		Font;
-typedef struct	Fontchar	Fontchar;
-typedef struct	Event		Event;
-typedef struct	RGB		RGB;
-
-struct	Point
-{
-	int	x;
-	int	y;
-};
-
-struct Rectangle
-{
-	Point min;
-	Point max;
-};
-
-struct	Bitmap
-{
-	Rectangle r;		/* rectangle in data area, local coords */
-	Rectangle clipr;	/* clipping region */
-	int	ldepth;
-	int	id;
-	Bitmap	*cache;		/* zero; distinguishes bitmap from layer */
-	int	flag;		/* flag used by X implementation of libg */
-};
-
-struct	Mouse
-{
-	int		buttons; /* bit array: LMR=124 */
-	Point		xy;
-	unsigned long	msec;
-};
-
-struct	Cursor
-{
-	Point		offset;
-	unsigned char	clr[2*16];
-	unsigned char	set[2*16];
-	int		id;	/* init to zero; used by library */
-};
-
-struct Menu
-{
-	char	**item;
-	char	*(*gen)(int);
-	int	lasthit;
-};
-
-struct	Fontchar
-{
-	short		x;		/* left edge of bits */
-	unsigned char	top;		/* first non-zero scan-line */
-	unsigned char	bottom;		/* last non-zero scan-line */
-	char		left;		/* offset of baseline */
-	unsigned char	width;		/* width of baseline */
-};
-
-struct Font
-{
-	char		*name;
-	unsigned char	height;	/* max height of bitmap, interline spacing */
-	char		ascent;	/* top of bitmap to baseline */
-	char		width;	/* widest so far; used in caching only */	
-	char		ldepth;	/* of images */
-	unsigned long	id;	/* of font */
-	Fontchar 	*info;	/* n+1 character descriptors.  (X implmentation) */
-	short		n;	/* number of chars in font.  (X implmentation) */
-};
-
-struct	Event
-{
-	int		kbdc;
-	Mouse		mouse;
-	int		n;		/* number of characters in mesage */
-	unsigned char	data[EMAXMSG];	/* message from an arbitrary file descriptor */
-};
-
-struct RGB
-{
-	unsigned long	red;
-	unsigned long	green;
-	unsigned long	blue;
-};
-
-/*
- * Codes for bitblt etc.
- *
- *	       D
- *	     0   1
- *         ---------
- *	 0 | 1 | 2 |
- *     S   |---|---|
- * 	 1 | 4 | 8 |
- *         ---------
- *
- *	Usually used as D|S; DorS is so tracebacks are readable.
- */
-typedef
-enum	Fcode
-{
-	Zero		= 0x0,
-	DnorS		= 0x1,
-	DandnotS	= 0x2,
-	notS		= 0x3,
-	notDandS	= 0x4,
-	notD		= 0x5,
-	DxorS		= 0x6,
-	DnandS		= 0x7,
-	DandS		= 0x8,
-	DxnorS		= 0x9,
-	D		= 0xA,
-	DornotS		= 0xB,
-	S		= 0xC,
-	notDorS		= 0xD,
-	DorS		= 0xE,
-	F		= 0xF
-} Fcode;
-
-/*
- * Miscellany
- */
-
-typedef void	 (*Errfunc)(char *);
-
-extern Point	 add(Point, Point);
-extern Point	 sub(Point, Point);
-extern Point	 mul(Point, int);
-extern Point	 divpt(Point, int);
-extern Rectangle rsubp(Rectangle, Point);
-extern Rectangle raddp(Rectangle, Point);
-extern Rectangle inset(Rectangle, int);
-extern Rectangle rmul(Rectangle, int);
-extern Rectangle rdiv(Rectangle, int);
-extern Rectangle rshift(Rectangle, int);
-extern Rectangle rcanon(Rectangle);
-extern Bitmap*	 balloc(Rectangle, int);
-extern void	 bfree(Bitmap*);
-extern int	 rectclip(Rectangle*, Rectangle);
-extern void	 xtbinit(Errfunc, char*, int*, char**);
-extern void	 bclose(void);
-extern void	 berror(char*);
-extern void	 bitblt(Bitmap*, Point, Bitmap*, Rectangle, Fcode);
-extern void	 bitbltclip(void*);
-extern Font*	 getfont(char*);
-extern Point	 string(Bitmap*, Point, Font*, char*, Fcode);
-extern void	 segment(Bitmap*, Point, Point, int, Fcode);
-extern void	 point(Bitmap*, Point, int, Fcode);
-extern void	 arc(Bitmap*, Point, Point, Point, int, Fcode);
-extern void	 circle(Bitmap*, Point, int, int, Fcode);
-extern void	 disc(Bitmap*, Point, int, int, Fcode);
-extern void	 ellipse(Bitmap*, Point, int, int, int, Fcode);
-extern long	 strwidth(Font*, char*);
-extern Point	 strsize(Font*, char*);
-extern long	 charwidth(Font*, unsigned short);
-extern void	 texture(Bitmap*, Rectangle, Bitmap*, Fcode);
-extern void	 wrbitmap(Bitmap*, int, int, unsigned char*);
-extern void	 rdbitmap(Bitmap*, int, int, unsigned char*);
-extern void	 wrbitmapfile(int, Bitmap*);
-extern Bitmap*	 rdbitmapfile(int);
-extern int	 ptinrect(Point, Rectangle);
-extern int	 rectXrect(Rectangle, Rectangle);
-extern int	 eqpt(Point, Point);
-extern int	 eqrect(Rectangle, Rectangle);
-extern void	 border(Bitmap*, Rectangle, int, Fcode);
-extern void	 cursorswitch(Cursor*);
-extern void	 cursorset(Point);
-extern Rectangle bscreenrect(Rectangle*);
-extern unsigned char* bneed(int);
-extern void	 bflush(void);
-extern void	 bexit(void);
-extern int	 bwrite(void);
-extern int	 clipline(Rectangle, Point*, Point*);
-extern int	 clipr(Bitmap*, Rectangle);
-
-extern void	 einit(unsigned long);
-extern unsigned long estart(unsigned long, int, int);
-extern unsigned long etimer(unsigned long, int);
-extern unsigned long event(Event*);
-extern unsigned long eread(unsigned long, Event*);
-extern Mouse	 emouse(void);
-extern int	 ekbd(void);
-extern int	 ecanread(unsigned long);
-extern int	 ecanmouse(void);
-extern int	 ecankbd(void);
-extern void	 ereshaped(Rectangle);	/* supplied by user */
-extern int	 menuhit(int, Mouse*, Menu*);
-extern Rectangle getrect(int, Mouse*);
-extern unsigned long rgbpix(Bitmap*, RGB);
-extern void	 rdcolmap(Bitmap*, RGB*);
-
-/* Extra functions supplied by libXg */
-extern int	snarfswap(char *, int, char**);
-extern int	scrollfwdbut(void);
-
-enum{
-	Emouse		= 1,
-	Ekeyboard	= 2
-};
-
-extern Point	 Pt(int, int);
-extern Rectangle Rect(int, int, int, int);
-extern Rectangle Rpt(Point, Point);
-
-
-#define	Dx(r)	((r).max.x-(r).min.x)
-#define	Dy(r)	((r).max.y-(r).min.y)
-
-extern	Bitmap	screen;
-extern	Font	*font;
-
-#define	BGSHORT(p)		(((p)[0]<<0) | ((p)[1]<<8))
-#define	BGLONG(p)		((BGSHORT(p)<<0) | (BGSHORT(p+2)<<16))
-#define	BPSHORT(p, v)		((p)[0]=(v), (p)[1]=((v)>>8))
-#define	BPLONG(p, v)		(BPSHORT(p, (v)), BPSHORT(p+2, (v)>>16))
-
-#endif
//GO.SYSIN DD ./libXg/libg.h
echo ./libXg/libgint.h
sed s/.// > ./libXg/libgint.h <<'//GO.SYSIN DD ./libXg/libgint.h'
-/* internal libg implementation file - include after libg */
-
-/*
- * include defs of standard library routines, if possible,
- * and string routines
- */
-#ifdef _POSIX_SOURCE
-#include <stdlib.h>
-#include <string.h>
-#endif /* _POSIX_SOURCE */
-
-/*
- * use defines to rename X11 types Cursor, Font, Event
- */
-
-#define Cursor xCursor
-#define Font xFont
-#define Event xEvent
-
-#ifdef	v10
-typedef	char*	caddr_t;
-#endif
-
-#include <X11/Xlib.h>
-#include <X11/Xatom.h>
-#include <X11/Xutil.h>
-
-#undef Cursor
-#undef Font
-#undef Event
-
-/* Return a GCs for solid filling/strings/etc., segments/points, and tiling */
-extern GC	_getfillgc(Fcode, Bitmap*, unsigned long);
-extern GC	_getcopygc(Fcode, Bitmap*, Bitmap*, int*);
-
-/* balloc without zero init (which uses a gc!) */
-extern Bitmap	*_balloc(Rectangle, int);
-
-/* X Display for this application's connection */
-extern Display	*_dpy;
-
-/* screen depth foreground and background for this application */
-extern unsigned long	_fgpixel, _bgpixel;
-extern XColor		_fgcolor, _bgcolor;
-
-/* indexed by log depth (0 <= ld <= 5), to give depth and planemask */
-extern int		_ld2d[];
-extern unsigned long	_ld2dmask[];
-
-/* libg.h defines:
- *   extern Bitmap screen;   -- Bitmap for application Window after xbinit()
- *   extern Font *font;      -- Font for application default font after xbinit()
- */
-
-/*
- * Conventions:
- *   The .id field of a Bitmap is an X Pixmap unless the Bitmap is screen,
- *   in which case it is a Window.
- *   The .id field of a Cursor is set to the X xCursor the first time the
- *   cursor is used.
- *   The .id field of a Font is set to the X xFont.
- *
- *   Coordinate conventions: libg bitmaps can have non (0,0) origins,
- *   but not X Pixmaps, so we have to subtract the min point of a Bitmap
- *   from coords in the Bitmap before using the point in the corresponding Pixmap.
- *   The screen Bitmap, however, contains the rectangle in X coords of the
- *   widget in which the application is started, relative to the window.
- *   The origin may or may not be (0,0), but in any case, coordinates should
- *   NOT be translated before using in X calls on the Window.
- */
-
-/* values for bitmap flag field (see _getcopygc if change first two vals) */
-enum {
-	DP1=	0x1,	/* depth == 1 (ldepth == 0) */
-	BL1=	0x2,	/* black == 1 model */
-	SCR=	0x4,	/* on screen */
-	ZORG=	0x8,	/* r.min == Pt(0,0) */
-	SHIFT= 0x20,	/* !SCR & !ZORG */
-	CLIP=  0x40	/* r != clipr */
-};
-
-/* values for return bltfunc arg of _getcopygc */
-enum {
-	UseCopyArea,
-	UseCopyPlane,
-	UseFillRectangle
-};
//GO.SYSIN DD ./libXg/libgint.h
echo ./libXg/latin1.c
sed s/.// > ./libXg/latin1.c <<'//GO.SYSIN DD ./libXg/latin1.c'
-/*
- * $Log:	latin1.c,v $
- * Revision 1.2  92/05/04  16:15:59  matty
- * Corrected rune encodings
- * 
- * Revision 1.1  92/04/22  16:55:19  matty
- * Initial revision
- * 
- */
-
-struct latin
-{
-	unsigned short	l;
-	unsigned char	c[2];
-}latintab[] = {
-	0xa1,	"!!",	/* spanish initial ! */
-	0xa2,	"c$",	/* cent */
-	0xa3,	"l$",	/* pound sterling */
-	0xa4,	"g$",	/* general currency */
-	0xa5,	"y$",	/* yen */
-	0xa6,	"||",	/* broken vertical bar */
-	0xa7,	"SS",	/* section symbol */
-	0xa8,	"\"\"",	/* dieresis */
-	0xa9,	"cO",	/* copyright */
-	0xaa,	"sa",	/* super a, feminine ordinal */
-	0xab,	"<<",	/* left angle quotation */
-	0xac,	"no",	/* not sign, hooked overbar */
-	0xad,	"--",	/* soft hyphen */
-	0xae,	"rO",	/* registered trademark */
-	0xaf,	"__",	/* macron */
-	0xb0,	"de",	/* degree */
-	0xb1,	"+-",	/* plus-minus */
-	0xb2,	"s2",	/* sup 2 */
-	0xb3,	"s3",	/* sup 3 */
-	0xb4,	"''",	/* acute accent */
-	0xb5,	"*m",	/* mu */
-	0xb6,	"pg",	/* paragraph (pilcrow) */
-	0xb7,	"..",	/* centered . */
-	0xb8,	",,",	/* cedilla */
-	0xb9,	"s1",	/* sup 1 */
-	0xba,	"s0",	/* sup 0 */
-	0xbb,	">>",	/* right angle quotation */
-	0xbc,	"14",	/* 1/4 */
-	0xbd,	"12",	/* 1/2 */
-	0xbe,	"34",	/* 3/4 */
-	0xbf,	"??",	/* spanish initial ? */
-	0xc0,	"`A",	/* A grave */
-	0xc1,	"'A",	/* A acute */
-	0xc2,	"^A",	/* A circumflex */
-	0xc3,	"~A",	/* A tilde */
-	0xc4,	"\"A",	/* A dieresis */
-	0xc5,	"oA",	/* A circle */
-	0xc6,	"AE",	/* AE ligature */
-	0xc7,	",C",	/* C cedilla */
-	0xc8,	"`E",	/* E grave */
-	0xc9,	"'E",	/* E acute */
-	0xca,	"^E",	/* E circumflex */
-	0xcb,	"\"E",	/* E dieresis */
-	0xcc,	"`I",	/* I grave */
-	0xcd,	"'I",	/* I acute */
-	0xce,	"^I",	/* I circumflex */
-	0xcf,	"\"I",	/* I dieresis */
-	0xd0,	"D-",	/* Eth */
-	0xd1,	"~N",	/* N tilde */
-	0xd2,	"`O",	/* O grave */
-	0xd3,	"'O",	/* O acute */
-	0xd4,	"^O",	/* O circumflex */
-	0xd5,	"~O",	/* O tilde */
-	0xd6,	"\"O",	/* O dieresis */
-	0xd7,	"mu",	/* times sign */
-	0xd8,	"/O",	/* O slash */
-	0xd9,	"`U",	/* U grave */
-	0xda,	"'U",	/* U acute */
-	0xdb,	"^U",	/* U circumflex */
-	0xdc,	"\"U",	/* U dieresis */
-	0xdd,	"'Y",	/* Y acute */
-	0xde,	"|P",	/* Thorn */
-	0xdf,	"ss",	/* sharp s */
-	0xe0,	"`a",	/* a grave */
-	0xe1,	"'a",	/* a acute */
-	0xe2,	"^a",	/* a circumflex */
-	0xe3,	"~a",	/* a tilde */
-	0xe4,	"\"a",	/* a dieresis */
-	0xe5,	"oa",	/* a circle */
-	0xe6,	"ae",	/* ae ligature */
-	0xe7,	",c",	/* c cedilla */
-	0xe8,	"`e",	/* e grave */
-	0xe9,	"'e",	/* e acute */
-	0xea,	"^e",	/* e circumflex */
-	0xeb,	"\"e",	/* e dieresis */
-	0xec,	"`i",	/* i grave */
-	0xed,	"'i",	/* i acute */
-	0xee,	"^i",	/* i circumflex */
-	0xef,	"\"i",	/* i dieresis */
-	0xf0,	"d-",	/* eth */
-	0xf1,	"~n",	/* n tilde */
-	0xf2,	"`o",	/* o grave */
-	0xf3,	"'o",	/* o acute */
-	0xf4,	"^o",	/* o circumflex */
-	0xf5,	"~o",	/* o tilde */
-	0xf6,	"\"o",	/* o dieresis */
-	0xf7,	"-:",	/* divide sign */
-	0xf8,	"/o",	/* o slash */
-	0xf9,	"`u",	/* u grave */
-	0xfa,	"'u",	/* u acute */
-	0xfb,	"^u",	/* u circumflex */
-	0xfc,	"\"u",	/* u dieresis */
-	0xfd,	"'y",	/* y acute */
-	0xfe,	"|p",	/* thorn */
-	0xff,	"\"y",	/* y dieresis */
-	0x2654,	"wk",	/* chess white king */
-	0x2655,	"wq",	/* chess white queen */
-	0x2656,	"wr",	/* chess white rook */
-	0x2657,	"wb",	/* chess white bishop */
-	0x2658,	"wn",	/* chess white knight */
-	0x2659,	"wp",	/* chess white pawn */
-	0x265a,	"bk",	/* chess black king */
-	0x265b,	"bq",	/* chess black queen */
-	0x265c,	"br",	/* chess black rook */
-	0x265d,	"bb",	/* chess black bishop */
-	0x265e,	"bn",	/* chess black knight */
-	0x265f,	"bp",	/* chess black pawn */
-	0,	0,
-};
-
-long
-latin1(unsigned char *k)
-{
-	struct latin *l;
-
-	for(l=latintab; l->l; l++)
-		if(k[0]==l->c[0] && k[1]==l->c[1])
-			return l->l;
-	return -1;
-}
-
-long
-unicode(unsigned char *k)
-{
-	long i, c;
-	struct latin *l;
-
-	k++;	/* skip 'X' */
-	c = 0;
-	for(i=0; i<4; i++,k++){
-		c <<= 4;
-		if('0'<=*k && *k<='9')
-			c += *k-'0';
-		else if('a'<=*k && *k<='f')
-			c += 10 + *k-'a';
-		else if('A'<=*k && *k<='F')
-			c += 10 + *k-'A';
-		else
-			return -1;
-	}
-	return c;
-}
//GO.SYSIN DD ./libXg/latin1.c
echo ./libXg/menuhit.c
sed s/.// > ./libXg/menuhit.c <<'//GO.SYSIN DD ./libXg/menuhit.c'
-#include "libg.h"
-#include "libgint.h"
-
-enum
-{
-	Margin = 3,		/* outside to text */
-	Border = 2,		/* outside to selection boxes */
-	Blackborder = 1,	/* width of outlining border */
-	Vspacing = 1		/* extra spacing between lines of text */
-};
-
-Rectangle
-menurect(Rectangle r, int i)
-{
-	if(i < 0)
-		return Rect(0, 0, 0, 0);
-	r = inset(r, Margin);
-	r.min.y += (font->height+Vspacing)*i;
-	r.max.y = r.min.y+font->height+Vspacing;
-	return inset(r, Border-Margin);
-}
-
-int
-menusel(Rectangle r, Point p)
-{
-	r = inset(r, Margin);
-	if(!ptinrect(p, r))
-		return -1;
-	return (p.y-r.min.y)/(font->height+Vspacing);
-}
-
-int
-menuhit(int but, Mouse *m, Menu *menu)
-{
-	int i, nitem, maxwid = 0, lasti;
-	Rectangle r, menur;
-	Point pt;
-	Bitmap *b;
-	char *item;
-
-	for(nitem = 0;
-	    item = menu->item? menu->item[nitem] : (*menu->gen)(nitem);
-	    nitem++){
-		i = strwidth(font, item);
-		if(i > maxwid)
-			maxwid = i;
-	}
-	if(menu->lasthit<0 || menu->lasthit>=nitem)
-		menu->lasthit = 0;
-	r = inset(Rect(0, 0, maxwid, nitem*(font->height+Vspacing)), -Margin);
-	r = rsubp(r,
-	    Pt(maxwid/2, menu->lasthit*(font->height+Vspacing)+font->height/2));
-	r = raddp(r, m->xy);
-	pt = Pt(0, 0);
-	if(r.max.x>screen.r.max.x)
-		pt.x = screen.r.max.x-r.max.x;
-	if(r.max.y>screen.r.max.y)
-		pt.y = screen.r.max.y-r.max.y;
-	if(r.min.x<screen.r.min.x)
-		pt.x = screen.r.min.x-r.min.x;
-	if(r.min.y<screen.r.min.y)
-		pt.y = screen.r.min.y-r.min.y;
-	menur = raddp(r, pt);
-	b = balloc(menur, screen.ldepth);
-	if(b == 0)
-		b = &screen;
-	bitblt(b, menur.min, &screen, menur, S);
-	bitblt(&screen, menur.min, &screen, menur, 0);
-	border(&screen, menur, Blackborder, F);
-	pt = Pt(menur.min.x+menur.max.x, menur.min.y+Margin);
-	for(i = 0; i<nitem; i++, pt.y += font->height+Vspacing){
-		item = menu->item? menu->item[i] : (*menu->gen)(i);
-		string(&screen,
-			Pt((pt.x-strwidth(font, item))/2, pt.y),
-			font, item, S);
-	}
-	bflush();
-	lasti = menusel(menur, m->xy);
-	r = menurect(menur, menu->lasthit);
-	cursorset(divpt(add(r.min, sub(r.max, Pt(0,Vspacing))), 2));
-	bitblt(&screen, r.min, &screen, r, F&~D);
-	for(;;){
-		*m = emouse();
-		if(!(m->buttons & (1<<(but-1))))
-			break;
-		i = menusel(menur, m->xy);
-		if(i == lasti)
-			continue;
-		bitblt(&screen, r.min, &screen, r, F&~D);
-		r = menurect(menur, i);
-		bitblt(&screen, r.min, &screen, r, F&~D);
-		lasti = i;
-	}
-	bitblt(&screen, menur.min, b, menur, S);
-	if(b != &screen)
-		bfree(b);
-	if(lasti >= 0)
-		menu->lasthit = lasti;
-	return lasti;
-}
//GO.SYSIN DD ./libXg/menuhit.c
echo ./libXg/point.c
sed s/.// > ./libXg/point.c <<'//GO.SYSIN DD ./libXg/point.c'
-#include "libg.h"
-#include "libgint.h"
-
-void
-point(Bitmap *b, Point p, int v, Fcode f)
-{
-	int x, y;
-	GC g;
-
-	x = p.x;
-	y = p.y;
-	if(b->flag&SHIFT){
-		x -= b->r.min.x;
-		y -= b->r.min.y;
-	}
-	g = _getfillgc(f, b, v);
-	XDrawPoint(_dpy, (Drawable)b->id, g, x, y);
-}
//GO.SYSIN DD ./libXg/point.c
echo ./libXg/rdbitmap.c
sed s/.// > ./libXg/rdbitmap.c <<'//GO.SYSIN DD ./libXg/rdbitmap.c'
-#include "libg.h"
-#include "libgint.h"
-
-void
-rdbitmap(Bitmap *b, int miny, int maxy, unsigned char *data)
-{
-	XImage *gim, *eim;
-	int x, y, w, h, pix, n;
-	char *tdata;
-
-	/*
-	 * The XGetImage returned image may be wrong in a number of ways:
-	 * wrong bit order, byte order, bit pad, scanline pad,
-	 * and constant shift.
-	 * So use a SLOW loop, for now
-	 */
-	w = Dx(b->r);
-	h = maxy - miny;
-	gim = XGetImage(_dpy, (Drawable)b->id, 0, miny - b->r.min.y,
-			w, h, ~0, ZPixmap);
-	n = (w * _ld2d[b->ldepth] + 7) / 8 * h;
-	if(n <= 0)
-		return;
-	tdata = (char *)malloc(n);
-	if (!tdata)
-		berror("rdbitmap malloc");
-	eim = XCreateImage(_dpy, 0, _ld2d[b->ldepth], ZPixmap, 0, tdata,
-			w, h, 8, 0);
-	eim->bitmap_pad = 8;
-	eim->bitmap_bit_order = MSBFirst;
-	eim->byte_order = MSBFirst;
-
-	for(y = 0; y < h; y++)
-		for(x = 0; x < w; x++) {
-			pix = XGetPixel(gim, x, y);
-			XPutPixel(eim, x, y, pix);
-		}
-	memcpy((char *)data, tdata, n);
-	XDestroyImage(gim);
-	XDestroyImage(eim);
-}
//GO.SYSIN DD ./libXg/rdbitmap.c
echo ./libXg/rdbitmapfile.c
sed s/.// > ./libXg/rdbitmapfile.c <<'//GO.SYSIN DD ./libXg/rdbitmapfile.c'
-#include "libg.h"
-#include "libgint.h"
-
-#define CHUNK 6000
-
-Bitmap*
-rdbitmapfile(int fd)
-{
-	char hdr[5*12+1];
-	unsigned char *data;
-	long dy, px;
-	unsigned long l, t, n;
-	long miny, maxy;
-	Rectangle r;
-	int ld;
-	Bitmap *b;
-
-	if(read(fd, hdr, 5*12)!=5*12)
-		berror("rdbitmapfile read");
-	ld = atoi(hdr+0*12);
-	r.min.x = atoi(hdr+1*12);
-	r.min.y = atoi(hdr+2*12);
-	r.max.x = atoi(hdr+3*12);
-	r.max.y = atoi(hdr+4*12);
-	if(ld<0 || ld>1)
-		berror("rdbitmapfile ldepth");
-	if(r.min.x>r.max.x || r.min.y>r.max.y)
-		berror("rdbitmapfile rectangle");
-
-	miny = r.min.y;
-	maxy = r.max.y;
-	px = 1<<(3-ld);	/* pixels per byte */
-	/* set l to number of bytes of data per scan line */
-	if(r.min.x >= 0)
-		l = (r.max.x+px-1)/px - r.min.x/px;
-	else{	/* make positive before divide */
-		t = (-r.min.x)+px-1;
-		t = (t/px)*px;
-		l = (t+r.max.x+px-1)/px;
-	}
-	b = balloc(r, ld);
-	if(b == 0)
-		return 0;
-	data = (unsigned char *)malloc(CHUNK);
-	if(data == 0)
-		berror("rdbitmapfile malloc");
-	while(maxy > miny){
-		dy = maxy - miny;
-		if(dy*l > CHUNK)
-			dy = CHUNK/l;
-		n = dy*l;
-		if(read(fd, data, n) != n){
-			free(data);
-			bfree(b);
-			berror("rdbitmapfile read");
-		}
-		wrbitmap(b, miny, miny+dy, data);
-		miny += dy;
-	}
-	free(data);
-	return b;
-}
//GO.SYSIN DD ./libXg/rdbitmapfile.c
echo ./libXg/rectclip.c
sed s/.// > ./libXg/rectclip.c <<'//GO.SYSIN DD ./libXg/rectclip.c'
-#include "libg.h"
-
-rectclip(Rectangle *rp, Rectangle b)		/* first by reference, second by value */
-{
-	Rectangle *bp = &b;
-	/*
-	 * Expand rectXrect() in line for speed
-	 */
-	if((rp->min.x<bp->max.x && bp->min.x<rp->max.x &&
-	    rp->min.y<bp->max.y && bp->min.y<rp->max.y)==0)
-		return 0;
-	/* They must overlap */
-	if(rp->min.x < bp->min.x)
-		rp->min.x = bp->min.x;
-	if(rp->min.y < bp->min.y)
-		rp->min.y = bp->min.y;
-	if(rp->max.x > bp->max.x)
-		rp->max.x = bp->max.x;
-	if(rp->max.y > bp->max.y)
-		rp->max.y = bp->max.y;
-	return 1;
-}
//GO.SYSIN DD ./libXg/rectclip.c
echo ./libXg/segment.c
sed s/.// > ./libXg/segment.c <<'//GO.SYSIN DD ./libXg/segment.c'
-#include "libg.h"
-#include "libgint.h"
-
-void
-segment(Bitmap *d, Point p1, Point p2, int v, Fcode f)
-{
-	int x1, y1, x2, y2;
-	GC g;
-
-	x1 = p1.x;
-	y1 = p1.y;
-	x2 = p2.x;
-	y2 = p2.y;
-	if(d->flag&SHIFT){
-		x1 -= d->r.min.x;
-		y1 -= d->r.min.y;
-		x2 -= d->r.min.x;
-		y2 -= d->r.min.y;
-	}
-	g = _getfillgc(f, d, v);
-	XDrawLine(_dpy, (Drawable)d->id, g, x1, y1, x2, y2);
-}
//GO.SYSIN DD ./libXg/segment.c
echo ./libXg/string.c
sed s/.// > ./libXg/string.c <<'//GO.SYSIN DD ./libXg/string.c'
-#include "libg.h"
-#include "libgint.h"
-
-Point
-string(Bitmap *b, Point p, Font *ft, char *s, Fcode f)
-{
-	int x, y;
-	GC g;
-
-	x = p.x;
-	y = p.y;
-	if (b->flag&SHIFT){
-		x -= b->r.min.x;
-		y -= b->r.min.y;
-	}
-	y += ft->ascent;
-	g = _getfillgc(f, b, ~0);
-	XSetFont(_dpy, g, (xFont)ft->id);
-	XDrawString(_dpy, (Drawable)b->id, g, x, y, s, strlen(s));
-	p.x += strwidth(ft, s);
-	return p;
-}
//GO.SYSIN DD ./libXg/string.c
echo ./libXg/strwidth.c
sed s/.// > ./libXg/strwidth.c <<'//GO.SYSIN DD ./libXg/strwidth.c'
-#include "libg.h"
-#include "libgint.h"
-
-Point
-strsize(Font *f, char *cs)
-{
-	int c, l, n;
-	Fontchar *info;
-	unsigned char *s;
-
-	s = (unsigned char*)cs;
-	l = 0;
-	n = f->n;
-	info = f->info;
-	if(s)
-		while(c = *s++)
-			if(c < n)
-				l += info[c].width;
-	return Pt(l,f->height);
-}
-
-long
-strwidth(Font *f, char *s)
-{
-	Point p;
-
-	p = strsize(f,s);
-	return p.x;
-}
-
-long
-charwidth(Font *f, unsigned short r)
-{
-	if(r >= f->n)
-		return 0;
-	else
-		return f->info[r].width;
-}
//GO.SYSIN DD ./libXg/strwidth.c
echo ./libXg/test.c
sed s/.// > ./libXg/test.c <<'//GO.SYSIN DD ./libXg/test.c'
-#ifdef __STDC__
-#include <stdlib.h>
-#endif
-#include "libg.h"
-#include <stdio.h>
-
-void cont(char *);
-void putstring(char *);
-void colorinit(void);
-
-unsigned char arrowset[] =
-	{0x00, 0x00, 0x7F, 0xC0, 0x7F, 0x00, 0x7C, 0x00,
-	 0x7E, 0x00, 0x7F, 0x00, 0x6F, 0x80, 0x67, 0xC0,
-	 0x43, 0xE0, 0x41, 0xF0, 0x00, 0xF8, 0x00, 0x7C,
-	 0x00, 0x3E, 0x00, 0x1C, 0x00, 0x08, 0x00, 0x00};
-
-char *colors[] = { "Black", "Red", "Green", "Yellow",
-		"Cyan", "Magenta", "Blue", "White" };
-RGB colordefs[] = {
-	{ 0,0,0 },					/* black */
-	{0xFFFFFFFF,	0x00000000,	0x00000000},	/* red */
-	{0x00000000,	0xFFFFFFFF,	0x00000000},	/* green */
-	{0xFFFFFFFF,	0xFFFFFFFF,	0x00000000},	/* yellow */
-	{0x00000000,	0xFFFFFFFF,	0xFFFFFFFF},	/* cyan */
-	{0xFFFFFFFF,	0x00000000,	0xFFFFFFFF},	/* magenta */
-	{0x00000000,	0x00000000,	0xFFFFFFFF},	/* blue */
-	{0xFFFFFFFF,	0xFFFFFFFF,	0xFFFFFFFF},	/* white */
-};
-#define Ncol (sizeof(colordefs)/sizeof(colordefs[0]))
-unsigned long rgbval[Ncol];
-Bitmap *rgbbitmap[Ncol];
-
-main(int argc, char **argv)
-{
-	Point p1,p2,p3;
-	Mouse m;
-	int r,rx,ry;
-	int n, i;
-	char *m3gen(int);
-	static Menu menu3 = { (char **) 0, m3gen, 0 };
-	char *p, buf[200];
-	Bitmap *bm, *bm2;
-
-	xtbinit(0,0,&argc,argv);
-	einit(Ekeyboard|Emouse);
-	p1 = add(screen.r.min, Pt(15,15));
-	p2 = sub(screen.r.max, Pt(15,15));
-	fprintf(stderr, "segment(&screen, (%d,%d), (%d,%d), ~0, S)\n",
-		p1.x,p1.y,p2.x,p2.y);
-	segment(&screen, p1, p2, ~0, S);
-	cont("point");
-	fprintf(stderr, "point(&screen, (%d,%d), ~0, S)\n", p1.x,p1.y);
-	point(&screen, p1, ~0, S);
-	cont("circle");
-	p3 = divpt(add(p1,p2),2);
-	rx = p3.x - p1.x;
-	ry = p3.y - p1.y;
-	r = (rx < ry)? rx : ry;
-	fprintf(stderr, "circle(&screen, (%d,%d), %d, ~0, S)\n",
-		p3.x,p3.y,r);
-	circle(&screen, p3, r, ~0, S);
-	cont("disc");
-	fprintf(stderr, "disc(&screen, (%d,%d), %d, ~0, S)\n",
-		p3.x,p3.y,r);
-	disc(&screen, p3, r, ~0, S);
-	cont("clipped disc");
-	fprintf(stderr, "clipr(&screen, ((%d,%d)(%d,%d))\n",
-		p1.x+30, p1.y+5, p3.x-30, p3.y-5);
-	clipr(&screen, Rect(p1.x+30, p1.y+5, p3.x-30, p3.y-5));
-	fprintf(stderr, "disc(&screen, (%d,%d), %d, ~0, S)\n",
-		p3.x,p3.y,r);
-	disc(&screen, p3, r, ~0, S);
-	clipr(&screen, screen.r);
-	cont("ellipse");
-	fprintf(stderr, "ellipse(&screen, (%d,%d), %d, %d, ~0, S)\n",
-		p3.x,p3.y,r,r/2);
-	ellipse(&screen, p3, r, r/2, ~0, S);
-	cont("arc");
-	fprintf(stderr, "arc(&screen, (%d,%d), (%d,%d), (%d,%d), ~0, S)\n",
-		p3.x,p3.y, p3.x+r,p3.y, p3.x+r/2,p3.x-(int)(r*.866));
-	arc(&screen, p3, Pt(p3.x+r,p3.y), Pt(p3.x+r/2,p3.x-(int)(r*.866)), ~0, S);
-	if(screen.ldepth > 1){
-		cont("color");
-		colorinit();
-		p3 = p1;
-		rx *= 2;
-		ry *= 2;
-		for(i = 0; i<Ncol; i++) {
-			texture(&screen, Rpt(p3,add(p3,Pt(rx,ry/Ncol))),
-				rgbbitmap[i], S);
-        		string(&screen, add(p3,Pt(15,15)), font, colors[i], DxorS);
-			p3.y += ry/Ncol;
-		}
-	}
-	cont("wrbitmap, border, and bitblt(S)");
-	bm = balloc(Rect(0,0,16,16), 0);
-	fprintf(stderr, "border (%d,%d,%d,%d), -2, F)\n",
-		p1.x, p1.y, p1.x+16, p1.y+16);
-	border(&screen, Rpt(p1, add(p1,Pt(16,16))), -2, F);
-	wrbitmap(bm, 0, 16, arrowset);
-	fprintf(stderr, "bitblt(&screen, (%d,%d), bm, (0,0,16,16), S)\n",
-		p1.x,p1.y);
-	bitblt(&screen, p1, bm, Rect(0,0,16,16), S);
-	cont("mouse track (button 1)");
-	do{
-		m = emouse();
-	} while(!(m.buttons&1));
-	fprintf(stderr,"test tracking\n");
-	while(m.buttons&1){
-		point(&screen, m.xy, ~0, S);
-		m = emouse();
-	}
-	cursorswitch(0);
-	cont("menuhit (button 3)");
-	do {
-		do{
-			m = emouse();
-		} while(!(m.buttons&4));
-		n = menuhit(3, &m, &menu3);
-		fprintf(stderr, "button %d\n", n);
-	} while (n != 0);
-	cont("keyboard (end with \\n)");
-	fprintf(stderr, "type something\n");
-	for (p = buf; (*p = ekbd()) != '\n' && *p != '\r'; p++) {
-		fprintf(stderr, "%c", *p);
-		if (*p == '\b')
-			p -= 2;
-		if (p < buf-1)
-			p = buf-1;
-		p[1] = 0;
- 		putstring(buf);
-	}
-	cont("done");
-	exit(0);
-}
-
-void colorinit(void)	/* set up color definitions */
-{
-	int i;
-
-	for (i = 0; i < Ncol; i++) {
-		rgbval[i] = rgbpix(&screen, colordefs[i]);
-		rgbbitmap[i] = balloc(Rect(0,0,1,1), screen.ldepth);
-		point(rgbbitmap[i], Pt(0,0), rgbval[i], S);
-	}
-}
-
-void
-putstring(char *buf)
-{
-        Point p;
-        static int jmax = 0, l;
-
-	p = add(screen.r.min, Pt(20,20));
-	bitblt(&screen, p, &screen, Rect(p.x, p.y, p.x+jmax, p.y+font->height), Zero);
-        string(&screen, p, font, buf, F);
-        if ((l = strwidth(font, buf)) > jmax)
-                jmax = l;
-}
-
-void
-cont(char *msg)
-{
-	Event ev;
-	Point mp;
-
-	while(event(&ev) != Ekeyboard)
-		continue;
-	bitblt(&screen, Pt(0,0), &screen, screen.r, Zero);
-	mp = add(screen.r.min, Pt(20,20));
-	string(&screen, mp, font, msg, S);
-	while(event(&ev) != Ekeyboard)
-		continue;
-	bitblt(&screen, Pt(0,0), &screen, screen.r, Zero);
-}
-
-char *
-m3gen(int n)
-{
-	static char *m3[] ={ "quit", "thing1", "thing2" };
-
-	if (n < 0 || n > 2)
-		return 0;
-	else 
-		return m3[n];
-}
-
-void
-ereshaped(Rectangle r)
-{
-}
//GO.SYSIN DD ./libXg/test.c
echo ./libXg/texture.c
sed s/.// > ./libXg/texture.c <<'//GO.SYSIN DD ./libXg/texture.c'
-#include "libg.h"
-#include "libgint.h"
-
-void
-texture(Bitmap *d, Rectangle r, Bitmap *s, Fcode f)
-{
-	int x, y, w, h, bfunc;
-	GC g;
-
-	x = r.min.x;
-	y = r.min.y;
-	if(d->flag&SHIFT){
-		x -= d->r.min.x;
-		y -= d->r.min.y;
-	}
-	g = _getcopygc(f, d, s, &bfunc);
-	if(d->flag&SHIFT){
-		XSetTSOrigin(_dpy, g, -d->r.min.x, -d->r.min.y);
-	}else
-		XSetTSOrigin(_dpy, g, 0, 0);
-	w = Dx(r);
-	h = Dy(r);
-	if(bfunc == UseFillRectangle){
-		/* source isn't involved at all */
-		XFillRectangle(_dpy, (Drawable)d->id, g, x, y, w, h);
-	}else if(bfunc == UseCopyArea){
-		XSetTile(_dpy, g, (Drawable)s->id);
-		XSetFillStyle(_dpy, g, FillTiled);
-		XFillRectangle(_dpy, (Drawable)d->id, g, x, y, w, h);
-		XSetFillStyle(_dpy, g, FillSolid);
-	}else{
-		if(s->ldepth != 0)
-			berror("unsupported texture");
-		XSetStipple(_dpy, g, (Drawable)s->id);
-		XSetFillStyle(_dpy, g, FillOpaqueStippled);
-		XFillRectangle(_dpy, (Drawable)d->id, g, x, y, w, h);
-		XSetFillStyle(_dpy, g, FillSolid);
-	}
-}
//GO.SYSIN DD ./libXg/texture.c
echo ./libXg/wrbitmap.c
sed s/.// > ./libXg/wrbitmap.c <<'//GO.SYSIN DD ./libXg/wrbitmap.c'
-#include "libg.h"
-#include "libgint.h"
-#include <X11/Intrinsic.h>
-#ifndef XtSpecificationRelease
-#define R3
-#endif
-
-void
-wrbitmap(Bitmap *b, int miny, int maxy, unsigned char *data)
-{
-	XImage *im;
-	int w, h, n, dep;
-	GC g;
-
-	w = Dx(b->r);
-	h = maxy - miny;
-	dep = _ld2d[b->ldepth];
-	im = XCreateImage(_dpy, 0, dep, ZPixmap, 0,
-			(char*)data, w, h, 8, (w*dep+7)/8);
-
-	/* Botched interface to XCreateImage doesn't let you set these: */
-	im->bitmap_bit_order = MSBFirst;
-	im->byte_order = MSBFirst;
-
-	g = _getfillgc(S, b, ~0);
-	XSetBackground(_dpy, g, b->flag&DP1 ? 0 : _bgpixel);
-	XPutImage(_dpy, (Drawable)b->id, g, im, 0, 0, 0, miny - b->r.min.y, w, h);
-}
//GO.SYSIN DD ./libXg/wrbitmap.c
echo ./libXg/wrbitmapfile.c
sed s/.// > ./libXg/wrbitmapfile.c <<'//GO.SYSIN DD ./libXg/wrbitmapfile.c'
-#include "libg.h"
-#include "libgint.h"
-
-#define	CHUNK	4096
-
-void
-wrbitmapfile(int fd, Bitmap *b)
-{
-	char hdr[5*12+1];
-	unsigned char *data;
-	long dy, px;
-	unsigned long l, t, n;
-	long miny, maxy;
-
-	sprint(hdr, "%11d %11d %11d %11d %11d ",
-		b->ldepth, b->r.min.x, b->r.min.y, b->r.max.x, b->r.max.y);
-	if(write(fd, hdr, 5*12) != 5*12)
-		berror("wrbitmapfile write");
-
-	px = 1<<(3-b->ldepth);	/* pixels per byte */
-	/* set l to number of bytes of data per scan line */
-	if(b->r.min.x >= 0)
-		l = (b->r.max.x+px-1)/px - b->r.min.x/px;
-	else{	/* make positive before divide */
-		t = (-b->r.min.x)+px-1;
-		t = (t/px)*px;
-		l = (t+b->r.max.x+px-1)/px;
-	}
-	miny = b->r.min.y;
-	maxy = b->r.max.y;
-	data = (unsigned char *)malloc(CHUNK);
-	if(data == 0)
-		berror("wrbitmapfile malloc");
-	while(maxy > miny){
-		dy = maxy - miny;
-		if(dy*l > CHUNK)
-			dy = CHUNK/l;
-		rdbitmap(b, miny, miny+dy, data);
-		n = dy*l;
-		if(write(fd, data, n) != n){
-			free(data);
-			berror("wrbitmapfile write");
-		}
-		miny += dy;
-	}
-	free(data);
-}
//GO.SYSIN DD ./libXg/wrbitmapfile.c
echo ./libXg/xtbinit.c
sed s/.// > ./libXg/xtbinit.c <<'//GO.SYSIN DD ./libXg/xtbinit.c'
-#include "libg.h"
-#include <stdio.h>
-#include "libgint.h"
-
-#define COMPRESSMOUSE
-
-#define Cursor xCursor
-#define Font xFont
-#define Event xEvent
-
-#include <X11/Intrinsic.h>
-#include <X11/StringDefs.h>
-#include <X11/Shell.h>
-#include "Gwin.h"
-
-#ifndef XtSpecificationRelease
-#define R3
-#define XtAppInitialize(a,b,c,d,e,f,g,h,i) XtInitialize(0,b,c,d,e,f)
-#define XtConvertAndStore(a,b,c,d,e) (XtConvert(a,b,c,d,e),1)
-#define XtAppPending(a) XtPending()
-#define XtAppProcessEvent(a,b) XtProcessEvent(b)
-#define XtAppAddTimeOut(a,b,c,d) XtAddTimeOut(b,c,d)
-#define XtAppAddInput(a,b,c,d,e) XtAddInput(b,c,d,e)
-#define XtPointer caddr_t
-#endif
-
-#undef Cursor
-#undef Font
-#undef Event
-
-/* libg globals */
-Bitmap	screen;
-Font	*font;
-
-/* implementation globals */
-Display	*_dpy;
-Widget	_toplevel;
-unsigned long	_fgpixel, _bgpixel;
-XColor	_fgcolor, _bgcolor;
-int	_ld2d[6] = { 1, 2, 4, 8, 16, 32 };
-unsigned long _ld2dmask[6] = { 0x1, 0x3, 0xF, 0xFF, 0xFFFF, 0xFFFFFFFF };
-
-/* xbinit implementation globals */
-#ifndef R3
-static XtAppContext app;
-#endif
-static Widget widg;
-static int exposed = 0;
-static Atom wm_take_focus;
-static Mouse lastmouse;
-
-typedef struct Ebuf {
-	struct Ebuf	*next;
-	int		n;
-	unsigned char	buf[2];
-} Ebuf;
-
-typedef struct Esrc {
-	int	inuse;
-	int	size;
-	Ebuf	*head;
-	Ebuf	*tail;
-} Esrc;
-
-#define MAXSRC 10
-
-static Esrc	esrc[MAXSRC];
-static int	nsrc;
-
-/* Make sure Smouse = log2(Emouse) and Skeyboard == log2(Ekeyboard) */
-#define Smouse	  0
-#define Skeyboard 1
-
-static int einitcalled = 0;
-static int Stimer = -1;
-
-
-static void	reshaped(int, int, int, int);
-static void	gotchar(int);
-static void	gotmouse(Gwinmouse *);
-static int	log2(int);
-static void	pixtocolor(Pixel, XColor *);
-static Font	*XFontStructtoFont(XFontStruct *);
-static Ebuf	*ebread(Esrc *);
-static Ebuf	*ebadd(Esrc *);
-static void	focinit(Widget);
-static void	wmproto(Widget, XEvent *, String *, Cardinal *);
-
-static Errfunc	onerr;
-
-String fallbacks[] = {
-	"*gwin.width: 400",
-	"*gwin.height: 400",
-	NULL
-};
-
-#ifndef R3
-static char *shelltrans = 
-	"<ClientMessage> WM_PROTOCOLS : WMProtocolAction()";
-static XtActionsRec wmpactions[] = {
-	{"WMProtocolAction", wmproto}
-};
-#endif
-
-void
-xtbinit(Errfunc f, char *class, int *pargc, char **argv)
-{
-	int n;
-	unsigned int depth;
-	XFontStruct *xf;
-	Arg args[10];
-	char *p;
-	XSetWindowAttributes attr;
-
-	if(!class && argv[0]){
-		p = strrchr(argv[0], '/');
-		if(p)
-			class = XtNewString(p+1);
-		else
-			class = XtNewString(argv[0]);
-		if(class[0] >= 'a' && class[0] <= 'z')
-			class[0] += 'A' - 'a';
-	}
-	onerr = f;
-	n = 0;
-	XtSetArg(args[n], XtNinput, TRUE);		n++;
-	_toplevel = XtAppInitialize(&app, class, 0, 0,
-			(int*)pargc, argv, fallbacks, args, n);
-
-	n = 0;
-	XtSetArg(args[n], XtNreshaped, reshaped);	n++;
-	XtSetArg(args[n], XtNgotchar, gotchar);		n++;
-	XtSetArg(args[n], XtNgotmouse, gotmouse);	n++;
-	widg = XtCreateManagedWidget("gwin", gwinWidgetClass, _toplevel, args, n);
-
-	n = 0;
-	XtSetArg(args[n], XtNforeground, &_fgpixel);	n++;
-	XtSetArg(args[n], XtNbackground, &_bgpixel);	n++;
-	XtSetArg(args[n], XtNdepth, &depth);		n++;
-	XtSetArg(args[n], XtNfont, &xf);		n++;
-	XtGetValues(widg, args, n);
-
-	_dpy = XtDisplay(widg);
-	font = XFontStructtoFont(xf);
-	screen.id = 0;
-	XtRealizeWidget(_toplevel);
-	pixtocolor(_fgpixel, &_fgcolor);
-	pixtocolor(_bgpixel, &_bgcolor);
-	screen.id = (int) XtWindow(widg);
-	screen.ldepth = log2(depth);
-	screen.flag = SCR;
-	if(_fgpixel != 0)
-		screen.flag |= BL1;
-	if(depth == 1)
-		screen.flag |= DP1;
-	/* leave screen rect at all zeros until reshaped() sets it */
-	while(!exposed)
-		bflush();
-	XFlush(_dpy);
-	focinit(_toplevel);
-}
-
-static void
-focinit(Widget w)
-{
-#ifndef R3
-	XrmValue src, dst;
-
-	src.addr = "WM_TAKE_FOCUS";
-	src.size = strlen((char *)src.addr)+1;
-	dst.addr = (XtPointer) &wm_take_focus;
-	dst.size = sizeof(Atom);
-	XtConvertAndStore(w, XtRString, &src, XtRAtom, &dst);
-	XSetWMProtocols(XtDisplay(w), XtWindow(w), &wm_take_focus, 1);
-	XtAppAddActions(app, wmpactions, XtNumber(wmpactions));
-	XtAugmentTranslations(w, XtParseTranslationTable(shelltrans));
-#endif
-}
-
-#ifndef R3
-static void
-wmproto(Widget w, XEvent *e , String *p, Cardinal *np)
-{
-	Time t;
-
-	if(e->type == ClientMessage &&
-          (Atom)(e->xclient.data.l[0]) == wm_take_focus) {
-		t = (Time) e->xclient.data.l[1];
-		XtCallAcceptFocus(widg, &t);
-	}
-}
-#endif
-
-static void
-reshaped(int minx, int miny, int maxx, int maxy)
-{
-	Ebuf *eb;
-	Mouse m;
-
-	exposed = 1;
-	screen.r = Rect(minx, miny, maxx, maxy);
-	screen.clipr = screen.r;
-	if (screen.id)
-		ereshaped(screen.r);
-	if(einitcalled){
-		/*
-		 * Cause a mouse event, so programs like sam
-		 * will get out of eread and REALLY do the reshape
-		 */
-		eb = ebadd(&esrc[Smouse]);
-		memcpy(eb->buf, &lastmouse, sizeof lastmouse);
-	}
-}
-
-static void
-gotchar(int c)
-{
-	Ebuf *eb;
-
-	if(!einitcalled || !esrc[Skeyboard].inuse)
-		return;
-	eb = ebadd(&esrc[Skeyboard]);
-	if(c == '\r')
-		c = '\n';
-	BPSHORT(eb->buf, (unsigned short)(c & 0xffff));
-}
-
-static void
-gotmouse(Gwinmouse *gm)
-{
-	Ebuf *eb;
-	Mouse m;
-
-	if(!einitcalled || !esrc[Smouse].inuse)
-		return;
-	m.buttons = gm->buttons;
-	m.xy.x = gm->xy.x;
-	m.xy.y = gm->xy.y;
-	m.msec = gm->msec;
-	lastmouse = m;
-	eb = ebadd(&esrc[Smouse]);
-	memcpy(eb->buf, &m, sizeof m);
-}
-
-static void
-gotinput(XtPointer cldata, int *pfd, XtInputId *id)
-{
-	Ebuf *eb;
-	Esrc *es;
-
-	if(!einitcalled)
-		return;
-	es = (Esrc *)cldata;
-	eb = ebadd(es);
-	if(es->size){
-		eb->n = read(*pfd, (char *)eb->buf, es->size);
-		if(eb->n < 0)
-			eb->n = 0;
-	}
-}
-
-static void
-gottimeout(XtPointer cldata, XtIntervalId *id)
-{
-	if(!einitcalled || Stimer == -1)
-		return;
-	/*
-	 * Don't queue up timeouts, because there's
-	 * too big a danger that they might pile up
-	 * too quickly.
-	 */
-	esrc[Stimer].head = (Ebuf *)1;
-	XtAppAddTimeOut(app, (int)cldata, gottimeout, cldata);
-}
-
-static int
-log2(int n)
-{
-	int i, v;
-
-	for(i=0, v=1; i < 32; i++, v<<=1)
-		if(n == v)
-			break;
-	return i;
-}
-
-static void
-pixtocolor(Pixel p, XColor *pc)
-{
-#ifdef R3
-	Colormap cmap;
-	Arg args[2];
-	int n;
-
-	n = 0;
-	XtSetArg(args[n], XtNcolormap, &cmap);	n++;
-	XtGetValues(widg, args, n);
-	pc->pixel = p;
-	XQueryColor(_dpy, cmap, pc);
-#else
-	XrmValue xvf, xvt;
-
-	xvf.size = sizeof(Pixel);
-	xvf.addr = (XtPointer)&p;
-	xvt.size = sizeof(XColor);
-	xvt.addr = (XtPointer)pc;
-	if(!XtConvertAndStore(widg, XtRPixel, &xvf, XtRColor, &xvt))
-		pc->pixel = p;	/* maybe that's enough */
-#endif
-}
-
-unsigned long
-rgbpix(Bitmap *b, RGB col)
-{
-	XColor c;
-	Colormap cmap;
-	Arg args[2];
-	int n;
-
-
-	n = 0;
-	XtSetArg(args[n], XtNcolormap, &cmap);	n++;
-	XtGetValues(widg, args, n);
-	c.red = col.red>>16;
-	c.green = col.green>>16;
-	c.blue = col.blue>>16;
-	c.flags = DoRed|DoGreen|DoBlue;
-	if(!XAllocColor(_dpy, cmap, &c))
-		return 0;	/* what to do? */
-	return (unsigned long)(c.pixel);
-}
-
-void
-rdcolmap(Bitmap *b, RGB *map)
-{
-	XColor cols[256];
-	int n, depth;
-	Colormap cmap;
-	Arg args[2];
-
-	n = 0;
-	XtSetArg(args[n], XtNcolormap, &cmap);	n++;
-	XtGetValues(widg, args, n);
-
-	depth = 1 << screen.ldepth;
-	if (depth == 1) {
-		map[0].red = map[0].green = map[0].blue = ~0;
-		map[1].red = map[1].green = map[1].blue = 0;
-	}
-	else {
-		for (n = 0; n < (1 << depth); n++)
-			cols[n].pixel = n;
-		XQueryColors(_dpy, cmap, cols, 1 << depth);
-		for (n = 0; n < (1 << depth); n++) {
-			map[n].red = (cols[n].red << 16) | cols[n].red;
-			map[n].green = (cols[n].green << 16) | cols[n].green;
-			map[n].blue = (cols[n].blue << 16) | cols[n].blue;
-		}
-	}
-}
-
-Font *
-getfont(char *s)
-{
-	XFontStruct *fp;
-
-	if(!s)
-		return 0;
-	fp = XLoadQueryFont(_dpy, s);
-	if(!fp)
-		return 0;
-	return XFontStructtoFont(fp);
-}
-
-static Font *
-XFontStructtoFont(XFontStruct *fp)
-{
-	XCharStruct *cp;
-	Font *f;
-	int i;
-
-	if(!fp)
-		berror("no font");
-	f = (Font *)malloc(sizeof(Font));
-	if(!f)
-		berror("getfont malloc");
-	f->id = fp->fid;
-	f->n = fp->max_char_or_byte2+1;
-	f->height = fp->max_bounds.ascent + fp->max_bounds.descent;
-	f->ascent = fp->max_bounds.ascent;
-	f->info = (Fontchar *)malloc((f->n+1)*sizeof(Fontchar));
-	if(!f->info)
-		berror("getfont malloc");
-	memset(f->info, 0, (f->n+1)*sizeof(Fontchar));
-	for(i = fp->min_char_or_byte2; i < f->n; i++){
-		if(fp->per_char)
-			cp = fp->per_char + i - fp->min_char_or_byte2;
-		else
-			cp = &fp->max_bounds;
-		f->info[i].left = cp->lbearing;
-		f->info[i].width = cp->width;
-		f->info[i].top = 0;
-		f->info[i].bottom = f->height;
-	}
-	XFreeFontInfo(0, fp, 1);
-	return f;
-}
-
-int
-scrollfwdbut(void)
-{
-	Arg arg;
-	Boolean v;
-
-	XtSetArg(arg, XtNscrollForwardR, &v);
-	XtGetValues(widg, &arg, 1);
-	return v? 3 : 1;
-}
-
-void
-einit(unsigned long keys)
-{
-	nsrc = 0;
-	if(keys&Emouse){
-		esrc[Smouse].inuse = 1;
-		esrc[Smouse].size = sizeof(Mouse);
-		nsrc = Smouse+1;
-	}
-	if(keys&Ekeyboard){
-		esrc[Skeyboard].inuse = 1;
-		esrc[Skeyboard].size = 1;
-		if(Skeyboard >= nsrc)
-			nsrc = Skeyboard+1;
-	}
-	einitcalled = 1;
-}
-
-unsigned long
-estart(unsigned long key, int fd, int n)
-{
-	int i;
-
-	if(fd < 0)
-		berror("bad fd to estart");
-	if(n <= 0 || n > EMAXMSG)
-		n = EMAXMSG;
-	for(i=0; i<MAXSRC; i++)
-		if((key & ~(1<<i)) == 0 && !esrc[i].inuse){
-			if(nsrc <= i)
-				nsrc = i+1;
-			esrc[i].inuse = 1;
-			esrc[i].size = n;
-			XtAppAddInput(app, fd, (XtPointer)XtInputReadMask,
-				gotinput, (XtPointer) &esrc[i]);
-			return 1<<i;
-		}
-	return 0;
-}
-
-unsigned long
-etimer(unsigned long key, int n)
-{
-	int i;
-
-	if(Stimer != -1)
-		berror("timer started twice");
-	if(n <= 0)
-		n = 1000;
-	for(i=0; i<MAXSRC; i++)
-		if((key & ~(1<<i)) == 0 && !esrc[i].inuse){
-			if(nsrc <= i)
-				nsrc = i+1;
-			esrc[i].inuse = 1;
-			esrc[i].size = 0;
-			XtAppAddTimeOut(app, n, gottimeout, (XtPointer)n);
-			Stimer = i;
-			return 1<<i;
-		}
-	return 0;
-}
-
-unsigned long
-event(Event *e)
-{
-	return eread(~0L, e);
-}
-
-unsigned long
-eread(unsigned long keys, Event *e)
-{
-	Ebuf *eb;
-	int i;
-
-	if(keys == 0)
-		return 0;
-	for(;;){
-		for(i=0; i<nsrc; i++)
-			if((keys & (1<<i)) && esrc[i].head){
-				if(i == Smouse)
-					e->mouse = emouse();
-				else if(i == Skeyboard)
-					e->kbdc = ekbd();
-				else if(i == Stimer)
-					esrc[i].head = 0;
-				else{
-					eb = ebread(&esrc[i]);
-					e->n = eb->n;
-					if(e->n > 0)
-						memcpy(e->data, eb->buf, e->n);
-					free(eb);
-				}
-				return 1<<i;
-			}
-		XtAppProcessEvent(app, XtIMAll);
-	}
-}
-
-Mouse
-emouse(void)
-{
-	Mouse m;
-	Ebuf *eb;
-
-	if(!esrc[Smouse].inuse)
-		berror("mouse events not selected");
-	eb = ebread(&esrc[Smouse]);
-	memcpy(&m, eb->buf, sizeof(Mouse));
-	free(eb);
-	return m;
-}
-
-int
-ekbd(void)
-{
-	Ebuf *eb;
-	int c;
-
-	if(!esrc[Skeyboard].inuse)
-		berror("keyboard events not selected");
-	eb = ebread(&esrc[Skeyboard]);
-	c = BGSHORT(eb->buf);
-	free(eb);
-	return c;
-}
-
-int
-ecanread(unsigned long keys)
-{
-	int i;
-
-	for(;;){
-		for(i=0; i<nsrc; i++){
-			if((keys & (1<<i)) && esrc[i].head)
-				return 1<<i;
-		}
-		if(XtAppPending(app))
-			XtAppProcessEvent(app, XtIMAll);
-		else
-			return 0;
-	}
-}
-
-int
-ecanmouse(void)
-{
-	if(!esrc[Smouse].inuse)
-		berror("mouse events not selected");
-	return ecanread(Emouse);
-}
-
-int
-ecankbd(void)
-{
-	if(!esrc[Skeyboard].inuse)
-		berror("keyboard events not selected");
-	return ecanread(Ekeyboard);
-}
-
-static Ebuf*
-ebread(Esrc *s)
-{
-	Ebuf *eb;
-
-	while(s->head == 0)
-		XtAppProcessEvent(app, XtIMAll);
-	eb = s->head;
-#ifdef COMPRESSMOUSE
-	if(s == &esrc[Smouse]) {
-		while(eb->next) {
-			s->head = eb->next;
-			free(eb);
-			eb = s->head;
-		}
-	}
-#endif
-	s->head = s->head->next;
-	if(s->head == 0)
-		s->tail = 0;
-	return eb;
-}
-
-static Ebuf*
-ebadd(Esrc *s)
-{
-	Ebuf *eb;
-	int m;
-
-	m = sizeof(Ebuf);
-	if(s->size > 1)
-		m += (s->size-1);	/* overestimate, because of alignment */
-	eb = (Ebuf *)malloc(m);
-	if(!eb)
-		berror("eballoc can't malloc");
-	eb->next = 0;
-	eb->n = s->size;
-	if(s->tail){
-		s->tail->next = eb;
-		s->tail = eb;
-	}else
-		s->head = s->tail = eb;
-	return eb;
-}
-
-void
-berror(char *s)
-{
-	if(onerr)
-		(*onerr)(s);
-	else{
-		fprintf(stderr, "libg error: %s:\n", s);
-		exit(1);
-	}
-}
-
-void
-bflush(void)
-{
-	while(XtAppPending(app))
-		XtAppProcessEvent(app, XtIMAll);
-}
-
-int
-snarfswap(char *s, int n, char **t)
-{
-	*t = GwinSelectionSwap(widg, s);
-	if (*t)
-		return strlen(*t);
-	return 0;
-}
-
-#ifdef DEBUG
-/* for debugging */
-printgc(char *msg, GC g)
-{
-	XGCValues v;
-
-	XGetGCValues(_dpy, g, GCFunction|GCForeground|GCBackground|GCFont|
-			GCTile|GCFillStyle|GCStipple, &v);
-	fprintf(stderr, "%s: gc %x\n", msg, g);
-	fprintf(stderr, "  fg %d bg %d func %d fillstyle %d font %x tile %x stipple %x\n",
-		v.foreground, v.background, v.function, v.fill_style,
-		v.font, v.tile, v.stipple);
-}
-#endif
-
//GO.SYSIN DD ./libXg/xtbinit.c
