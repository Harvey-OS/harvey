%\iffalse
%/////////////////////////////////////////
%   Generic bibliography style           /
%   Adapted from XBTXBST.DOC             /
%   for use with or without MAKEBST.TEX  /
%/////////////////////////////////////////
% This file is self-documenting: simply LaTeX it!
%% (Here are the specifications of the source file)
%\fi
%<*selfdoc>
\ifx\undefined\endoptions\def\next{%
   \NeedsTeXFormat{LaTeX2e}%
   \documentclass[a4paper,11pt]{article}%
   \usepackage{doc}%
   \def\skipguard##1>{}\MakePercentIgnore\skipguard}\else\let\next\relax\fi
\next
%</selfdoc>
%% \def\filename{xbtxbst.mbs}
%% \def\filedate{1994 July 1}
%% \def\fileversion{1.1}
%\iffalse
%% NOTICE:
%% This file may be used for non-profit purposes.
%% It may not be distributed in exchange for money, 
%%   other than distribution costs.
%%   
%% The author provides it `as is' and does not guarantee it in any way.
%% 
%% Copyright (C) 1993 Patrick W. Daly
%% Max-Planck-Institut f\"ur Aeronomie
%% Postfach 20
%% D-37189 Katlenburg-Lindau
%% Germany
%% 
%% E-mail:
%% SPAN--     nsp::linmpi::daly    (note nsp also known as ecd1)
%% Internet-- daly@linmpi.dnet.gwdg.de   
%%-----------------------------------------------------------
%   For use with docstrip to select various style parameters
%   This is derived from XBTXBST.DOC version 1.02 of Nelson H.F.Beebe
%   which in turn is derived from Oren Patashnik's BTXBST.DOC.
%   The original files are meant to be processed with a C Preprocessor.
%   I have modified it to run under Frank Mittelbach's DOCSTRIP 
%   program instead, with or without my MAKEBST interface. (MAKEBST
%   uses information in this file to produce, with interactive menus,
%   a DOCSTRIP batch job). I have also taken over Patashnik's (and Beebe's)
%   comments and LaTeXized them so that this whole thing can produce a
%   doc.sty type description. Just LaTeX this file to get it (you will
%   need doc.sty, however).
%                                              PWD
%\fi
%% \CharacterTable
%%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%%   Digits        \0\1\2\3\4\5\6\7\8\9
%%   Exclamation   \!     Double quote  \"     Hash (number) \#
%%   Dollar        \$     Percent       \%     Ampersand     \&
%%   Acute accent  \'     Left paren    \(     Right paren   \)
%%   Asterisk      \*     Plus          \+     Comma         \,
%%   Minus         \-     Point         \.     Solidus       \/
%%   Colon         \:     Semicolon     \;     Less than     \<
%%   Equals        \=     Greater than  \>     Question mark \?
%%   Commercial at \@     Left bracket  \[     Backslash     \\
%%   Right bracket \]     Circumflex    \^     Underscore    \_
%%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%%   Right brace   \}     Tilde         \~}
%
% \CodelineIndex
% ^^A\OnlyDescription
% \setcounter{StandardModuleDepth}{1}
% \begin{document}
% 
% \setcounter{IndexColumns}{2}
% \setlength{\IndexMin}{10cm}
%
% \changes{1.0}{1993 Aug 16}{Initial version}
% \changes{1.1}{1994 July 1}{Change documentation to \LaTeX2e}
% \changes{1.1}{1994 July 1}{Add possibility of NFSS commands}
%
% ^^A Change margins to center text
% \setlength{\oddsidemargin}{0.5\paperwidth}
% \addtolength{\oddsidemargin}{-0.5\textwidth}
% \addtolength{\oddsidemargin}{-1in}
% \setlength{\evensidemargin}{\oddsidemargin}
% 
% \pagestyle{headings}
%
% \title{\bfseries Docstrip Version of XBTXBST.DOC}
%    
% \author{P. W. Daly}
%
% \date{This paper describes file \texttt{\filename},\\
%  version \fileversion{} from \filedate}
% 
% \maketitle
%
% \MakeShortVerb{\|}
% 
% \parskip=1ex \parindent=0pt
%
% \newcommand{\btx}{\textsc{Bib}\TeX}
% \newcommand{\dtx}{\textsf{docstrip}}
% 
% \part{About This File}
% \section{Introduction}
% When I got the idea of using Frank Mittelbach's \dtx{} program to
% make up generic, or master, bibliographic style files for \btx, I took
% the standard {\tt.bst} file {\tt plain} plus {\tt apalike} (also from
% Patashnik) and merged them as my model. I wanted to add various options
% using \dtx{} alternative coding, as explained in the next
% sections. However, in order to find out what bibliographic features were
% being used by others, I copied every {\tt.bst} file I could find in order
% to compare the results. In this way I discovered {\tt xbtxbst.doc}, a
% modified version of {\tt btxbst.doc} that includes ISBN and ISSN
% numbers, as well as a |periodical| type. The {\tt.bst} styles produced
% from it are normally prefixed with |is-| to distinguish them from the 
% original four.
% 
% The original file {\tt btxbst.doc} is
% Patashnik's master file for producing the four standard {\tt.bst} files,
% and it works exactly as I visualized using \dtx{}, but with a
% C-pre\-pro\-cessor. It contains only 6 options. It was no great problem
% to convert the preprocessor commands to \dtx{} equivalents.
% 
% However, what is even more interesting is the extensive comments from
% Patashnik that fill the coding. These are simply {\sc ascii} comments,
% but I decided to try to convert them to \LaTeX{} format in order to
% produce a true internally documented file in the manner of Mittelbach's
% {\tt doc.sty} system. For anyone struggling through \btx{} formatting
% language, this will be a great relief.
% 
% I provide this file in such a manner that when it is \LaTeX{}ed, it only
% produces my introductory text, describing master files and {\tt makebst},
% as well as the menus for running {\tt makebst} and \dtx{}. To
% obtain the whole \btx{} coding, with Patashnik's comments, you must
% remove the line |% \OnlyDescription| near the beginning. Removal is done
% not by adding a \% sign (they have been turned off!) but by physical
% deletion, or better, by adding |^^A|, as |% ^^A\OnlyDescription|. This is 
% a speciality of {\tt doc.sty}, and not of normal \LaTeX.
%
% \section{About Master Bibliographic Style Files}
% \subsection{The \dtx{} Options}
% This master file is a \btx{} bibliographic style file containing
% alternative coding depending on \dtx{} options. The options are
% selected when \dtx{} is run, either interactively or through a
% batch job. 
% 
% Suppose that one of the options is called {\tt xyz}. Then the following
% alternatives are possible:
% \begin{quote}
% |%<xyz> | \em one line of coding
% \end{quote}
% \emph{includes} the single line of coding;
% \begin{quote}
% |%<!xyz> | \em one line of coding 
% \end{quote}
% \emph{excludes} the single line;
% \begin{quote}
% |%<*xyz> | \\
% \emph{several lines of coding}\\
% |%</xyz> | 
% \end{quote}
% \emph{includes} all the bracketted lines;
% \begin{quote}
% |%<*!xyz> | \\
% \emph{several lines of coding}\\
% |%</!xyz> | 
% \end{quote}
% \emph{excludes} all the bracketted lines.
% 
% Options may be logically combined: the symbol \verb!|! is a logical {\sf
% or}, |&| a logical {\sf and}, |!| a logical {\sf not}; parentheses {\tt(}
% and {\tt)} may be used to group options.
% 
% \subsection{The \dtx{} Batch Job}
% In order to generate a true \btx{} style file with selected options from
% this master file, it is necessary to run a \dtx{} batch job.
% Suppose that the master file is named {\tt master.mbs}, and the
% resulting \btx{} style file is to be {\tt silly.bst}, and the batch job
% file itself is called {\tt silly.drv}. To produce this with options, say,
% {\tt xyz} and {\tt abc}, the batch job would look something like:
% \begin{quote}\begin{verbatim}
% \def\batchfile{silly.drv}
% \input docstrip
% 
% \preamble
% This is for Journal of Silly Results
% \endpreamble
% 
% \postamble
% End of customized bst file
% \endpostamble
% 
% \keepsilent
% 
% \generateFile{silly.bst}{f}{\from{master.mbs}{xyz,abc}}
% \end{verbatim}
% \end{quote}
% A preamble is not necessary, although it is advisable to include some
% statement about the application of the bibliographic style. A postamble
% \emph{is} vital, otherwise the default will add |\endinput| at the end
% of the file, something that \btx{} will not understand. The |\keepsilent|
% is optional and just suppresses \dtx{} output during processing.
% 
% \subsection{The {\tt makebst} Program}
% The program {\tt makebst} simplifies the creation of the batch job file. To
% do that, it needs information on the available options. This information
% must be stored in a special format, either in the master file itself, or
% in a file with the same root name but extension {\tt.opt}. The form of
% this format is described in the documentation on {\tt makebst}.
% 
% In the master file, this information must be enclosed within \dtx{}
% options |%<*options>| \dots |%</options>| and \emph{must} include an
% |\endoptions| command. It may also include any number of comments. 
% 
% A sample menu in the master file to select one or none of options {\tt
% xyz} \emph{or} {\tt zyx} would look thus:
% \begin{quote}\begin{verbatim}
% %<*options>
% \mes{Select one of these}
% \optdef{f}{xyz}{Option forword}{to do forward stuff}
% \optdef{r}{zyx}{Option reverse}{to do reverse stuff}
% \optdef{*}{}{None of the above}{}
% \getans
% \endoptions
% %</options>
% %<*!options>
% . . . . . . 
% %</!options>
% \end{verbatim}
% \end{quote}
% An explanation of these commands is to be found in the documentation on 
% {\tt makebst}.
% 
% The menu information may be extracted from the master file by means of
% \dtx{} and stored in a file with extension {\tt.opt}. If this
% file is missing, the program tries to read it from the master file.
% 
% \section{The Options}
% The original file {\tt xbtxbst.doc} contains only 6 options for the
% C-pre\-pro\-cessor, which I have easily changed to 6 corresponding 
% \dtx{} options. (By comparison, my own master bibliographic style file
% offers about 30.) 
% 
% These six options are:
% \renewcommand{\descriptionlabel}[1]{\hspace\labelsep \tt #1}
% \begin{description}
% \item[lab-alph] an alphabetic label is produced instead of a running
%    number;
%    
% \item[sorted] the references are listed alphabetically by author(s); if
%    this is option is not given, then they appear in the list in the same
%    order as they are cited in the text;
%    
% \item[name-full] first names of authors and editors are written out
%    (provided they have been given in the entry); if this option is
%    missing, then the first names are initialized;
% 
% \item[atit-lower] words in the titles of non-books (i.e., articles) are
%    converted to lowercase, other than the first word, and any words enclosed
%    in braces; if not given, such titles are reproduced as they are in the
%    entry;
%    
% \item[month-full] the names of months are written out in full; otherwise
%    they are abbreviated;
%    
% \item[jour-full] the names of the pre-defined journals are written out in
%    full; otherwise they are abbreviated.
% 
% \end{description}
% 
% The following table shows the values of these options for the four
% standard bibliographic styles (+ means active, $-$ means not active):
% \DeleteShortVerb{\|}
% \begin{center}
% \begin{tabular}{c|cccc}
% \emph{Option} & \tt plain & \tt unsrt & \tt abbrv & \tt alph \\ \hline
% \tt lab-alph &     $-$   &     $-$   &     $-$   &    +      \\
% \tt sorted   &      +    &     $-$   &      +    &    +      \\
% \tt name-full&      +    &      +    &     $-$   &    +      \\
% \tt atit-lower&     +    &      +    &      +    &    +      \\
% \tt month-full&     +    &      +    &     $-$   &    +      \\
% \tt jour-full&      +    &      +    &     $-$   &    +      \\ \hline
% \end{tabular}\end{center}
% \MakeShortVerb{\|}
%
% To this I have now added a seventh option:
% \begin{description}
% \item[nfss] to use NFSS font commands instead of the older \LaTeX~2.09 ones.
% \end{description}
% This means that |\emph{text}| is used in place of |{\em text}|. Such a
% {\tt.bst} file can only be used with \LaTeXe. This allows an easy way to
% update the standard four {\tt.bst} files to the new \LaTeX.
%
% \section{The Menu Information}
% Here I describe the options and menu information for this particular
% master file for use with {\tt makebst}.
% 
% All this menu information is nested between \dtx{} guard options
% |%<*options>| \dots\ |%</options>|, and the last command is
% |\endoptions|. The rest of the file is nested between |%<*!options>|
% \dots\ |%</!options>| in order to exclude it if \dtx{} is used to
% extract only the menu information.
% 
% First the menu identifies itself.
%    \begin{macrocode}
%<*options>
\mes{^^JThis is XBTXBST.DOC, hacked to work with DOCSTRIP instead}
\mes{\space\space of with a C Preprocessor}
\mes{\space\space It is the Master File for the (extended) standard BibTeX}
\mes{\space\space styles plain, unsrt, abbrv, and alpha}
\mes{\space\space (Extended means ISBN and ISSN are included as fields)}
%    \end{macrocode}
% 
% Now the inquisition begins. Note that the default answers produce the
% {\tt plain} (more properly the {\tt is-plain}) bibliographic style.
% This illustrates how the menu defaults may be different from the 
% \dtx{} ones. The |^^J| forces a new line within the output message.
%    \begin{macrocode}
\mes{^^JSelect your options:^^JStyle of label:}
\optdef{*}{}{Numerical}{for plain, unsrt, abbrv}
\optdef{a}{lab-alph}{Alphabetical}{for alpha}
\getans

\mes{^^JOrdering:}
\optdef{*}{sorted}{Sorted}{for plain, abbrv, alpha}
\optdef{u}{}{Unsorted}{for unsrt}
\getans

\mes{^^JAuthor names:}
\optdef{*}{name-full}{Names fully written}{for plain, unsrt, alpha}
\optdef{a}{}{Names abbreviated}{for abbrv}
\getans

\mes{^^JNon-book titles:}
\optdef{*}{atit-lower}{Converted to l.c.}{for plain, unsrt, abbrv, alpha}
\optdef{u}{}{As in entry}{for none}
\getans

\mes{^^JMonth names:}
\optdef{*}{month-full}{Full}{for plain, unsrt, alpha}
\optdef{a}{}{Abbreviated}{for abbrv}
\getans

\mes{^^JJournal names:}
\optdef{*}{jour-full}{Full}{for plain, unsrt, alpha}
\optdef{a}{}{Abbreviated}{for abbrv}
\getans

\mes{^^JNEW FONT SELECTION SCHEME:}
\optdef{*}{}{No NFSS}{use 2.09 font commands}
\optdef{n}{nfss}{NFSS}{use \string\textbf, \string\emph, not \string\bf,
                       \string\em}
\getans
\endoptions
%</options>
%    \end{macrocode}
% \StopEventually{\relax
%    \DeleteShortVerb{\|}
%    \end{document}}
% 
% \newpage
% \part{The Bibliographic Coding}
% \begin{sl}
% The remaining text is that found in {\tt xbtxbst.doc}, which is 
% almost the same as that in {\tt btxbst.doc}. I have only modified
% it to work as \LaTeX{} input, adding |\tt| where necessary, and changing
% |"text"| to |``text''|, adding environments, and sectioning commands, 
% and so on.
%
% The original also contains several ``comment versions'' of the coding.
% These are a simplified copy of the function in question. I have kept
% them, as verbatim text. They are part of the comments themselves, and not
% of the coding.
% 
% For more information about how the \btx{} stack language works, see
% Patashnik's article {\tt btxhak.tex} that should be part of the standard
% \LaTeX{} package.
% 
% The initial copyright and explanatory text has been moved from the
% beginning to here; it is output into every {\tt.bst} file produced.
% \end{sl}
%    \begin{macrocode}
%<*!options>
 %% BibTeX `plain' family
 %%       version 0.99b for BibTeX versions 0.99a or later, LaTeX version 2.09.
 %%       Copyright (C) 1985, all rights reserved.
 %%       Copying of this file is authorized only if either
 %%       (1) you make absolutely no changes to your copy, including name, or
 %%       (2) if you do make changes, you name it something other than
 %%       btxbst.doc, plain.bst, unsrt.bst, alpha.bst, and abbrv.bst.
 %%       This restriction helps ensure that all standard styles are identical.
 %%       The file btxbst.doc has the documentation for this style.
 %%
%    \end{macrocode}
% \begin{sl}
% From here on, it is Oren Patashnik's original text. Any other comments that
% I may have will be entered in slanted typeface as here.
% 
% \hbox to \hsize{\hfill PWD}
% \end{sl}
% 
% \section{Background}
%   Entry formatting: Similar to that recommended by Mary-Claire van Leunen
%       in ``A Handbook for Scholars''.  Book-like titles are italicized
%       (emphasized) and non-book titles are converted to sentence
%       capitalization (and not enclosed in quotes).
%       This file outputs a |\newblock| between major blocks of an entry
%       (the name |\newblock| is analogous to the names |\newline| and
%          |\newpage|)
%       so that the user can obtain an ``open'' format, which has a line break
%       before each block and lines after the first are indented within blocks,
%       by giving the optional |\documentstyle| argument |openbib|;
%       the default is the ``closed'' format---blocks runs together.
%
%   Citation alphabetic label format:
% \begin{quote}
%               |[Knu73]| for single author (or editor or key)\\
%               |[AHU83]| (first letters of last names) for multiple authors
% \end{quote}
%
%   Citation label numberic format:
% \begin{quote}
%               |[number]|
% \end{quote}
%
%   Reference list ordering for sorted, alphabetic lables:
% \begin{quote}
%               alphabetical by citation label, then by author(s) or whatever
%               passes for author in the absence of one, then by year,
%               then title.
% \end{quote}
%
%   Reference list ordering for sorted, numeric lables:
% \begin{quote}
%            alphabetical by author(s) or whatever passes
%            for author in the absence of one, then by year, then title.
% \end{quote}
%
%   Reference list ordering for unsorted:
% \begin{quote}
%               by the order cited in the text.
% \end{quote}
%
%   History:
% \begin{list}{}{\labelwidth3cm \labelsep20pt \leftmargin\labelwidth
%   \addtolength{\leftmargin}{\labelsep} \rightmargin0pt}
% \item[12/16/84 (HWT)] Original {\tt plain} version, by Howard Trickey.
% \item[12/23/84 (LL)] Some comments made by Leslie Lamport.
% \item[2/16/85 (OP)] Changes based on LL's comments, Oren Patashnik.
% \item[2/17/85 (HWT)] Template file and other standard styles made.
% \item[3/28/85 (OP)] First release, version 0.98b for \btx{} 0.98f.
% \item[5/09/85 (OP)] Version 0.98c for \btx{} 0.98i:
%
%                       fixed Theoretical Computer Science macro name;
%
%                       fixed the {\tt format.vol.num.pages} function.
% \item[1/24/88 (OP)] Version 0.99a for \btx{} 0.99a, main changes:
% 
%                       assignment operator (|:=|) arguments reversed;
% 
%                       the |preamble$| function outputs the database 
%                       |PREAMBLE|;
% 
%                       |entry.max$| and |global.max$| (built-in) variables 
%                       replace
%                       |entry.string.max| and |global.string.max|
%                       functions;
% 
%                       alphabetizing by year then title, not just
%                       title;
% 
%                       many unnecessary ties removed;
% 
%                       |\em| $\Rightarrow$ |\em|;
% 
%                       the {\tt alpha} style uses a superscripted `+' 
%                       instead of a
%                       `*' for unnamed names in constructing the
%                       label;
% 
%                       the {\tt abbrv} style now uses ``Mar.''\ and
%                       ``Sept.'';
% 
%                       the functions |calc.label| and |presort| now look 
%                       at just
%                       the fields they're supposed to;
% 
%                       |BOOKLET|, |MASTERSTHESIS|, |TECHREPORT| use nonbook 
%                       titles;
% 
%                       |INBOOK| and |INCOLLECTION| take an optional type
%                       (e.g.\
%                       type = ``Section''), overriding the default
%                       ``chapter'';
% 
%                       |BOOK|, |INBOOK|, |INCOLLECTION|, and
%                       |PROCEEDINGS| now allow
%                       either volume or number, not just volume;
% 
%                       |INCOLLECTION| now allows an edition and series field;
%                        
%                       |PROCEEDINGS| and |INPROCEEDINGS| now use the address 
%                       field
%                       to tell where a conference was held;
% 
%                       |INPROCEEDINGS| and |PROCEEDINGS| now allow either 
%                       volume
%                       or number, and also a series field;
% 
%                       |MASTERSTHESIS| and |PHDTHESIS| accept types other than
%                       ``Master's thesis'' and ``PhD thesis'';
% 
%                       |UNPUBLISHED| now outputs, in one block, note then date;
%                       
%                       |MANUAL| now prints out the organization in
%                       the first block if the author field is empty;
% 
%                       |MISC| can't be empty---it requires some optional field.
%
% \item[3/23/88 (OP)] Version 0.99b for \btx{} 0.99c---changed the three
%                       erroneous occurrences of {\tt cite} to |cite$|; this
%                       change didn't affect the four standard styles, so the
%                       0.99a versions of those styles are still current.
% \end{list}
%
% \section{Preliminaries}
% \subsection{The {\tt ENTRY} declaration}
%   Like Scribe's (according to pages 231-2 of the April '84 edition),
%   but no {\tt fullauthor} or {\tt editors} fields because \btx{} does 
%   name handling.
%   The {\tt annote} field is commented out here because this family doesn't
%   include an annotated bibliography style.  And in addition to the fields
%   listed here, \btx{} has a built-in crossref field, explained later.
%    \begin{macrocode}
ENTRY
%    \end{macrocode}
% Fields:
%    \begin{macrocode}
  { address
%    \end{macrocode}
%           Usually the address of a publisher or other type of organization.
%           Put information in this field only if it helps the reader find the
%           thing---for example you should omit the address of a major
%           publisher entirely.  For a |PROCEEDINGS| or an |INPROCEEDINGS|,
%           however, it's the address of the conference; for those two entry
%           types, include the publisher's or organization's address, if
%           necessary, in the publisher or organization field.
%    \begin{macrocode}
%    annote
%    \end{macrocode}
%           Long annotation---for annotated bibliographies (begins sentence).
%    \begin{macrocode}
    author
%    \end{macrocode}
%           Name(s) of author(s), in \btx{} name format.
%    \begin{macrocode}
    booktitle
%    \end{macrocode}
%           Book title when the thing being referenced isn't the whole book.
%           For book entries, the |title| field should be used instead.
%    \begin{macrocode}
    chapter
%    \end{macrocode}
%           Chapter (or section or whatever) number.
%    \begin{macrocode}
    edition
%    \end{macrocode}
%           Edition of a book---should be an ordinal (e.g., ``Second'').
%    \begin{macrocode}
    editor
%    \end{macrocode}
%           Name(s) of editor(s), in \btx{} name format.
%           If there is also an |author| field, then the |editor| field 
%           should be
%           for the book or collection that the work appears in.
%    \begin{macrocode}
    howpublished
%    \end{macrocode}
%            How something strange has been published (begins sentence).
%    \begin{macrocode}
    institution
%    \end{macrocode}
%           Sponsoring institution of a technical report.
%    \begin{macrocode}
    isbn
%    \end{macrocode}
%           ISBN book number (a 10-digit number with optional
%           embedded spaces or hyphens, where a `digit' is one of
%           0123456789X).
%    \begin{macrocode}
    issn
%    \end{macrocode}
%           ISSN serial publication number (an 8-digit number with optional
%           embedded spaces or hyphens, where a `digit' is one of
%           0123456789X).
%    \begin{macrocode}
    journal
%    \end{macrocode}
%           Journal name (macros are provided for many).
%    \begin{macrocode}
    key
%    \end{macrocode}
%           Alphabetizing, labeling, and cross-referencing key
%           (needed when an entry has no |author| or |editor|).
%    \begin{macrocode}
    month
%    \end{macrocode}
%           Month (macros are provided).
%    \begin{macrocode}
    note
%    \end{macrocode}
%           To help the reader find a reference (begins sentence).
%    \begin{macrocode}
    number
%    \end{macrocode}
%           Number of a journal or technical report, or of a work in a series.
%    \begin{macrocode}
    organization
%    \end{macrocode}
%           Organization sponsoring a conference (or publishing a manual); if
%           the |editor| (or |author|) is empty, and if the organization 
%           produces
%           an awkward label or cross reference, you should put appropriately
%           condensed organization information in the |key| field as well.
%    \begin{macrocode}
    pages
%    \end{macrocode}
%           Page number or numbers (use |--| to separate a range, use |+|
%           to indicate pages following that don't form a simple range).
%    \begin{macrocode}
    publisher
%    \end{macrocode}
%           Publisher name.
%    \begin{macrocode}
    school
%    \end{macrocode}
%           School name (for theses).
%    \begin{macrocode}
    series
%    \end{macrocode}
%           The name of a series or set of books.
%           An individual book will also have it's own title.
%    \begin{macrocode}
    title
%    \end{macrocode}
%           The title of the thing you're referring to.
%    \begin{macrocode}
    type
%    \end{macrocode}
%           Type of a Techreport (e.g., ``Research Note'') to be used instead of
%           the default ``Technical Report''; or, similarly, the type of a
%           thesis; or of a part of a book.
%    \begin{macrocode}
    volume
%    \end{macrocode}
%           The volume number of a journal or multivolume work.
%    \begin{macrocode}
    year
%    \end{macrocode}
%           The year should contain only numerals (technically, it should end
%           with four numerals, after purification; doesn't a begin sentence).
%    \begin{macrocode}
  }
%    \end{macrocode}
% There are no integer entry variables
%    \begin{macrocode}
  {}
%    \end{macrocode}
%
% These string entry variables are used to form the citation label.
% In a storage pinch, |sort.label| can be easily computed on the fly.
%    \begin{macrocode}
%<*lab-alph>
%<sorted>  { label extra.label sort.label }
%    \end{macrocode}
% It doesn't seem like a good idea to use an order-of-citation
% reference list when using alphabetic labels, but when this happens
% we do things a little differently
%    \begin{macrocode}
%<!sorted>  { label }
%</lab-alph>
%<!lab-alph>  { label }

%    \end{macrocode}
%
% \subsection{Description of the Processing}
%
% Each entry function starts by calling |output.bibitem|, to write the
% |\bibitem| and its arguments to the {\tt.bbl} file.  Then the various fields
% are formatted and printed by |output| or |output.check|.  Those functions
% handle the writing of separators (commas, periods, |\newblock|'s),
% taking care not to do so when they are passed a null string.
% Finally, |fin.entry| is called to add the final period and finish the
% entry.
%
% A bibliographic reference is formatted into a number of `blocks':
% in the open format, a block begins on a new line and subsequent
% lines of the block are indented.  A block may contain more than
% one sentence (well, not a grammatical sentence, but something to
% be ended with a sentence ending period).  The entry functions should
% call |new.block| whenever a block other than the first is about to be
% started.  They should call |new.sentence| whenever a new sentence is
% to be started.  The output functions will ensure that if two
% |new.sentence|'s occur without any non-null string being output between
% them then there won't be two periods output.  Similarly for two
% successive |new.block|'s.
%
% The output routines don't write their argument immediately.
% Instead, by convention, that argument is saved on the stack to be
% output next time (when we'll know what separator needs to come
% after it).  Meanwhile, the output routine has to pop the pending
% output off the stack, append any needed separator, and write it.
%
% \subsubsection{The Output States}
% To tell which separator is needed, we maintain an |output.state|.
% It will be one of these values:
% \begin{description}
% \item[before.all]              just after the |\bibitem|
% \item[mid.sentence]            in the middle of a sentence: comma needed
%                                       if more sentence is output
% \item[after.sentence]          just after a sentence: period needed
% \item[after.block]             just after a block (and sentence):
%                                       period and |\newblock| needed.
% \end{description}
% Note: These styles don't use |after.sentence|.
% \begin{quote}
% VAR: |output.state| : INTEGER \qquad -- state variable for output
% \end{quote}
%
% \subsubsection{The Output Functions}
% The |output.nonnull| function saves its argument (assumed to be nonnull)
% on the stack, and writes the old saved value followed by any needed
% separator.  The ordering of the tests is decreasing frequency of
% occurrence.
%
% \begin{verbatim}
% output.nonnull(s) ==
%  BEGIN
%       s := argument on stack
%       if output.state = mid.sentence then
%           write$(pop() * ", ")
%                 -- "pop" isn't a function: just use stack top
%       else
%           if output.state = after.block then
%               write$(add.period$(pop()))
%               newline$
%               write$("\newblock ")
%           else
%               if output.state = before.all then
%                   write$(pop())
%               else        -- output.state should be after.sentence
%                   write$(add.period$(pop()) * " ")
%               fi
%           fi
%           output.state := mid.sentence
%       fi
%       push s on stack
%  END
% \end{verbatim}
%
% The output function calls |output.nonnull| if its argument is non-empty;
% its argument may be a missing field (thus, not necessarily a string)
%
% \begin{verbatim}
% output(s) ==
%  BEGIN
%       if not empty$(s) then output.nonnull(s)
%       fi
%  END
% \end{verbatim}
%
% The |output.check| function is the same as the |output| function except 
% that, if
% necessary, |output.check| warns the user that the |t| field shouldn't be 
% empty
% (this is because it probably won't be a good reference without the field;
% the entry functions try to make the formatting look reasonable even when
% such fields are empty).
%
% \begin{verbatim}
% output.check(s,t) ==
%  BEGIN
%       if empty$(s) then
%           warning$("empty " * t * " in " * cite$)
%       else output.nonnull(s)
%       fi
%  END
% \end{verbatim}
%
% The |output.bibitem| function writes the |\bibitem| for the current entry
% (the label should already have been set up), and sets up the separator
% state for the output functions.  And, it leaves a string on the stack
% as per the output convention.
%
% \begin{verbatim}
% output.bibitem ==
%  BEGIN
%       newline$
%       write$("\bibitem[")     % for alphabetic labels,
%       write$(label)           % these three lines
%       write$("]{")            % are used
%       write$("\bibitem{")             % this line for numeric labels
%       write$(cite$)
%       write$("}")
%       push "" on stack
%       output.state := before.all
%  END
% \end{verbatim}
%
% The |fin.entry| function finishes off an entry by adding a period to the
% string remaining on the stack.  If the state is still |before.all|
% then nothing was produced for this entry, so the result will look bad,
% but the user deserves it. (We don't omit the whole entry because the
% entry was cited, and a |\bibitem| is needed to define the citation label.)
%
% \begin{verbatim}
% fin.entry ==
%  BEGIN
%       write$(add.period$(pop()))
%       newline$
%  END
% \end{verbatim}
%
% The |new.block| function prepares for a new block to be output, and
% |new.sentence| prepares for a new sentence.
%
% \begin{verbatim}
% new.block ==
%  BEGIN
%       if output.state <> before.all then
%           output.state := after.block
%       fi
%  END
%
% new.sentence ==
%  BEGIN
%       if output.state <> after.block then
%           if output.state <> before.all then
%               output.state :=  after.sentence
%           fi
%       fi
%  END
% \end{verbatim}
%
% \subsection{Coding of Output Functions}
%    \begin{macrocode}

INTEGERS { output.state before.all mid.sentence after.sentence after.block }

FUNCTION {init.state.consts}
{ #0 'before.all :=
  #1 'mid.sentence :=
  #2 'after.sentence :=
  #3 'after.block :=
}

%    \end{macrocode}
% The variables |s| and |t| are temporary string holders.
%    \begin{macrocode}

STRINGS { s t }

FUNCTION {output.nonnull}
{ 's :=
  output.state mid.sentence =
    { ", " * write$ }
    { output.state after.block =
        { add.period$ write$
          newline$
          "\newblock " write$
        }
        { output.state before.all =
            'write$
            { add.period$ " " * write$ }
          if$
        }
      if$
      mid.sentence 'output.state :=
    }
  if$
  s
}

FUNCTION {output}
{ duplicate$ empty$
    'pop$
    'output.nonnull
  if$
}

FUNCTION {output.check}
{ 't :=
  duplicate$ empty$
    { pop$ "empty " t * " in " * cite$ * warning$ }
    'output.nonnull
  if$
}

FUNCTION {output.bibitem}
{ newline$
%<*lab-alph>
  "\bibitem[" write$
  label write$
  "]{" write$
%</lab-alph>
%<*!lab-alph>
  "\bibitem{" write$
%</!lab-alph>
  cite$ write$
  "}" write$
  newline$
  ""
  before.all 'output.state :=
}

%    \end{macrocode}
% This function finishes all entries.
%    \begin{macrocode}
FUNCTION {fin.entry}
{ add.period$
  write$
  newline$
}

FUNCTION {new.block}
{ output.state before.all =
    'skip$
    { after.block 'output.state := }
  if$
}

FUNCTION {new.sentence}
{ output.state after.block =
    'skip$
    { output.state before.all =
        'skip$
        { after.sentence 'output.state := }
      if$
    }
  if$
}

%    \end{macrocode}
% \subsection{Some Auxiliary Functions}
% These three functions pop one or two (integer) arguments from the stack
% and push a single one, either |0| or |1|.
% The |skip$| in the |and| and |or| functions are used because
% the corresponding |if$| would be idempotent.
%    \begin{macrocode}
FUNCTION {not}
{   { #0 }
    { #1 }
  if$
}

FUNCTION {and}
{   'skip$
    { pop$ #0 }
  if$
}

FUNCTION {or}
{   { pop$ #1 }
    'skip$
  if$
}

%    \end{macrocode}
%
% Sometimes we begin a new block only if the block will be big enough.  The
% |new.block.checka| function issues a |new.block| if its argument is nonempty;
% |new.block.checkb| does the same if either of its \emph{two} arguments is 
% nonempty.
%    \begin{macrocode}
FUNCTION {new.block.checka}
{ empty$
    'skip$
    'new.block
  if$
}

FUNCTION {new.block.checkb}
{ empty$
  swap$ empty$
  and
    'skip$
    'new.block
  if$
}

%    \end{macrocode}
% The |new.sentence.check| functions are analogous.
%    \begin{macrocode}
FUNCTION {new.sentence.checka}
{ empty$
    'skip$
    'new.sentence
  if$
}

FUNCTION {new.sentence.checkb}
{ empty$
  swap$ empty$
  and
    'skip$
    'new.sentence
  if$
}

%    \end{macrocode}
%
% \section{Formatting Functions}
% \subsection{Formatting Names}
% Here are some functions for formatting chunks of an entry.
% By convention they either produce a string that can be followed by
% a comma or period (using |add.period$|, so it is OK to end in a period),
% or they produce the null string.
%
% A useful utility is the |field.or.null| function, which checks if the
% argument is the result of pushing a `missing' field (one for which no
% assignment was made when the current entry was read in from the database)
% or the result of pushing a string having no non-white-space characters.
% It returns the null string if so, otherwise it returns the field string.
% Its main (but not only) purpose is to guarantee that what's left on the
% stack is a string rather than a missing field.
%
% \begin{verbatim}
% field.or.null(s) ==
%  BEGIN
%       if empty$(s) then return ""
%       else return s
%  END
% \end{verbatim}
%
% Another helper function is |emphasize|, which returns the argument emphasized,
% if that is non-empty, otherwise it returns the null string.  Italic
% corrections aren't used, so this function should be used when punctation
% will follow the result.
%
% \begin{verbatim}
% emphasize(s) ==
%  BEGIN
%       if empty$(s) then return ""
%       else return "{\em " * s * "}"
% \end{verbatim}
%
% The |format.names| function formats the argument (which should be in
% \btx{} name format) into ``First Von Last, Junior'', separated by commas
% and with an ``and'' before the last (but ending with ``et~al.'' if the last
% of multiple authors is ``others'').  This function's argument should always
% contain at least one name.
%
% \begin{quote}
% VAR: |nameptr, namesleft, numnames|: INTEGER\\
% pseudoVAR: |nameresult|: STRING \qquad(it's what's accumulated on the stack)
% \end{quote}
%
% \begin{verbatim}
% format.names(s) ==
%  BEGIN
%       nameptr := 1
%       numnames := num.names$(s)
%       namesleft := numnames
%       while namesleft > 0
%         do
%                               % for full names:
%           t := format.name$(s, nameptr, "{ff~}{vv~}{ll}{, jj}")
%                               % for abbreviated first names:
%           t := format.name$(s, nameptr, "{f.~}{vv~}{ll}{, jj}")
%           if nameptr > 1 then
%               if namesleft > 1 then nameresult := nameresult * ", " * t
%               else if numnames > 2
%                      then nameresult := nameresult * ","
%                    fi
%                    if t = "others"
%                      then nameresult := nameresult * " et~al."
%                      else nameresult := nameresult * " and " * t
%                    fi
%               fi
%           else nameresult := t
%           fi
%           nameptr := nameptr + 1
%           namesleft := namesleft - 1
%         od
%       return nameresult
%  END
% \end{verbatim}
%
% The |format.authors| function returns the result of
%  |format.names(author)|
% if the |author| is present, or else it returns the null string.
%
% \begin{verbatim}
% format.authors ==
%  BEGIN
%       if empty$(author) then return ""
%       else return format.names(author)
%       fi
%  END
% \end{verbatim}
%
% |Format.editors| is like |format.authors|, but it uses the |editor| field,
% and appends ``, editor'' or ``, editors''.
%
% \begin{verbatim}
% format.editors ==
%  BEGIN
%       if empty$(editor) then return ""
%       else
%           if num.names$(editor) > 1 then
%               return format.names(editor) * ", editors"
%           else
%               return format.names(editor) * ", editor"
%           fi
%       fi
%  END
% \end{verbatim}
%
% Other formatting functions are similar, so no ``comment version'' will be
% given for them.
%
% \subsection{Coding the Names Format Functions}
% The |pop$| in this function gets rid of the duplicate `empty' value and
% the |skip$| returns the duplicate field value.
%    \begin{macrocode}
FUNCTION {field.or.null}
{ duplicate$ empty$
    { pop$ "" }
    'skip$
  if$
}

FUNCTION {emphasize}
{ duplicate$ empty$
    { pop$ "" }
%<!nfss>    { "{\em " swap$ * "}" * }
%<nfss>    { "\emph{" swap$ * "}" * }
  if$
}

INTEGERS { nameptr namesleft numnames }

FUNCTION {format.names}
{ 's :=
  #1 'nameptr :=
  s num.names$ 'numnames :=
  numnames 'namesleft :=
    { namesleft #0 > }
%<name-full>    { s nameptr "{ff~}{vv~}{ll}{, jj}" format.name$ 't :=
%<!name-full>    { s nameptr "{f.~}{vv~}{ll}{, jj}" format.name$ 't :=
      nameptr #1 >
        { namesleft #1 >
            { ", " * t * }
            { numnames #2 >
                { "," * }
                'skip$
              if$
              t "others" =
                { " et~al." * }
                { " and " * t * }
              if$
            }
          if$
        }
        't
      if$
      nameptr #1 + 'nameptr :=
      namesleft #1 - 'namesleft :=
    }
  while$
}

FUNCTION {format.authors}
{ author empty$
    { "" }
    { author format.names }
  if$
}

FUNCTION {format.editors}
{ editor empty$
    { "" }
    { editor format.names
      editor num.names$ #1 >
        { ", editors" * }
        { ", editor" * }
      if$
    }
  if$
}

FUNCTION {format.isbn}
{ isbn empty$
    { "" }
    { new.block "ISBN " isbn * }
  if$
}

FUNCTION {format.issn}
{ issn empty$
    { "" }
    { new.block "ISSN " issn * }
  if$
}

%    \end{macrocode}
%
% \subsection{Title and Date Format Functions}
% The |format.title| function is used for non-book-like titles.
% For most styles we convert to lowercase (except for the very first letter,
% and except for the first one after a colon (followed by whitespace)),
% and hope the user has brace-surrounded words that need to stay capitalized;
% for some styles, however, we leave it as it is in the database.
%    \begin{macrocode}
FUNCTION {format.title}
{ title empty$
    { "" }
%<atit-lower>    { title "t" change.case$ }
%<!atit-lower>    'title
  if$
}

%    \end{macrocode}
% By default, \btx{} sets the global integer variable |global.max$| 
% to the \btx{}
% constant |glob_str_size|, the maximum length of a global string variable.
% Analogously, \btx{} sets the global integer variable |entry.max$| to
% |ent_str_size|, the maximum length of an entry string variable.
% The style designer may change these if necessary (but this is
% unlikely).
%
% The |n.dashify| function makes each single {\tt-} in a string a double
% {\tt--} if it's not already.
%
% \begin{quote}
% pseudoVAR: |pageresult|: STRING \qquad (it's what's accumulated on the stack)
% \end{quote}
%
% \begin{verbatim}
% n.dashify(s) ==
%  BEGIN
%       t := s
%       pageresult := ""
%       while (not empty$(t))
%         do
%           if (first character of t = "-")
%             then
%               if (next character isn't)
%                 then
%                   pageresult := pageresult * "--"
%                   t := t with the "-" removed
%                 else
%                   while (first character of t = "-")
%                     do
%                       pageresult := pageresult * "-"
%                       t := t with the "-" removed
%                     od
%               fi
%             else
%               pageresult := pageresult * the first character
%               t := t with the first character removed
%           fi
%         od
%       return pageresult
%  END
% \end{verbatim}
%    \begin{macrocode}
FUNCTION {n.dashify}
{ 't :=
  ""
    { t empty$ not }
    { t #1 #1 substring$ "-" =
        { t #1 #2 substring$ "--" = not
            { "--" *
              t #2 global.max$ substring$ 't :=
            }
            {   { t #1 #1 substring$ "-" = }
                { "-" *
                  t #2 global.max$ substring$ 't :=
                }
              while$
            }
          if$
        }
        { t #1 #1 substring$ *
          t #2 global.max$ substring$ 't :=
        }
      if$
    }
  while$
}

%    \end{macrocode}
%
% The |format.date| function is for the month and year, but we give a warning if
% there's an empty year but the month is there, and we return the empty string
% if they're both empty.
%    \begin{macrocode}
FUNCTION {format.date}
{ year empty$
    { month empty$
        { "" }
        { "there's a month but no year in " cite$ * warning$
          month
        }
      if$
    }
    { month empty$
        'year
        { month " " * year * }
      if$
    }
  if$
}

%    \end{macrocode}
% The |format.btitle| is for formatting the |title| field when it is a book-like
% entry---the style used here keeps it in uppers-and-lowers and emphasizes it.
%    \begin{macrocode}
FUNCTION {format.btitle}
{ title emphasize
}

%    \end{macrocode}
%
% For several functions we'll need to connect two strings with a
% tie (|~|) if the second one isn't very long (fewer than 3 characters).
% The |tie.or.space.connect| function does that.  It concatenates the two
% strings on top of the stack, along with either a tie or space between
% them, and puts this concatenation back onto the stack:
%
% \begin{verbatim}
% tie.or.space.connect(str1,str2) ==
%    BEGIN
%       if text.length$(str2) < 3
%         then return the concatenation of str1, "~", and str2
%         else return the concatenation of str1, " ", and str2
%    END
% \end{verbatim}
%    \begin{macrocode}
FUNCTION {tie.or.space.connect}
{ duplicate$ text.length$ #3 <
    { "~" }
    { " " }
  if$
  swap$ * *
}

%    \end{macrocode}
%
% The |either.or.check| function complains if both fields or an either-or pair
% are nonempty.
%
% \begin{verbatim}
% either.or.check(t,s) ==
%  BEGIN
%       if empty$(s) then
%           warning$(can't use both " * t * " fields in " * cite$)
%       fi
%  END
% \end{verbatim}
%    \begin{macrocode}
FUNCTION {either.or.check}
{ empty$
    'pop$
    { "can't use both " swap$ * " fields in " * cite$ * warning$ }
  if$
}

%    \end{macrocode}
%
% The |format.bvolume| function is for formatting the volume and perhaps
% series name of a multivolume work.  If both a |volume| and a |series| field
% are there, we assume the |series| field is the title of the whole multivolume
% work (the |title| field should be the title of the thing being referred to),
% and we add an ``of \emph{series}''.  This function is called in mid-sentence.
%    \begin{macrocode}
FUNCTION {format.bvolume}
{ volume empty$
    { "" }
    { "volume" volume tie.or.space.connect
      series empty$
        'skip$
        { " of " * series emphasize * }
      if$
      "volume and number" number either.or.check
    }
  if$
}

%    \end{macrocode}
%
% \subsection{Formats for Special Fields}
% The |format.number.series| function is for formatting the series name
% and perhaps number of a work in a series.  This function is similar to
% |format.bvolume|, although for this one the |series| must exist (and the
% |volume| must not exist).  If the |number| field is empty we output either
% the |series| field unchanged if it exists or else the null string.
% If both the |number| and |series| fields are there we assume the
% |series| field
% gives the name of the whole series (the |title| field should be the title
% of the work being one referred to), and we add an ``in \emph{series}''.
% We capitalize ``Number'' when this function is used at the beginning of 
% a block.
%    \begin{macrocode}
FUNCTION {format.number.series}
{ volume empty$
    { number empty$
        { series field.or.null }
        { output.state mid.sentence =
            { "number" }
            { "Number" }
          if$
          number tie.or.space.connect
          series empty$
            { "there's a number but no series in " cite$ * warning$ }
            { " in " * series * }
          if$
        }
      if$
    }
    { "" }
  if$
}

%    \end{macrocode}
%
% The |format.edition| function appends ``edition'' to the edition, if present.
% We lowercase the edition (it should be something like ``Third''), because
% this doesn't start a sentence.
%    \begin{macrocode}
FUNCTION {format.edition}
{ edition empty$
    { "" }
    { output.state mid.sentence =
        { edition "l" change.case$ " edition" * }
        { edition "t" change.case$ " edition" * }
      if$
    }
  if$
}

%    \end{macrocode}
%
% The |format.pages| function is used for formatting a page range in a book
% (and in rare circumstances, an article).
%
% The |multi.page.check| function examines the |pages| field for a 
% |-| or |,| or |+|
% so that |format.pages| can use ``page'' instead of ``pages'' if none exists.
% Note: |global.max$| here means ``take the rest of the string''.
%
% \begin{quote}
% VAR: |multiresult|: INTEGER \qquad (actually, a boolean)
% \end{quote}
%
% \begin{verbatim}
% multi.page.check(s) ==
%  BEGIN
%       t := s
%       multiresult := false
%       while ((not multiresult) and (not empty$(t)))
%         do
%           if (first character of t = "-" or "," or "+")
%             then multiresult := true
%             else t := t with the first character removed
%           fi
%         od
%       return multiresult
%  END
% \end{verbatim}
%    \begin{macrocode}

INTEGERS { multiresult }

FUNCTION {multi.page.check}
{ 't :=
  #0 'multiresult :=
    { multiresult not
      t empty$ not
      and
    }
    { t #1 #1 substring$
      duplicate$ "-" =
      swap$ duplicate$ "," =
      swap$ "+" =
      or or
        { #1 'multiresult := }
        { t #2 global.max$ substring$ 't := }
      if$
    }
  while$
  multiresult
}

%    \end{macrocode}
%
% This function doesn't begin a sentence so ``pages'' isn't capitalized.
% Other functions that use this should keep that in mind.
%    \begin{macrocode}
FUNCTION {format.pages}
{ pages empty$
    { "" }
    { pages multi.page.check
        { "pages" pages n.dashify tie.or.space.connect }
        { "page" pages tie.or.space.connect }
      if$
    }
  if$
}

%    \end{macrocode}
%
% The |format.vol.num.pages| function is for the volume, number, and page range
% of a journal article.  We use the format:  vol(number):pages, with some
% variations for empty fields.  This doesn't begin a sentence.
%    \begin{macrocode}
FUNCTION {format.vol.num.pages}
{ volume field.or.null
  number empty$
    'skip$
    { "\penalty0 (" number * ")" * *
      volume empty$
        { "there's a number but no volume in " cite$ * warning$ }
        'skip$
      if$
    }
  if$
  pages empty$
    'skip$
    { duplicate$ empty$
        { pop$ format.pages }
        { ":\penalty0 " * pages n.dashify * }
      if$
    }
  if$
}

%    \end{macrocode}
%
% The |format.chapter.pages|, if the |chapter| is present, puts whatever 
% is in the
% |type| field (or else ``chapter'' if |type| is empty) in front of a 
% chapter number.
% It then appends the pages, if present.  This doesn't begin a sentence.
%    \begin{macrocode}
FUNCTION {format.chapter.pages}
{ chapter empty$
    'format.pages
    { type empty$
        { "chapter" }
        { type "l" change.case$ }
      if$
      chapter tie.or.space.connect
      pages empty$
        'skip$
        { ", " * format.pages * }
      if$
    }
  if$
}

%    \end{macrocode}
%
% The |format.in.ed.booktitle| function is used for starting out a sentence
% that begins ``In \emph{booktitle}'', putting an editor before the 
% title if one exists.
%    \begin{macrocode}
FUNCTION {format.in.ed.booktitle}
{ booktitle empty$
    { "" }
    { editor empty$
        { "In " booktitle emphasize * }
        { "In " format.editors * ", " * booktitle emphasize * }
      if$
    }
  if$
}

%    \end{macrocode}
%
% The function |empty.misc.check| complains if all six fields are empty, and
% if there's been no sorting or alphabetic-label complaint.
%    \begin{macrocode}
FUNCTION {empty.misc.check}
{ author empty$ title empty$ howpublished empty$
  month empty$ year empty$ note empty$
  and and and and and
%<sorted>  key empty$ not and
%<!sorted&lab-alph>  key empty$ not and
    { "all relevant fields are empty in " cite$ * warning$ }
    'skip$
  if$
}

%    \end{macrocode}
%
% The function |format.thesis.type| returns either the (case-changed) 
% |type| field,
% if it is defined, or else the default string already on the stack
% (like ``Master's thesis'' or ``PhD thesis'').
%    \begin{macrocode}
FUNCTION {format.thesis.type}
{ type empty$
    'skip$
    { pop$
      type "t" change.case$
    }
  if$
}

%    \end{macrocode}
%
% The function |format.tr.number| makes a string starting with
% ``Technical Report''
% (or |type|, if that field is defined), followed by the number if there is one;
% it returns the starting part (with a case change) even if there is no number.
% This is used at the beginning of a sentence.
%    \begin{macrocode}
FUNCTION {format.tr.number}
{ type empty$
    { "Technical Report" }
    'type
  if$
  number empty$
    { "t" change.case$ }
    { number tie.or.space.connect }
  if$
}

%    \end{macrocode}
%
% \subsection{Cross-Reference Format Functions}
% Now come the cross-referencing functions (these are invoked because
% one entry in the database file(s) cross-references another, by giving
% the other entry's database key in a |crossref| field).  This feature
% allows one or more titled things that are part of a larger titled
% thing to cross-reference the larger thing.  These styles allow for
% five posibilities: 
% \begin{enumerate}
% \item an |ARTICLE| may cross-reference an |ARTICLE|;
% \item a |BOOK|, 
% \item |INBOOK|, or 
% \item |INCOLLECTION| may cross-reference a |BOOK|; or
% \item an |INPROCEEDINGS| may cross-reference a |PROCEEDINGS|.
% \end{enumerate}
% Each of these is explained in more detail later.
%
% An |ARTICLE| entry type may cross reference another |ARTICLE| (this is
% intended for when an entire journal is devoted to a single topic---but
% since there is no |JOURNAL| entry type, the journal, too, should be
% classified as an |ARTICLE| but without the |author| and |title| fields).
% This will result in two warning messages for the journal's entry
% if it's included in the reference list, but such is life.
%
% \begin{verbatim}
% format.article.crossref ==
%  BEGIN
%       if empty$(key) then
%           if empty$(journal) then
%               warning$("need key or journal for " * cite$ *
%                                               " to crossref " * crossref)
%               return(" \cite{" * crossref * "}")
%           else
%               return("In " * emphasize.correct (journal) *
%                                               " \cite{" * crossref * "}")
%               fi
%       else
%           return("In " * key * " \cite{" * crossref * "}")
%       fi
%  END
% \end{verbatim}
%
% The other cross-referencing functions are similar, so no ``comment
% version'' will be given for them.
%    \begin{macrocode}
FUNCTION {format.article.crossref}
{ key empty$
    { journal empty$
        { "need key or journal for " cite$ * " to crossref " * crossref *
          warning$
          ""
        }
%<!nfss>        { "In {\em " journal * "\/}" * }
%<nfss>        { "In \emph{" journal * "}" * }
      if$
    }
    { "In " key * }
  if$
  " \cite{" * crossref * "}" *
}

%    \end{macrocode}
%
% We use just the last names of editors for a cross reference: either
% ``editor'', or ``editor1 and editor2'', or ``editor1 et~al.'' depending on
% whether there are one, or two, or more than two editors.
%    \begin{macrocode}
FUNCTION {format.crossref.editor}
{ editor #1 "{vv~}{ll}" format.name$
  editor num.names$ duplicate$
  #2 >
    { pop$ " et~al." * }
    { #2 <
        'skip$
        { editor #2 "{ff }{vv }{ll}{ jj}" format.name$ "others" =
            { " et~al." * }
            { " and " * editor #2 "{vv~}{ll}" format.name$ * }
          if$
        }
      if$
    }
  if$
}

%    \end{macrocode}
%
% A |BOOK| (or |INBOOK|) entry type (assumed to be for a single volume in a
% multivolume work) may cross reference another |BOOK| (the entire multivolume).
% Usually there will be an editor, in which case we use that to construct the
% cross reference; otherwise we use a nonempty |key| field or else the
% |series|
% field (since the series gives the title of the multivolume work).
%    \begin{macrocode}
FUNCTION {format.book.crossref}
{ volume empty$
    { "empty volume in " cite$ * "'s crossref of " * crossref * warning$
      "In "
    }
    { "Volume" volume tie.or.space.connect
      " of " *
    }
  if$
  editor empty$
  editor field.or.null author field.or.null =
  or
    { key empty$
        { series empty$
            { "need editor, key, or series for " cite$ * " to crossref " *
              crossref * warning$
              "" *
            }
%<!nfss>            { "{\em " * series * "\/}" * }
%<nfss>            { "\emph{" * series * "}" * }
          if$
        }
        { key * }
      if$
    }
    { format.crossref.editor * }
  if$
  " \cite{" * crossref * "}" *
}

%    \end{macrocode}
%
% An |INCOLLECTION| entry type may cross reference a |BOOK| (assumed to be the
% collection), or an |INPROCEEDINGS| may cross reference a |PROCEEDINGS|.
% Often there will be an editor, in which case we use that to construct
% the cross reference; otherwise we use a nonempty |key| field or else
% the |booktitle| field (which gives the cross-referenced work's title).
%    \begin{macrocode}
FUNCTION {format.incoll.inproc.crossref}
{ editor empty$
  editor field.or.null author field.or.null =
  or
    { key empty$
        { booktitle empty$
            { "need editor, key, or booktitle for " cite$ * " to crossref " *
              crossref * warning$
              ""
            }
%<!nfss>            { "In {\em " booktitle * "\/}" * }
%<nfss>            { "In \emph{" booktitle * "}" * }
          if$
        }
        { "In " key * }
      if$
    }
    { "In " format.crossref.editor * }
  if$
  " \cite{" * crossref * "}" *
}

%    \end{macrocode}
%
% \section{The Entry Type Functions}
% Now we define the type functions for all entry types that may appear
% in the {\tt.bib} file---e.g., functions like |article| and |book|.  These
% are the routines that actually generate the {\tt.bbl}-file output for
% the entry.  These must all precede the |READ| command.  In addition, the
% style designer should have a function |default.type| for unknown types.
% Note: The fields (within each list) are listed in order of appearance,
% except as described for an |inbook| or a |proceedings|.
%
% \subsection{The {\tt article} Function}
% The |article| function is for an article in a journal.  An article may
% |CROSSREF| another article.
% \begin{description}
% \item[] Required fields: |author|, |title|, |journal|, |year|
% \item[] Optional fields: |volume|, |number|, |pages|, |month|, |note|
% \end{description}
%
% \begin{verbatim}
% article ==
%  BEGIN
%       output.bibitem
%       output.check(format.authors,"author")
%       new.block
%       output.check(format.title,"title")
%       new.block
%       if missing$(crossref) then
%           output.check(emphasize(journal),"journal")
%           output(format.vol.num.pages)
%           output.check(format.date,"year")
%       else
%           output.nonnull(format.article.crossref)
%           output(format.pages)
%       fi
%       new.block
%       output(note)
%       fin.entry
%  END
% \end{verbatim}
%
% \subsection{The {\tt book} Function}
% The |book| function is for a whole book.  A book may |CROSSREF| another book.
% \begin{description}
% \item[] Required fields: |author| or |editor|, |title|, |publisher|, |year|
% \item[] Optional fields: |volume| or |number|, |series|, |address|, 
%          |edition|, |month|, |note|
% \end{description}
%
% \begin{verbatim}
% book ==
%  BEGIN
%       if empty$(author) then output.check(format.editors,"author and editor")
%       else    output.check(format.authors,"author")
%               if missing$(crossref) then
%                   either.or.check("author and editor",editor)
%               fi
%       fi
%       new.block
%       output.check(format.btitle,"title")
%       if missing$(crossref) then
%           output(format.bvolume)
%           new.block
%           output(format.number.series)
%           new.sentence
%           output.check(publisher,"publisher")
%           output(address)
%       else
%           new.block
%           output.nonnull(format.book.crossref)
%       fi
%       output(format.edition)
%       output.check(format.date,"year")
%       new.block
%       output(note)
%       fin.entry
%  END
% \end{verbatim}
%
% The other entry functions are all quite similar, so no ``comment
%  version'' will be given for them.
%
%    \begin{macrocode}
FUNCTION {article}
{ output.bibitem
  format.authors "author" output.check
  new.block
  format.title "title" output.check
  new.block
  crossref missing$
    { journal emphasize "journal" output.check
      format.vol.num.pages output
      format.date "year" output.check
    }
    { format.article.crossref output.nonnull
      format.pages output
    }
  if$
  new.block
  note output
  fin.entry
}

FUNCTION {book}
{ output.bibitem
  author empty$
    { format.editors "author and editor" output.check }
    { format.authors output.nonnull
      crossref missing$
        { "author and editor" editor either.or.check }
        'skip$
      if$
    }
  if$
  new.block
  format.btitle "title" output.check
  crossref missing$
    { format.bvolume output
      new.block
      format.number.series output
      new.sentence
      publisher "publisher" output.check
      address output
    }
    { new.block
      format.book.crossref output.nonnull
    }
  if$
  format.edition output
  format.date "year" output.check
  format.isbn output
  new.block
  note output
  fin.entry
}

%    \end{macrocode}
%
% \subsection{The {\tt booklet} Function}
% A booklet is a bound thing without a publisher or sponsoring institution.
% \begin{description}
% \item[] Required: |title|
% \item[] Optional: |author|, |howpublished|, |address|, |month|, |year|,
%         |note|
% \end{description}
%    \begin{macrocode}
FUNCTION {booklet}
{ output.bibitem
  format.authors output
  new.block
  format.title "title" output.check
  howpublished address new.block.checkb
  howpublished output
  address output
  format.date output
  format.isbn output
  new.block
  note output
  fin.entry
}

%    \end{macrocode}
%
% \subsection{The {\tt inbook} Function}
% For the conference entry type, see inproceedings.
%
% An |inbook| is a piece of a book: either a chapter and/or a page range.
% It may |CROSSREF| a book.  If there's no |volume| field, the |type| field
% will come before number and series.
% \begin{description}
% \item[] Required: |author| or |editor|, |title|, |chapter| and/or
%         |pages|, |publisher|, |year|
% \item[] Optional: |volume| or |number|, |series|, |type|, |address|, 
% |edition|, |month|, |note|
% \end{description}
% 

%    \begin{macrocode}
FUNCTION {inbook}
{ output.bibitem
  author empty$
    { format.editors "author and editor" output.check }
    { format.authors output.nonnull
      crossref missing$
        { "author and editor" editor either.or.check }
        'skip$
      if$
    }
  if$
  new.block
  format.btitle "title" output.check
  crossref missing$
    { format.bvolume output
      format.chapter.pages "chapter and pages" output.check
      new.block
      format.number.series output
      new.sentence
      publisher "publisher" output.check
      address output
    }
    { format.chapter.pages "chapter and pages" output.check
      new.block
      format.book.crossref output.nonnull
    }
  if$
  format.edition output
  format.date "year" output.check
  format.isbn output
  new.block
  note output
  fin.entry
}

%    \end{macrocode}
% 
% \subsection{The {\tt incollection} Function}
% An |incollection| is like |inbook|, but where there is a separate |title|
% for the referenced thing (and perhaps an |editor| for the whole).
% An |incollection| may |CROSSREF| a book.
% \begin{description}
% \item[] Required: |author|, |title|, |booktitle|, |publisher|, |year|
% \item[] Optional: |editor|, |volume| or |number|, |series|, |type|, 
%                   |chapter|, |pages|,
%                   |address|, |edition|, |month|, |note|
% \end{description}
%    \begin{macrocode}
FUNCTION {incollection}
{ output.bibitem
  format.authors "author" output.check
  new.block
  format.title "title" output.check
  new.block
  crossref missing$
    { format.in.ed.booktitle "booktitle" output.check
      format.bvolume output
      format.number.series output
      format.chapter.pages output
      new.sentence
      publisher "publisher" output.check
      address output
      format.edition output
      format.date "year" output.check
    }
    { format.incoll.inproc.crossref output.nonnull
      format.chapter.pages output
    }
  if$
  format.isbn output
  new.block
  note output
  fin.entry
}

%    \end{macrocode}
% 
% \subsection{The {\tt inproceedings} Function}
% An |inproceedings| is an article in a conference proceedings, and it may
% |CROSSREF| a proceedings.  If there's no |address| field, the month
% (and year) will appear just before note.
% \begin{description}
% \item[] Required: |author|, |title|, |booktitle|, |year|
% \item[] Optional: |editor|, |volume| or |number|, |series|, |pages|, 
%                   |address|, |month|,
%                   |organization|, |publisher|, |note|
% \end{description}
%    \begin{macrocode}
FUNCTION {inproceedings}
{ output.bibitem
  format.authors "author" output.check
  new.block
  format.title "title" output.check
  new.block
  crossref missing$
    { format.in.ed.booktitle "booktitle" output.check
      format.bvolume output
      format.number.series output
      format.pages output
      address empty$
        { organization publisher new.sentence.checkb
          organization output
          publisher output
          format.date "year" output.check
        }
        { address output.nonnull
          format.date "year" output.check
          new.sentence
          organization output
          publisher output
        }
      if$
    }
    { format.incoll.inproc.crossref output.nonnull
      format.pages output
    }
  if$
  format.isbn output
  new.block
  note output
  fin.entry
}

%    \end{macrocode}
% The conference function is included for Scribe compatibility.
%    \begin{macrocode}
FUNCTION {conference} { inproceedings }

%    \end{macrocode}
% 
% \subsection{The {\tt manual} Function}
% A manual is technical documentation.
% \begin{description}
% \item[] Required: |title|
% \item[] Optional: |author|, |organization|, |address|, |edition|,
%                   |month|, |year|, |note|
% \end{description}
%    \begin{macrocode}
FUNCTION {manual}
{ output.bibitem
  author empty$
    { organization empty$
        'skip$
        { organization output.nonnull
          address output
        }
      if$
    }
    { format.authors output.nonnull }
  if$
  new.block
  format.btitle "title" output.check
  author empty$
    { organization empty$
        { address new.block.checka
          address output
        }
        'skip$
      if$
    }
    { organization address new.block.checkb
      organization output
      address output
    }
  if$
  format.edition output
  format.date output
  new.block
  note output
  fin.entry
}
% 
%    \end{macrocode}
% 
% \subsection{The {\tt mastersthesis} Function}
% A |mastersthesis| is a Master's thesis.
% \begin{description}
% \item[] Required: |author|, |title|, |school|, |year|
% \item[] Optional: |type|, |address|, |month|, |note|
% \end{description}
%    \begin{macrocode}
FUNCTION {mastersthesis}
{ output.bibitem
  format.authors "author" output.check
  new.block
  format.title "title" output.check
  new.block
  "Master's thesis" format.thesis.type output.nonnull
  school "school" output.check
  address output
  format.date "year" output.check
  new.block
  note output
  fin.entry
}

%    \end{macrocode}
% 
% \subsection{The {\tt misc} Function}
% A |misc| is something that doesn't fit elsewhere.
% \begin{description}
% \item[] Required: at least one of the `optional' fields
% \item[] Optional: |author|, |title|, |howpublished|, |month|, |year|,
%                   |note|
% \end{description}
%    \begin{macrocode}
FUNCTION {misc}
{ output.bibitem
  format.authors output
  title howpublished new.block.checkb
  format.title output
  howpublished new.block.checka
  howpublished output
  format.date output
  format.issn output
  new.block
  note output
  fin.entry
  empty.misc.check
}

%    \end{macrocode}
% 
% \subsection{The {\tt phdthesis} Function}
% A phdthesis is like a mastersthesis.
% \begin{description}
% \item[] Required: |author|, |title|, |school|, |year|
% \item[] Optional: |type|, |address|, |month|, |note|
% \end{description}
%    \begin{macrocode}
FUNCTION {phdthesis}
{ output.bibitem
  format.authors "author" output.check
  new.block
  format.btitle "title" output.check
  new.block
  "PhD thesis" format.thesis.type output.nonnull
  school "school" output.check
  address output
  format.date "year" output.check
  new.block
  note output
  fin.entry
}

%    \end{macrocode}
% 
% \subsection{The {\tt periodical} Function}
% {\sl (This is not part of the standard styles, but is an addition in
%   {\tt xbtxbst.doc}. ---PWD)}
%   
% A periodical is a publication that appears at regular
% intervals.  This includes journals, magazines, and newspapers.
% If there is an |organization| but no |editor| field, the
% organization will appear as the first optional field (we try to
% make the first block nonempty); if there's no |address| field,
% the month (and year) will appear just before note.
% \begin{description}
% \item[] Required: |title|, |key|
% \item[] Optional: |editor|, |volume|, |number|, |series|, |address|,
%                   |month|, |year|,
%                   |organization|, |publisher|, |note|, |issn|,
%                   |howpublished|
% \end{description}
%    \begin{macrocode}
FUNCTION {periodical}
{ output.bibitem
  editor empty$
    { organization output }
    { format.editors output.nonnull }
  if$
  new.block
  title emphasize "title" output.check
%  format.bvolume output
%  format.number.series output
  format.vol.num.pages output
  format.date output
  format.issn output
  new.sentence
  publisher output
  address output
  howpublished new.block.checka
  howpublished output
  new.block
  note output
  fin.entry
}

%    \end{macrocode}
% 
% \subsection{The {\tt proceedings} Function}
% A proceedings is a conference proceedings.
% If there is an |organization| but no |editor| field, the organization will
% appear as the first optional field (we try to make the first block nonempty);
% if there's no |address| field, the month (and year) will appear just 
% before note.
% \begin{description}
% \item[] Required: |title|, |year|
% \item[] Optional: |editor|, |volume| or |number|, |series|, |address|,
%                   |month|,
%                   |organization|, |publisher|, |note|
% \end{description}
%    \begin{macrocode}
FUNCTION {proceedings}
{ output.bibitem
  editor empty$
    { organization output }
    { format.editors output.nonnull }
  if$
  new.block
  format.btitle "title" output.check
  format.bvolume output
  format.number.series output
  address empty$
    { editor empty$
        { publisher new.sentence.checka }
        { organization publisher new.sentence.checkb
          organization output
        }
      if$
      publisher output
      format.date "year" output.check
    }
    { address output.nonnull
      format.date "year" output.check
      new.sentence
      editor empty$
        'skip$
        { organization output }
      if$
      publisher output
    }
  if$
  format.isbn output
  new.block
  note output
  fin.entry
}

%    \end{macrocode}
% 
% \subsection{The {\tt techreport} Function}
% A |techreport| is a technical report.
% \begin{description}
% \item[] Required: |author|, |title|, |institution|, |year|
% \item[] Optional: |type|, |number|, |address|, |month|, |note|
% \end{description}
%    \begin{macrocode}
FUNCTION {techreport}
{ output.bibitem
  format.authors "author" output.check
  new.block
  format.title "title" output.check
  new.block
  format.tr.number output.nonnull
  institution "institution" output.check
  address output
  format.date "year" output.check
  new.block
  note output
  fin.entry
}

%    \end{macrocode}
%
% \subsection{The {\tt unpublished} Function}
% An |unpublished| is something that hasn't been published.
% \begin{description}
% \item[] Required: |author|, |title|, |note|
% \item{} Optional: |month|, |year|
% \end{description}
%    \begin{macrocode}
FUNCTION {unpublished}
{ output.bibitem
  format.authors "author" output.check
  new.block
  format.title "title" output.check
  new.block
  note "note" output.check
  format.date output
  fin.entry
}

%    \end{macrocode}
%
% \subsection{The {\tt default.type} Function}
% We use entry type |misc| for an unknown type; \btx{} gives a warning.
%    \begin{macrocode}
FUNCTION {default.type} { misc }

%    \end{macrocode}
% \section{Common Features}
% Here are macros for common things that may vary from style to style.
% Users are encouraged to use these macros.
%
% \subsection{The Months}
% Months are either written out in full or abbreviated
%    \begin{macrocode}
%<*month-full>

MACRO {jan} {"January"}

MACRO {feb} {"February"}

MACRO {mar} {"March"}

MACRO {apr} {"April"}

MACRO {may} {"May"}

MACRO {jun} {"June"}

MACRO {jul} {"July"}

MACRO {aug} {"August"}

MACRO {sep} {"September"}

MACRO {oct} {"October"}

MACRO {nov} {"November"}

MACRO {dec} {"December"}

%</month-full>
%<*!month-full>

MACRO {jan} {"Jan."}

MACRO {feb} {"Feb."}

MACRO {mar} {"Mar."}

MACRO {apr} {"Apr."}

MACRO {may} {"May"}

MACRO {jun} {"June"}

MACRO {jul} {"July"}

MACRO {aug} {"Aug."}

MACRO {sep} {"Sept."}

MACRO {oct} {"Oct."}

MACRO {nov} {"Nov."}

MACRO {dec} {"Dec."}

%</!month-full>

%    \end{macrocode}
%
% \subsection{Journal Names}
% Journals are either written out in full or abbreviated;
% the abbreviations are like those found in ACM publications.
%
% To get a completely different set of abbreviations, it may be best to make
% a separate {\tt.bib} file with nothing but those abbreviations; users 
% could then
% include that file name as the first argument to the |\bibliography|
% command.
%    \begin{macrocode}
%<*jour-full>

MACRO {acmcs} {"ACM Computing Surveys"}

MACRO {acta} {"Acta Informatica"}

MACRO {cacm} {"Communications of the ACM"}

MACRO {ibmjrd} {"IBM Journal of Research and Development"}

MACRO {ibmsj} {"IBM Systems Journal"}

MACRO {ieeese} {"IEEE Transactions on Software Engineering"}

MACRO {ieeetc} {"IEEE Transactions on Computers"}

MACRO {ieeetcad}
 {"IEEE Transactions on Computer-Aided Design of Integrated Circuits"}

MACRO {ipl} {"Information Processing Letters"}

MACRO {jacm} {"Journal of the ACM"}

MACRO {jcss} {"Journal of Computer and System Sciences"}

MACRO {scp} {"Science of Computer Programming"}

MACRO {sicomp} {"SIAM Journal on Computing"}

MACRO {tocs} {"ACM Transactions on Computer Systems"}

MACRO {tods} {"ACM Transactions on Database Systems"}

MACRO {tog} {"ACM Transactions on Graphics"}

MACRO {toms} {"ACM Transactions on Mathematical Software"}

MACRO {toois} {"ACM Transactions on Office Information Systems"}

MACRO {toplas} {"ACM Transactions on Programming Languages and Systems"}

MACRO {tcs} {"Theoretical Computer Science"}

%</jour-full>
%<*!jour-full>

MACRO {acmcs} {"ACM Comput. Surv."}

MACRO {acta} {"Acta Inf."}

MACRO {cacm} {"Commun. ACM"}

MACRO {ibmjrd} {"IBM J. Res. Dev."}

MACRO {ibmsj} {"IBM Syst.~J."}

MACRO {ieeese} {"IEEE Trans. Softw. Eng."}

MACRO {ieeetc} {"IEEE Trans. Comput."}

MACRO {ieeetcad}
 {"IEEE Trans. Comput.-Aided Design Integrated Circuits"}

MACRO {ipl} {"Inf. Process. Lett."}

MACRO {jacm} {"J.~ACM"}

MACRO {jcss} {"J.~Comput. Syst. Sci."}

MACRO {scp} {"Sci. Comput. Programming"}

MACRO {sicomp} {"SIAM J. Comput."}

MACRO {tocs} {"ACM Trans. Comput. Syst."}

MACRO {tods} {"ACM Trans. Database Syst."}

MACRO {tog} {"ACM Trans. Gr."}

MACRO {toms} {"ACM Trans. Math. Softw."}

MACRO {toois} {"ACM Trans. Office Inf. Syst."}

MACRO {toplas} {"ACM Trans. Prog. Lang. Syst."}

MACRO {tcs} {"Theoretical Comput. Sci."}

%</!jour-full>

%    \end{macrocode}
%
% \section{Processing}
%
% \subsection{Input the Entries}
%
% Now we read in the {\tt.bib} entries.
%    \begin{macrocode}
READ

%    \end{macrocode}
%
%\subsection{Auxiliary Functions for Labels}
% The sortify function converts to lower case after |purify$|ing; it's
% used in sorting and in computing alphabetic labels after sorting.
%
% The |chop.word(w,len,s)| function returns either |s| or, if the first
% |len|
% letters of |s| equals |w| (this comparison is done in the third line of the
% function's definition), it returns that part of |s| after |w|.
%    \begin{macrocode}
%<*sorted>

FUNCTION {sortify}
{ purify$
  "l" change.case$
}

INTEGERS { len }

FUNCTION {chop.word}
{ 's :=
  'len :=
  s #1 len substring$ =
    { s len #1 + global.max$ substring$ }
    's
  if$
}

%</sorted>
%<*lab-alph&!sorted>

%    \end{macrocode}
%
% We need the |chop.word| stuff for the dubious 
% \emph{unsorted-list-with-labels} case.
%    \begin{macrocode}
INTEGERS { len }

FUNCTION {chop.word}
{ 's :=
  'len :=
  s #1 len substring$ =
    { s len #1 + global.max$ substring$ }
    's
  if$
}

%</lab-alph&!sorted>

%    \end{macrocode}
%
% \subsection{Making Labels}
% This long comment applies only to alphabetic labels.
%
% The |format.lab.names| function makes a short label by using the initials of
% the von and Last parts of the names (but if there are more than four names,
% (i.e., people) it truncates after three and adds a superscripted |+|;
% it also adds such a |+| if the last of multiple authors is ``others'').
% If there is only one name, and its von and Last parts combined have just
% a single name-token (``Knuth'' has a single token, ``Brinch Hansen'' has two),
% we take the first three letters of the last name.  The boolean
% |et.al.char.used| tells whether we've used a superscripted |+|, so that we
% know whether to include a \LaTeX{} macro for it.
%
% \begin{verbatim}
% format.lab.names(s) ==
%  BEGIN
%       numnames := num.names$(s)
%       if numnames > 1 then
%           if numnames > 4 then
%               namesleft := 3
%           else
%               namesleft := numnames
%           nameptr := 1
%           nameresult := ""
%           while namesleft > 0
%             do
%               if (name_ptr = numnames) and
%                    format.name$(s, nameptr, "{ff }{vv }{ll}{ jj}") = "others"
%                  then nameresult := nameresult * "{\etalchar{+}}"
%                       et.al.char.used := true
%                  else nameresult := nameresult *
%                               format.name$(s, nameptr, "{v{}}{l{}}")
%               nameptr := nameptr + 1
%               namesleft := namesleft - 1
%             od
%           if numnames > 4 then
%               nameresult := nameresult * "{\etalchar{+}}"
%               et.al.char.used := true
%       else
%           t := format.name$(s, 1, "{v{}}{l{}}")
%           if text.length$(t) < 2 then % there's just one name-token
%               nameresult := text.prefix$(format.name$(s,1,"{ll}"),3)
%           else
%               nameresult := t
%           fi
%       fi
%       return nameresult
%  END
% \end{verbatim}
%
% Exactly what fields we look at in constructing the primary part of the label
% depends on the entry type; this selectivity (as opposed to, say, always
% looking at author, then editor, then key) helps ensure that ``ignored''
% fields,
% as described in the \LaTeX{} book, really are ignored.  Note that
% |MISC| is part
% of the deepest `else' clause in the nested part of |calc.label|; thus, any
% unrecognized entry type in the database is handled correctly.
%
% There is one auxiliary function for each of the four different sequences of
% fields we use.  The first of these functions looks at the |author| field, and
% then, if necessary, the |key| field.  The other three functions, which might
% look at two fields and the |key| field, are similar, except that the
% |key| field
% takes precedence over the |organization| field (for labels---not for sorting).
%
% The |calc.label| function calculates the preliminary label of an entry, which
% is formed by taking three letters of information from the |author| or 
% |editor| or
% |key| or |organization| field (depending on the entry type and on 
% what's empty,
% but ignoring a leading ``The '' in the organization), and appending the last
% two characters (digits) of the year. It is an error if the appropriate fields
% among |author|, |editor|, |organization|, and |key| are missing, and we use
% the first three letters of the |cite$| in desperation when this happens.
% The resulting label has the |year| part, but not the |name| part,
% |purify$|ed
% (|purify$|ing the year allows some sorting shenanigans by the user).
%
% This function also calculates the version of the label to be used in sorting.
%
% The final label may need a trailing `a', `b', etc., to distinguish it from
% otherwise identical labels, but we can't calculated those
% |extra.label|s
% until after sorting.
%
% \begin{verbatim}
% calc.label ==
%  BEGIN
%       if type$ = "book" or "inbook" then
%           author.editor.key.label
%       else if type$ = "proceedings" then
%           editor.key.organization.label
%       else if type$ = "manual" then
%           author.key.organization.label
%       else
%           author.key.label
%       fi fi fi
%       label := label * substring$(purify$(field.or.null(year)), -1, 2)
%               % assuming we will also sort, we calculate a sort.label
%       sort.label := sortify(label), but use the last four, not two, digits
%  END
% \end{verbatim}
%    \begin{macrocode}
%<*lab-alph>

INTEGERS { et.al.char.used }

FUNCTION {initialize.et.al.char.used}
{ #0 'et.al.char.used :=
}

EXECUTE {initialize.et.al.char.used}

FUNCTION {format.lab.names}
{ 's :=
  s num.names$ 'numnames :=
  numnames #1 >
    { numnames #4 >
        { #3 'namesleft := }
        { numnames 'namesleft := }
      if$
      #1 'nameptr :=
      ""
        { namesleft #0 > }
        { nameptr numnames =
            { s nameptr "{ff }{vv }{ll}{ jj}" format.name$ "others" =
                { "{\etalchar{+}}" *
                  #1 'et.al.char.used :=
                }
                { s nameptr "{v{}}{l{}}" format.name$ * }
              if$
            }
            { s nameptr "{v{}}{l{}}" format.name$ * }
          if$
          nameptr #1 + 'nameptr :=
          namesleft #1 - 'namesleft :=
        }
      while$
      numnames #4 >
        { "{\etalchar{+}}" *
          #1 'et.al.char.used :=
        }
        'skip$
      if$
    }
    { s #1 "{v{}}{l{}}" format.name$
      duplicate$ text.length$ #2 <
        { pop$ s #1 "{ll}" format.name$ #3 text.prefix$ }
        'skip$
      if$
    }
  if$
}

FUNCTION {author.key.label}
{ author empty$
    { key empty$
%<sorted>        { cite$ #1 #3 substring$ }
%<*!sorted>
%    \end{macrocode}
% We need a warning here because we won't give it later
%    \begin{macrocode}
        { "for label, need author or key in " cite$ * warning$
          cite$ #1 #3 substring$
        }
%</!sorted>
        { key #3 text.prefix$ }
      if$
    }
    { author format.lab.names }
  if$
}

FUNCTION {author.editor.key.label}
{ author empty$
    { editor empty$
        { key empty$
%<sorted>            { cite$ #1 #3 substring$ }
%<*!sorted>
            { "for label, need author, editor, or key in " cite$ * warning$
              cite$ #1 #3 substring$
            }
%</!sorted>
            { key #3 text.prefix$ }
          if$
        }
        { editor format.lab.names }
      if$
    }
    { author format.lab.names }
  if$
}

FUNCTION {author.key.organization.label}
{ author empty$
    { key empty$
        { organization empty$
%<sorted>            { cite$ #1 #3 substring$ }
%<*!sorted>
            { "for label, need author, key, or organization in " cite$ *
                                                                warning$
              cite$ #1 #3 substring$
            }
%</!sorted>
            { "The " #4 organization chop.word #3 text.prefix$ }
          if$
        }
        { key #3 text.prefix$ }
      if$
    }
    { author format.lab.names }
  if$
}

FUNCTION {editor.key.organization.label}
{ editor empty$
    { key empty$
        { organization empty$
%<sorted>            { cite$ #1 #3 substring$ }
%<*!sorted>
            { "for label, need editor, key, or organization in " cite$ *
                                                                warning$
              cite$ #1 #3 substring$
            }
%</!sorted>
            { "The " #4 organization chop.word #3 text.prefix$ }
          if$
        }
        { key #3 text.prefix$ }
      if$
    }
    { editor format.lab.names }
  if$
}

FUNCTION {calc.label}
{ type$ "book" =
  type$ "inbook" =
  or
    'author.editor.key.label
    { type$ "proceedings" =
        'editor.key.organization.label
        { type$ "manual" =
            'author.key.organization.label
            'author.key.label
          if$
        }
      if$
    }
  if$
  duplicate$
  year field.or.null purify$ #-1 #2 substring$
  *
  'label :=
  year field.or.null purify$ #-1 #4 substring$
  *
  sortify 'sort.label :=
}

%    \end{macrocode}
%
% \subsection{Sorting}
% It doesn't seem like a particularly good idea to use an order-of-citation
% reference list when using alphabetic labels, but we need to have a
% special pass to calculate labels when this happens.
%    \begin{macrocode}
%<!sorted>ITERATE {calc.label}

%</lab-alph>

%    \end{macrocode}
%
% When sorting, we compute the sortkey by executing |presort| on each entry.
% The presort key contains a number of |sortify|ed strings, concatenated
% with multiple blanks between them.  This makes things like ``brinch
% per''
% come before ``brinch hansen  per''.
%
% The fields used here are: the |sort.label| for alphabetic labels (as set by
% |calc.label|), followed by the author names (or editor names or organization
% (with a leading ``The '' removed) or key field, depending on entry type and on
% what's empty), followed by year, followed by the first bit of the title
% (chopping off a leading ``The '', ``A '', or ``An '').
% Names are formatted: Von Last First Junior.
% The names within a part will be separated by a single blank
% (such as ``brinch hansen''), two will separate the name parts themselves
% (except the von and last), three will separate the names,
% four will separate the names from year (and from label, if alphabetic),
% and four will separate year from title.
%
% The |sort.format.names| function takes an argument that should be in
% \btx{} name format, and returns a string containing ``\verb*!   !''-separated
% names in the format described above.  The function is almost the same
% as |format.names|.
%    \begin{macrocode}
%<*sorted>

FUNCTION {sort.format.names}
{ 's :=
  #1 'nameptr :=
  ""
  s num.names$ 'numnames :=
  numnames 'namesleft :=
    { namesleft #0 > }
    { nameptr #1 >
        { "   " * }
        'skip$
      if$
%<name-full>      s nameptr "{vv{ } }{ll{ }}{  ff{ }}{  jj{ }}" format.name$ 't :=
%<!name-full>      s nameptr "{vv{ } }{ll{ }}{  f{ }}{  jj{ }}" format.name$ 't :=
      nameptr numnames = t "others" = and
        { "et al" * }
        { t sortify * }
      if$
      nameptr #1 + 'nameptr :=
      namesleft #1 - 'namesleft :=
    }
  while$
}

%    \end{macrocode}
% The |sort.format.title| function returns the argument,
% but first any leading ``A ''\,'s, ``An ''\,'s, or ``The ''\,'s are removed.
% The |chop.word| function uses |s|, so we need another string variable,
% |t|.
%    \begin{macrocode}
FUNCTION {sort.format.title}
{ 't :=
  "A " #2
    "An " #3
      "The " #4 t chop.word
    chop.word
  chop.word
  sortify
  #1 global.max$ substring$
}

%    \end{macrocode}
%
% The auxiliary functions here, for the |presort| function, are analogous to
% the ones for |calc.label|; the same comments apply, except that the
% |organization| field takes precedence here over the |key| field.  For sorting
% purposes, we still remove a leading ``The '' from the |organization| field.
%    \begin{macrocode}
FUNCTION {author.sort}
{ author empty$
    { key empty$
        { "to sort, need author or key in " cite$ * warning$
          ""
        }
        { key sortify }
      if$
    }
    { author sort.format.names }
  if$
}

FUNCTION {author.editor.sort}
{ author empty$
    { editor empty$
        { key empty$
            { "to sort, need author, editor, or key in " cite$ * warning$
              ""
            }
            { key sortify }
          if$
        }
        { editor sort.format.names }
      if$
    }
    { author sort.format.names }
  if$
}

FUNCTION {author.organization.sort}
{ author empty$
    { organization empty$
        { key empty$
            { "to sort, need author, organization, or key in " cite$ * warning$
              ""
            }
            { key sortify }
          if$
        }
        { "The " #4 organization chop.word sortify }
      if$
    }
    { author sort.format.names }
  if$
}

FUNCTION {editor.organization.sort}
{ editor empty$
    { organization empty$
        { key empty$
            { "to sort, need editor, organization, or key in " cite$ * warning$
              ""
            }
            { key sortify }
          if$
        }
        { "The " #4 organization chop.word sortify }
      if$
    }
    { editor sort.format.names }
  if$
}

%    \end{macrocode}
% There is a limit, |entry.max$|, on the length of an entry string variable
% (which is what its |sort.key$| is), so we take at most that many characters
% of the constructed key, and hope there aren't many references that match
% to that many characters!
%    \begin{macrocode}
FUNCTION {presort}
%<*lab-alph>
{ calc.label
  sort.label
  "    "
  *
  type$ "book" =
%</lab-alph>
%<!lab-alph>{ type$ "book" =
  type$ "inbook" =
  or
    'author.editor.sort
    { type$ "proceedings" =
        'editor.organization.sort
        { type$ "manual" =
            'author.organization.sort
            'author.sort
          if$
        }
      if$
    }
  if$
%<lab-alph> *
  "    "
  *
  year field.or.null sortify
  *
  "    "
  *
  title field.or.null
  sort.format.title
  *
  #1 entry.max$ substring$
  'sort.key$ :=
}

ITERATE {presort}

%    \end{macrocode}
%
% And now we can sort.
%    \begin{macrocode}
SORT

%</sorted>

%    \end{macrocode}
%
% \subsection{Sorted Alphabetic Labels}
% This long comment applies only to alphabetic labels, when sorted.
%
% Now comes the final computation for alphabetic labels, putting in the `a's
% and `b's and so forth if required.  This involves two passes: a forward
% pass to put in the `b's, `c's and so on, and a backwards pass
% to put in the `a's (we don't want to put in `a's unless we know there
% are `b's).
% We have to keep track of the longest (in |width$| terms) label, for use
% by the |thebibliography| environment.
%
% \begin{quote}
% VAR: |longest.label|, |last.sort.label|, |next.extra|:\quad string \\
% \quad |longest.label.width|, |last.extra.num|: \quad integer
% \end{quote}
%
% \begin{verbatim}
% initialize.longest.label ==
%  BEGIN
%       longest.label := ""
%       last.sort.label := int.to.chr$(0)
%       next.extra := ""
%       longest.label.width := 0
%       last.extra.num := 0
%  END
%
% forward.pass ==
%  BEGIN
%       if last.sort.label = sort.label then
%           last.extra.num := last.extra.num + 1
%           extra.label := int.to.chr$(last.extra.num)
%       else
%           last.extra.num := chr.to.int$("a")
%           extra.label := ""
%           last.sort.label := sort.label
%       fi
%  END
%
% reverse.pass ==
%  BEGIN
%       if next.extra = "b" then
%           extra.label := "a"
%       fi
%       label := label * extra.label
%       if width$(label) > longest.label.width then
%           longest.label := label
%           longest.label.width := width$(label)
%       fi
%       next.extra := extra.label
%  END
%
% \end{verbatim}
%    \begin{macrocode}
%<*lab-alph>
%<*sorted>

STRINGS { longest.label last.sort.label next.extra }

INTEGERS { longest.label.width last.extra.num }

FUNCTION {initialize.longest.label}
{ "" 'longest.label :=
  #0 int.to.chr$ 'last.sort.label :=
  "" 'next.extra :=
  #0 'longest.label.width :=
  #0 'last.extra.num :=
}

FUNCTION {forward.pass}
{ last.sort.label sort.label =
    { last.extra.num #1 + 'last.extra.num :=
      last.extra.num int.to.chr$ 'extra.label :=
    }
    { "a" chr.to.int$ 'last.extra.num :=
      "" 'extra.label :=
      sort.label 'last.sort.label :=
    }
  if$
}

FUNCTION {reverse.pass}
{ next.extra "b" =
    { "a" 'extra.label := }
    'skip$
  if$
  label extra.label * 'label :=
  label width$ longest.label.width >
    { label 'longest.label :=
      label width$ 'longest.label.width :=
    }
    'skip$
  if$
  extra.label 'next.extra :=
}

EXECUTE {initialize.longest.label}

ITERATE {forward.pass}

REVERSE {reverse.pass}

%</sorted>
%<*!sorted>

%    \end{macrocode}
% It still doesn't seem like a good idea to use an order-of-citation
% reference list when using alphabetic labels, but when this happens we
% must compute the longest label
%    \begin{macrocode}
STRINGS { longest.label }

INTEGERS { longest.label.width }

FUNCTION {initialize.longest.label}
{ "" 'longest.label :=
  #0 'longest.label.width :=
}

FUNCTION {longest.label.pass}
{ label width$ longest.label.width >
    { label 'longest.label :=
      label width$ 'longest.label.width :=
    }
    'skip$
  if$
}

EXECUTE {initialize.longest.label}

ITERATE {longest.label.pass}

%</!sorted>
%</lab-alph>
%<*!lab-alph>

%    \end{macrocode}
% 
% \subsection{Numeric Labels}
% Now comes the computation for numeric labels.
% We use either the sorted order or original order.
% We still have to keep track of the longest (in |width$| terms) label, for use
% by the |thebibliography| environment.
%    \begin{macrocode}
STRINGS { longest.label }

INTEGERS { number.label longest.label.width }

FUNCTION {initialize.longest.label}
{ "" 'longest.label :=
  #1 'number.label :=
  #0 'longest.label.width :=
}

FUNCTION {longest.label.pass}
{ number.label int.to.str$ 'label :=
  number.label #1 + 'number.label :=
  label width$ longest.label.width >
    { label 'longest.label :=
      label width$ 'longest.label.width :=
    }
    'skip$
  if$
}

EXECUTE {initialize.longest.label}

ITERATE {longest.label.pass}

%</!lab-alph>

%    \end{macrocode}
%
% \subsection{Writing the {\tt.bbl} File}
% Now we're ready to start writing the {\tt.bbl} file.
% We begin, if necessary, with a \LaTeX{} macro for unnamed names in an 
% alphabetic
% label; next comes stuff from the |preamble| command in the database files.
% Then we give an incantation containing the command
% \begin{quote}
% |    \begin{thebibliography}{...}|
% \end{quote}
% where the |...| is the longest label.
%
% We also call |init.state.consts|, for use by the output routines.
%    \begin{macrocode}
FUNCTION {begin.bib}
%<*lab-alph>
{ et.al.char.used
    { "\newcommand{\etalchar}[1]{$^{#1}$}" write$ newline$ }
    'skip$
  if$
  preamble$ empty$
%</lab-alph>
%<!lab-alph>{ preamble$ empty$
    'skip$
    { preamble$ write$ newline$ }
  if$
  "\begin{thebibliography}{"  longest.label  * "}" * write$ newline$
}

EXECUTE {begin.bib}

EXECUTE {init.state.consts}

%    \end{macrocode}
%
% Now we produce the output for all the entries.
%    \begin{macrocode}
ITERATE {call.type$}

%    \end{macrocode}
%
% Finally, we finish up by writing the `|\end{thebibliography}|' command.
%    \begin{macrocode}
FUNCTION {end.bib}
{ newline$
  "\end{thebibliography}" write$ newline$
}

EXECUTE {end.bib}
%</!options>
%    \end{macrocode}
% 
% \Finale
