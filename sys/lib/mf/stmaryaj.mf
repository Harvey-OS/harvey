%%% ====================================================================
%%%  @METAFONT-file{
%%%     author-1        = "Jeremy Gibbons",
%%%     author-2        = "Alan Jeffrey",
%%%     version         = "1.1",
%%%     date            = "02 June 1992",
%%%     time            = "15:06:36 BST",
%%%     filename        = "stmaryaj.mf",
%%%     address-1       = "Department of Computer Science
%%%                        University of Aukland
%%%                        Private Bag
%%%                        Aukland
%%%                        New Zealand",
%%%     address-2       = "School of Cognitive and Computing Sciences
%%%                        University of Sussex
%%%                        Brighton BN1 9QH
%%%                        UK",
%%%     telephone-1     = "+64 9 373 7599 x 5120",
%%%     telephone-2     = "+44 273 606755 x 3238",
%%%     FAX-1           = "+64 9 373 7453",
%%%     FAX-2           = "+44 273 678188",
%%%     checksum        = "16420 1066 3686 40419",
%%%     email-1         = "jeremy@cs.aukuni.ac.nz",
%%%     email-2         = "alanje@cogs.sussex.ac.uk",
%%%     codetable       = "ISO/ASCII",
%%%     keywords        = "metafont symbols math fonts",
%%%     supported       = "yes",
%%%     abstract        = "This is part of the metafont program for
%%%                        the St Mary's Road symbol font.",
%%%     docstring       = "This is part of the metafont program for
%%%                        the St Mary's Road symbol font.  The font
%%%                        contains a number of mathematical
%%%                        characters which are not present in the
%%%                        standard TeX and AMS symbol fonts.
%%%
%%%                        It is described in stmaryrd.tex.
%%%
%%%                        Copyright 1992 Jeremy Gibbons and Alan Jeffrey.
%%%
%%%                        The checksum field above contains a CRC-16
%%%                        checksum as the first value, followed by the
%%%                        equivalent of the standard UNIX wc (word
%%%                        count) utility output of lines, words, and
%%%                        characters.  This is produced by Robert
%%%                        Solovay's checksum utility.",
%%%     package         = "St Mary's Road",
%%%     dependencies    = "none",
%%%  }
%%% ====================================================================
%%%
%%% 20 May 1991, v1.0: Created the font out of alans.mf and galileo.mf.
%%%
%%% 24 May 1991, v1.01: Finished the first version.
%%%
%%% 25 Jun 1991, v1.02: Corrected bugs with arrow_not and Arrow_not.
%%%
%%% 2 Jun 1992, v1.1: added the headers.

iff known left_right_arrow_eq:
cmchar "Left and right arrow equality";
compute_spread(.45x_height#,.55x_height#);
beginchar(left_right_arrow_eq,14u#,v_center(spread#+.96asc_height#));
adjust_fit(0,0); pickup crisp.nib; pos1(rule_thickness,90);
pos2(rule_thickness,90); pos3(bar,0); pos4(bar,0);
y0=y1=y2=math_axis; x1=.5w; rt
x0=hround(w-.75u); y3-y0=y0-y4=.24asc_height+eps;
x3=x4=x0-3u-eps; pos5(bar,angle(z4-z0)); z5l=z0;
pos6(bar,angle(z3-z0)); z6l=z0; z9=.381966[.5[z3,z4],z0];
numeric t; path p; p=z4l{z9-z4}..z6r; t=xpart(p
intersectiontimes((0,y2l)--(w,y2l))); x2=xpart point t of p;
path p; p=z0..{z4-z9}z4r--subpath (0,t)
of\\(z4l{z9-z4}..z6r)
 --z2l---z1l..z1r---z2r--subpath (t,0) of\\(z3l{z9-z3}..z5r)
 --z3r{z9-z3}..z0 & cycle;  % arrowhead and stem
p:=p shifted (0,.5spread); filldraw p; % top
addto currentpicture also currentpicture xscaled -1 shifted (w,0);
pickup rule.nib;
lft x10=hround u; x11=w-x10; y10=y11=math_axis-.5spread;
draw z10--z11;  % bottom
penlabels(0,1,2,3,4,5,6,9,10,11); endchar;

iff known curly_vee_down_arrow:
cmchar "Upside-down upwards accumulate symbol";
beginchar(curly_vee_down_arrow,12u#,asc_height#,asc_depth#);
adjust_fit(0,0); pickup rule.nib;
x2=good.x .5w; w:=r:=2x2;
lft x1=0; x3=w-x1;
bot y1=-d; top y2=h+o; y3=y1;
x4=x2; y4=h-(x_height+d);
pickup crisp.nib;
pos11(rule_thickness,0); pos12(rule_thickness,0);     % arrow head nicked from
pos13(bar,90); pos14(bar,90);                         % up_arrow
lft x11l=hround(.5w-.5rule_thickness); y11-.5rule_thickness=-d;
x10=x11=x12; top y10=top y2; x10-x13=x14-x10=3u+eps;
y13=y14=y10-.24asc_height-eps;
pos15(bar,angle(z14-z10)); z15l=z10;
pos16(bar,angle(z13-z10)); z16l=z10;
z19=.381966[.5[z13,z14],z10];
numeric t; path p; p=z14l{z19-z14}..z16r;
t=xpart(p intersectiontimes((x12r,-d)--(x12r,h))); y12=ypart point t of p;
filldraw z10..{z14-z19}z14r--subpath (0,t) of\\(z14l{z19-z14}..z16r)
 --z12r
 -- % ---z11r..z11l---
 z12l--subpath (t,0) of\\(z13l{z19-z13}..z15r)
 --z13r{z19-z13}..z10 & cycle;  % arrowhead
pickup rule.nib;
numeric t; path p; p=z1{z4-z1}..{up}z2;
t=xpart(p intersectiontimes((0,y12)--(w,y12)));
draw subpath (0,t) of\\(z1{z4-z1}..{up}z2);  % left arm
draw subpath (0,t) of\\(z3{z4-z3}..{up}z2);  % right arm
currentpicture:= currentpicture yscaled -1 shifted (0,h-d);
endchar;

iff known curly_vee_up_arrow:
cmchar "Upside-down downwards accumulate symbol";
beginchar(curly_vee_up_arrow,12u#,asc_height#,asc_depth#);
adjust_fit(0,0); pickup rule.nib;
x2=good.x .5w; w:=r:=2x2;
lft x1=0; x3=w-x1;
bot y1=-d; top y2=h+o; y3=y1;
x4=x2; y4=h-(x_height+d);
pickup crisp.nib;
numeric theta,delta; theta=angle(z4-z1); delta=3u++.24asc_height;
pos11(rule_thickness,-90+theta); pos12(rule_thickness,-90+theta);
pos13(bar,-180+theta); pos14(bar,-180+theta);
lft x10=0; bot y10=-d;
x11=w; z11=z10+whatever*(dir theta);  % where the arrow stem would go
y13a=y10; x14a=x10; x13a-x10=y14a-y10=delta+eps;
z13=z13a rotatedaround(z10,theta-45);
z14=z14a rotatedaround(z10,theta-45);
pos15(bar,theta+45); z15l=z10; pos16(bar,theta-45); z16l=z10;
z19=.381966[.5[z13,z14],z10];
numeric t; path p; p=z14l{z19-z14}..z16r;
t=xpart(p intersectiontimes (z11l--(z11l+2(z10-z11)))); z12l=point t of p;
filldraw z10..{z14-z19}z14r
 --subpath (0,t) of\\(z14l{z19-z14}..z16r)
 --z12l
 -- % ---z11l..z11r---
 z12r
 --subpath (t,0) of\\(z13l{z19-z13}..z15r)
 --z13r{z19-z13}..z10 & cycle;  % left arrowhead
numeric theta,delta; theta=angle(z3-z4); delta=3u++.24asc_height;
pos21(rule_thickness,90+theta); pos22(rule_thickness,90+theta);
pos23(bar,theta); pos24(bar,theta);
rt x20=w; bot y20=-d;
x21=0; z21=z20+whatever*-(dir theta);  % where the arrow stem would go
x23a=x20; y24a=y20; y23a-y20=x20-x24a=delta+eps;
z23=z23a rotatedaround(z20,theta+45);
z24=z24a rotatedaround(z20,theta+45);
pos25(bar,theta+225); z25l=z20; pos26(bar,theta+135); z26l=z20;
z29=.381966[.5[z23,z24],z20];
numeric t; path p; p=z24l{z29-z24}..z26r;
t=xpart(p intersectiontimes (z21l--(z21l+2(z20-z21)))); z22l=point t of p;
filldraw z20..{z24-z29}z24r
 --subpath (0,t) of\\(z24l{z29-z24}..z26r)
 --z22l
 -- % ---z21l..z21r---
 z22r
 --subpath (t,0) of\\(z23l{z29-z23}..z25r)
 --z23r{z29-z23}..z20 & cycle;  % right arrowhead
pickup rule.nib;
numeric t; path p; p=z2{down}..{z1-z4}z1;
t=xpart(p intersectiontimes(z12l--z12r));
draw subpath (0,t) of\\(z2{down}..{z1-z4}z1);  % left arm
draw subpath (0,t) of\\(z2{down}..{z3-z4}z3);  % right arm
currentpicture:= currentpicture yscaled -1 shifted (0,h-d);
endchar;

iff known nnw_arrow: cmchar "Northnorthwest arrow";
beginchar(nnw_arrow,11u#,asc_height#,asc_depth#);
adjust_fit(0,0); pickup crisp.nib;
x1+.5rule_thickness=hround(w-u); lft x0=hround 3u;  % This 3u used to be a u in
y1+.5rule_thickness=h; bot y0=-d;                   % the program for swarrow.
                                                    % 3u (with width 11u) gives
                                                    % arrow parallel to langle.
numeric theta,delta; theta=angle(z1-z0); delta=3u++.24asc_height;
if abs(theta-45)<2.5: theta:=45; y1:=y0+x1-x0; fi % near-45$^\circ$ angle
pos1(rule_thickness,-90+theta); pos2(rule_thickness,-90+theta);
pos3(bar,-180+theta); pos4(bar,-180+theta);
    %y3=y0; x4=x0; x3-x0=y4-y0=delta+eps;
y10=y0; x11=x0; x10-x0=y11-y0=delta+eps;   % Can now do arrows of any angle
z3=z10 rotatedaround(z0,theta-45);
z4=z11 rotatedaround(z0,theta-45);
pos5(bar,theta+45); z5l=z0; pos6(bar,theta-45); z6l=z0;
z9=.381966[.5[z3,z4],z0];
numeric t; path p; p=z4l{z9-z4}..z6r;
t=xpart(p intersectiontimes (z1l--(z1l+2(z0-z1)))); z2l=point t of p;
filldraw z0..{z4-z9}z4r
 --subpath (0,t) of\\(z4l{z9-z4}..z6r)
 --z2l---z1l..z1r---z2r
 --subpath (t,0) of\\(z3l{z9-z3}..z5r)
 --z3r{z9-z3}..z0 & cycle;  % arrowhead and stem
currentpicture:= currentpicture yscaled -1 shifted (0,h-d);
endchar;

iff known nne_arrow: cmchar "Northnortheast arrow";
beginchar(nne_arrow,11u#,asc_height#,asc_depth#);
adjust_fit(0,0); pickup crisp.nib;
x1-.5rule_thickness=hround u; rt x0=hround(w-3u);
y1+.5rule_thickness=h; bot y0=-d;
numeric theta,delta; theta=angle(z0-z1); delta=3u++.24asc_height;
if abs(theta+45)<2.5: theta:=-45; y1:=y0+x0-x1; fi % near-45$^\circ$ angle
pos1(rule_thickness,90+theta); pos2(rule_thickness,90+theta);
pos3(bar,theta); pos4(bar,theta);
   %x3=x0; y4=y0; y3-y0=x0-x4=delta+eps;
x10=x0; y11=y0; y10-y0=x0-x11=delta+eps;
z3=z10 rotatedaround(z0,theta+45);
z4=z11 rotatedaround(z0,theta+45);
pos5(bar,theta+225); z5l=z0; pos6(bar,theta+135); z6l=z0;
z9=.381966[.5[z3,z4],z0];
numeric t; path p; p=z4l{z9-z4}..z6r;
t=xpart(p intersectiontimes (z1l--(z1l+2(z0-z1)))); z2l=point t of p;
filldraw z0..{z4-z9}z4r
 --subpath (0,t) of\\(z4l{z9-z4}..z6r)
 --z2l---z1l..z1r---z2r
 --subpath (t,0) of\\(z3l{z9-z3}..z5r)
 --z3r{z9-z3}..z0 & cycle;  % arrowhead and stem
currentpicture:= currentpicture yscaled -1 shifted (0,h-d);
endchar;

iff known left_slice: cmchar "Left slice";
beginarithchar(left_slice); pickup rule.nib; autorounded;
lft x6=hround u; x2=w-x6; y2=math_axis; y8-y2 = .5(x2-x6);
circle_points;    % circle
draw z1--z6--z3;  % lessthan
draw z1..z2..z3;  % arc
labels(1,2,3,4,5,6,7,8); endchar;

iff known right_slice: cmchar "Right slice";
beginarithchar(right_slice); pickup rule.nib; autorounded;
lft x6=hround u; x2=w-x6; y2=math_axis; y8-y2 = .5(x2-x6);
circle_points;    % circle
draw z5--z2--z7;  % greaterthan
draw z5..z6..z7;  % arc
labels(1,2,3,4,5,6,7,8); endchar;

iff known var_o_less_than: cmchar "Circular circle-lessthan operator";
begincircle(var_o_less_than);
draw z1--z6--z3;  % lessthan
labels(1,2,3,4,5,6,7,8); endchar;

iff known var_o_greater_than: cmchar "Circular circle-greaterthan operator";
begincircle(var_o_greater_than);
draw z5--z2--z7;  % greaterthan
labels(1,2,3,4,5,6,7,8); endchar;

iff known var_o_vee: cmchar "Circular circle-vee operator";
begincircle(var_o_vee);
draw z1--z4--z7;  % vee
labels(1,2,3,4,5,6,7,8); endchar;

iff known var_o_wedge: cmchar "Circular circle-wedge operator";
begincircle(var_o_wedge);
draw z3--z8--z5;  % wedge
labels(1,2,3,4,5,6,7,8); endchar;

iff known tall_oblong: cmchar "Tall oblong (Dijkstra choice symbol)";
beginchar(tall_oblong,9u#,body_height#,paren_depth#);
adjust_fit(0,0); pickup rule.nib;
x1=x2; top y1=h; .5[y1,y2]=math_axis;
x3=x4=w-x1; y3=y1; y4=y2;
compute_spread(.45x_height#,.55x_height#); x3-x1=spread;
draw z1--z2--z4--z3--cycle;  % stems
labels(1,2,3,4); endchar;

iff known interleave:
cmchar "Triple vertical line (interleaving)";
beginchar(interleave,12.5u#,body_height#,paren_depth#);
adjust_fit(0,0); pickup rule.nib;
compute_spread(.45x_height#,.55x_height#);
x1=x2; top y1=h; .5[y1,y2]=math_axis;
x4=x3; x5=x6=w-x1; y5=y3=y1; y6=y4=y2;
x3-x1=x5-x3=hround spread;
draw z1--z2; draw z3--z4; draw z5--z6;  % stems
labels(1,2,3,4,5,6); endchar;

iff known o_bar: cmchar "Circle-bar operator";
beginarithchar(o_bar); pickup light_rule.nib; autorounded;
lft x6=hround u; x2=w-x6; y2=math_axis; top y8=h;
circle_points; draw_circle;  % circle
draw z4--z8;  % bar
labels(1,2,3,4,5,6,7,8); endchar;

iff known o_bslash: cmchar "Circle-backslash operator";
beginarithchar(o_bslash); pickup light_rule.nib; autorounded;
lft x6=hround u; x2=w-x6; y2=math_axis; top y8=h;
circle_points; draw_circle;  % circle
draw z3--z7;  % diagonal
labels(1,2,3,4,5,6,7,8); endchar;

iff known o_less_than: cmchar "Circle-lessthan operator";
beginarithchar(o_less_than); pickup light_rule.nib; autorounded;
lft x6=hround u; x2=w-x6; y2=math_axis; top y8=h;
circle_points; draw_circle;  % circle
draw z1--z6--z3;  % lessthan
labels(1,2,3,4,5,6,7,8); endchar;

iff known o_greater_than: cmchar "Circle-greaterthan operator";
beginarithchar(o_greater_than); pickup light_rule.nib; autorounded;
lft x6=hround u; x2=w-x6; y2=math_axis; top y8=h;
circle_points; draw_circle;  % circle
draw z5--z2--z7;  % greaterthan
labels(1,2,3,4,5,6,7,8); endchar;

iff known o_vee: cmchar "Circle-vee operator";
beginarithchar(o_vee); pickup light_rule.nib; autorounded;
lft x6=hround u; x2=w-x6; y2=math_axis; top y8=h;
circle_points; draw_circle;  % circle
draw z1--z4--z7;  % vee
labels(1,2,3,4,5,6,7,8); endchar;

iff known o_wedge: cmchar "Circle-wedge operator";
beginarithchar(o_wedge); pickup light_rule.nib; autorounded;
lft x6=hround u; x2=w-x6; y2=math_axis; top y8=h;
circle_points; draw_circle;  % circle
draw z3--z8--z5;  % wedge
labels(1,2,3,4,5,6,7,8); endchar;

iff known oblong:
cmchar "Oblong (Hoare choice)";
beginchar(oblong,12u#,.8asc_height#,0);
adjust_fit(0,0); pickup rule.nib;
lft x1=hround 1.1u; x2=x1; x4=x5=w-x1;
y1=good.y h+o; bot y2=0; y4=y2; y5=y1;
draw z1---z2---z4---z5--cycle;  % stems and bar
labels(1,2,4,5); endchar;

iff known in_plus: cmchar "Bag element sign";
compute_spread(5/4x_height#,3/2x_height#);
beginchar(in_plus,12u#,v_center(spread#+rule_thickness#));
italcorr h#*slant-u#;
adjust_fit(0,0); pickup rule.nib; autorounded;
lft x2=hround 1.5u-eps; x1=x3=x6=w-x2;
y1-y3=spread; y2=y6=.5[y1,y3]=math_axis;
x4=x5=.5w+u; y4=y1; y5=y3;
draw z1---z4...z2{down}...z5---z3;  % arc and bars
draw z2--z6;  % middle bar
x12=x13=.47[x1,x2]; y12=y1-3rule_thickness+eps; y13=y3+3rule_thickness+eps;
draw z12--z13; % vertical bar
labels(1,2,3,4,5,6,12,13); endchar;

iff known ni_plus: cmchar "Reversed bag element sign";
compute_spread(5/4x_height#,3/2x_height#);
beginchar(ni_plus,12u#,v_center(spread#+rule_thickness#));
italcorr h#*slant-u#;
adjust_fit(0,0); pickup rule.nib; autorounded;
lft x1=hround 1.5u-eps; x1=x3=x6=w-x2;
y1-y3=spread; y2=y6=.5[y1,y3]=math_axis;
x4=x5=.5w-u; y4=y1; y5=y3;
draw z1---z4...z2{down}...z5---z3;  % arc and bars
draw z2--z6;  % middle bar
x12=x13=.47[x1,x2]; y12=y1-3rule_thickness+eps; y13=y3+3rule_thickness+eps;
draw z12--z13; % vertical bar
labels(1,2,3,4,5,6,12,13); endchar;

iff known n_plus: cmchar "Bag intersection";
beginchar(n_plus,12u#,.8asc_height#,0);
italcorr .8asc_height#*slant-.5u#;
adjust_fit(0,0); pickup rule.nib; autorounded;
lft x1=hround u; x2=x1; x3=w-x3; x4=x5=w-x1;
y3=good.y h+o; bot y1=-o; y2=y4=2/3[y1,y3]; y5=y1;
draw z1---z2...z3...z4---z5;  % stems and cap
y8=y9=.47[y1,y3]; x8=w-x9=x1+2rule_thickness+eps;
x6=x7=x3; .5[y6,y7]=y8; y7-y6=x9-x8;
draw z6--z7; draw z8--z9;  % enclosed plus sign
labels(1,2,3,4,5,6,7,8,9); endchar;

iff known sub_set_plus: cmchar "Proper subbag sign";
compute_spread(5/4x_height#,3/2x_height#);
beginchar(sub_set_plus,14u#,v_center(spread#+rule_thickness#));
italcorr h#*slant-u#;
adjust_fit(0,0); pickup rule.nib; autorounded;
lft x2=hround 1.5u-eps; x1=x3=w-x2;
y1-y3=spread; y2=.5[y1,y3]=math_axis;
x4=x5=.5w; y4=y1; y5=y3;
draw z1---z4...z2{down}...z5---z3;  % arc and bars
x12=x13=.40[x1,x2]; y12=y1-3rule_thickness+eps; y13=y3+3rule_thickness+eps;
y10=y11=y2; .5[x10,x11]=x12; x11-x10=y12-y13;
draw z12--z13; draw z10--z11;  % enclosed plus sign
labels(1,2,3,4,5,10,11,12,13); endchar;

iff known sup_set_plus: cmchar "Proper superbag sign";
compute_spread(5/4x_height#,3/2x_height#);
beginchar(sup_set_plus,14u#,v_center(spread#+rule_thickness#));
italcorr h#*slant-u#;
adjust_fit(0,0); pickup rule.nib; autorounded;
lft x1=hround 1.5u-eps; x2=w-x1; x3=x1;
y1-y3=spread; y2=.5[y1,y3]=math_axis;
x4=x5=.5w; y4=y1; y5=y3;
draw z1---z4...z2{down}...z5---z3;  % arc and bars
x12=x13=.40[x1,x2]; y12=y1-3rule_thickness+eps; y13=y3+3rule_thickness+eps;
y10=y11=y2; .5[x10,x11]=x12; x11-x10=y12-y13;
draw z12--z13; draw z10--z11;  % enclosed plus sign
labels(1,2,3,4,5,10,11,12,13); endchar;

iff known sub_set_plus_eq: cmchar "Subbag or equal to sign";
compute_spread(.45x_height#,.55x_height#);
spread#':=spread#; spread':=spread; % the spread of `$=$'
compute_spread(5/4x_height#,3/2x_height#);
beginchar(sub_set_plus_eq,14u#,v_center(spread#'+spread#+rule_thickness#));
adjust_fit(0,0); pickup rule.nib; autorounded;
lft x2=hround 1.5u-eps; x1=x3=w-x2;
y1-y3=spread; y2=.5[y1,y3]; top y1=h;
x4=x5=.5w; y4=y1; y5=y3;
draw z1---z4...z2{down}...z5---z3;  % arc and bars
x8=x1; lft x9=x2; y8=y9; y3-y9=spread'; draw z8--z9;  % lower bar
x12=x13=.40[x1,x2]; y12=y1-3rule_thickness+eps; y13=y3+3rule_thickness+eps;
y10=y11=y2; .5[x10,x11]=x12; x11-x10=y12-y13;
draw z12--z13; draw z10--z11;  % enclosed plus sign
labels(1,2,3,4,5,7,8,10,11,12,13); endchar;

iff known sup_set_plus_eq: cmchar "Superbag or equal to sign";
compute_spread(.45x_height#,.55x_height#);
spread#':=spread#; spread':=spread; % the spread of `$=$'
compute_spread(5/4x_height#,3/2x_height#);
beginchar(sup_set_plus_eq,14u#,v_center(spread#'+spread#+rule_thickness#));
adjust_fit(0,0); pickup rule.nib; autorounded;
lft x1=hround 1.5u-eps; x2=w-x1; x3=x1;
y1-y3=spread; y2=.5[y1,y3]; top y1=h;
x4=x5=.5w; y4=y1; y5=y3;
draw z1---z4...z2{down}...z5---z3;  % arc and bars
x8=x1; rt x9=x2; y8=y9; y3-y9=spread'; draw z8--z9;  % lower bar
x12=x13=.40[x1,x2]; y12=y1-3rule_thickness+eps; y13=y3+3rule_thickness+eps;
y10=y11=y2; .5[x10,x11]=x12; x11-x10=y12-y13;
draw z12--z13; draw z10--z11;  % enclosed plus sign
labels(1,2,3,4,5,7,8,10,11,12,13); endchar;

iff known L_bag: cmchar "Left bag bracket";
beginchar(L_bag,8u#,body_height#,paren_depth#);
      % ht and dp from "left parenthesis" symbol
adjust_fit(0,0); pickup fine.nib;
pos0(hair,180); pos1(vair,90); pos2(hair,0);
pos3(cap_stem,0); pos4(vair,90); pos5(flare,180);
lft x0r=lft x3l=lft x5r=hround u; y0=h-2u;
x1=1/2[x0,x2]; top y1r=h;
x2=2/3[x0,x4]; y2=y0;
y3=0;
x4=w-x0r; bot y4l=-d;
filldraw stroke z1e{right}..z2e{down}..z3e{down}..{right}z4e; % arc
bulb(1,0,5);
penlabels(0,1,2,3,4,5); endchar;

iff known R_bag: cmchar "Right bag bracket";
beginchar(R_bag,8u#,body_height#,paren_depth#);
      % ht and dp from "left parenthesis" symbol
adjust_fit(0,0); pickup fine.nib;
pos0(hair,180); pos1(vair,90); pos2(hair,0);
pos3(cap_stem,0); pos4(vair,90); pos5(flare,180);
lft x0r=lft x3l=lft x5r=hround u; y0=h-2u;
x1=1/2[x0,x2]; top y1r=h;
x2=2/3[x0,x4]; y2=y0;
y3=0;
x4=w-x0r; bot y4l=-d;
filldraw stroke z1e{right}..z2e{down}..z3e{down}..{right}z4e; % arc
bulb(1,0,5);
currentpicture:= currentpicture xscaled -1 shifted (w,0);  % OK, so sue me!
endchar;

iff known ll_bracket:
cmchar "Left semantic bracket [[";
beginchar(ll_bracket,7.25u#,body_height#,paren_depth#);
adjust_fit(0,0);
pickup crisp.nib; pos1(rule_thickness,0); pos2(rule_thickness,0);
top y1=h; bot y2=-d; lft x1l=lft x2l=hround(2.5u-.5rule_thickness)-1-eps;
filldraw stroke z1e--z2e;  % left stem
pos7(rule_thickness,0); pos8(rule_thickness,0);
top y7=h; bot y8=-d; lft x7l=lft x8l=hround(4.75u-.5rule_thickness)-1-eps;
filldraw stroke z7e--z8e;  % right stem
pos3(rule_thickness,90); pos4(rule_thickness,90);
pos5(rule_thickness,90); pos6(rule_thickness,90);
x3=x5=x1l; rt x4=rt x6=ceiling(w-.4u)+eps; y3r=y4r=y1; y5l=y6l=y2;
filldraw stroke z3e--z4e;  % upper bar
filldraw stroke z5e--z6e;  % lower bar
penlabels(1,2,3,4,5,6,7,8); endchar;

iff known rr_bracket:
cmchar "Right semantic bracket ]]";
beginchar(rr_bracket,7.25u#,body_height#,paren_depth#);
adjust_fit(0,0);
pickup crisp.nib; pos1(rule_thickness,0); pos2(rule_thickness,0);
top y1=h; bot y2=-d; rt x1r=rt x2r=hround(w-2.5u+.5rule_thickness)+1+eps;
filldraw stroke z1e--z2e;  % left stem
pos7(rule_thickness,0); pos8(rule_thickness,0);
top y7=h; bot y8=-d; rt x7r=rt x8r=hround(w-4.75u+.5rule_thickness)+1+eps;
filldraw stroke z7e--z8e;  % right stem
pos3(rule_thickness,90); pos4(rule_thickness,90);
pos5(rule_thickness,90); pos6(rule_thickness,90);
x3=x5=x1l; lft x4=lft x6=ceiling(.4u)-eps; y3r=y4r=y1; y5l=y6l=y2;
filldraw stroke z3e--z4e;  % upper bar
filldraw stroke z5e--z6e;  % lower bar
penlabels(1,2,3,4,5,6,7,8); endchar;

iff known ll_parenthesis:
cmchar "Left relational image (|";
beginchar(ll_parenthesis,7u#,body_height#,paren_depth#);
italcorr body_height#*slant-.5u#;
adjust_fit(0,0); pickup fine.nib;
pos1(vair,0); pos2(.75[hair,stem],0); pos3(vair,0);
rt x1r=rt x3r=hround(w-u); lft x2l=hround(x1-4u);
top y1=h; y2=.5[y1,y3]=math_axis;
filldraw stroke z1e{3(x2e-x1e),y2-y1}...z2e
 ...{3(x3e-x2e),y3-y2}z3e;  % arc
pos4(whatever,45); pos5(whatever,-45);
rt x4r-lft x4l=rt x5r-lft x5l=rule_thickness;
z4r=z1r; z5r=z3r;
filldraw stroke z4e--z5e;
penlabels(1,2,3,4,5); endchar;

iff known rr_parenthesis:
cmchar "Right relational image |)";
beginchar(rr_parenthesis,7u#,body_height#,paren_depth#);
italcorr math_axis#*slant-.5u#;
adjust_fit(0,0); pickup fine.nib;
pos1(vair,0); pos2(.75[hair,stem],0); pos3(vair,0);
lft x1l=lft x3l=hround u; rt x2r=hround(x1+4u);
top y1=h; y2=.5[y1,y3]=math_axis;
filldraw stroke z1e{3(x2e-x1e),y2-y1}...z2e
 ...{3(x3e-x2e),y3-y2}z3e;  % arc
pos4(whatever,-45); pos5(whatever,45);
rt x4r-lft x4l=rt x5r-lft x5l=rule_thickness;
z4l=z1l; z5l=z3l;
filldraw stroke z4e--z5e;
penlabels(1,2,3,4,5); endchar;

iff known bin_ampersand:
cmchar "Binary operator ampersand (for linear logic)";
beginarithchar(bin_ampersand); pickup rule.nib; autorounded;
rt x1=hround(w-u)+eps; y1=.5[y2,y5]=math_axis;
x2=.25[x3,x1]; y5-y2=x1-x3;
lft x3=hround u-eps; y3=.45[y2,y1];
x5=.5[x3,x1]; x6=x1; y6=y2+o;
z4=whatever[z2,z5]; z4=z6+whatever*dir 140;
draw z1..z2{left}..z3{up}..z4..tension .85..z5{left}..tension .75..z4---z6;
labels(1,2,3,4,5,6);
endchar;

iff known bin_dnasrepma:
cmchar "Binary operator dnasrepma (for linear logic)";
beginarithchar(bin_dnasrepma); pickup rule.nib; autorounded;
rt x1=hround(w-u)+eps; y1=.5[y2,y5]=math_axis;
x2=.25[x3,x1]; y5-y2=x1-x3;
lft x3=hround u-eps; y3=.45[y2,y1];
x5=.5[x3,x1]; x6=x1; y6=y2+o;
z4=whatever[z2,z5]; z4=z6+whatever*dir 140;
draw z1..z2{left}..z3{up}..z4..tension .85..z5{left}..tension .75..z4---z6;
currentpicture:= currentpicture scaled -1 shifted (w,h-d);
endchar;

iff known triangle_left_eq_slant:
cmchar "Triangular less than or (slanted) equal sign";
compute_spread(.45x_height#,.55x_height#);
spread#':=spread#; spread':=spread;
compute_spread(5/4x_height#,3/2x_height#);
beginchar(triangle_left_eq_slant,14u#,
   v_center(spread#'+spread#+rule_thickness#));
italcorr h#*slant-u#; adjust_fit(0,0); pickup rule.nib;
lft x2=hround 1.5u-eps; x1=x3=w-x2; y1-y3=spread;
y2=.5[y1,y3]; y3-y8=y2-y9=spread'; top y1=h;
x2=x9; x1=x8;
draw z1--z2--z3--cycle;  % diagonals
draw z8--z9; % equal sign
penlabels(1,2,3,8,9); endchar;

iff known triangle_right_eq_slant:
cmchar "Triangular greater than or (slanted) equal sign";
compute_spread(.45x_height#,.55x_height#);
spread#':=spread#; spread':=spread;
compute_spread(5/4x_height#,3/2x_height#);
beginchar(triangle_right_eq_slant,14u#,
   v_center(spread#'+spread#+rule_thickness#));
italcorr h#*slant-u#; adjust_fit(0,0); pickup rule.nib;
rt x2=hround(w-1.5u)+eps; x1=x3=w-x2; y1-y3=spread;
x2=x9; x1=x8;
y2=.5[y1,y3]; y3-y8=y2-y9=spread'; top y1=h;
draw z1--z2--z3--cycle;  % diagonals
draw z8--z9;
penlabels(1,2,3,8,9); endchar;

iff known n_triangle_left_eq_slant:
cmchar "Not triangular less than or (slanted) equal sign";
compute_spread(.45x_height#,.55x_height#);
spread#':=spread#; spread':=spread;
compute_spread(5/4x_height#,3/2x_height#);
beginchar(n_triangle_left_eq_slant,14u#,
   v_center(spread#'+spread#+rule_thickness#+6u#));
italcorr h#*slant-u#; adjust_fit(0,0); pickup rule.nib;
lft x2=hround 1.5u-eps; x1=x3=w-x2; y1-y3=spread;
y2=.5[y1,y3]; y3-y8=y2-y9=spread'; top y1=h-3u;
x2=x9; x1=x8;
draw z1--z2--z3--cycle;  % diagonals
draw z8--z9; % equal sign
char_center(c); x.t=w-3u; y.t=y1+3u;
char_negate(c,t,b);
penlabels(1,2,3,8,9); endchar;

iff known n_triangle_right_eq_slant:
cmchar "Not triangular greater than or (slanted) equal sign";
compute_spread(.45x_height#,.55x_height#);
spread#':=spread#; spread':=spread;
compute_spread(5/4x_height#,3/2x_height#);
beginchar(n_triangle_right_eq_slant,14u#,
   v_center(spread#'+spread#+rule_thickness#+6u#));
italcorr h#*slant-u#; adjust_fit(0,0); pickup rule.nib;
rt x2=hround(w-1.5u)+eps; x1=x3=w-x2; y1-y3=spread;
x2=x9; x1=x8;
y2=.5[y1,y3]; y3-y8=y2-y9=spread'; top y1=h-3u;
draw z1--z2--z3--cycle;  % diagonals
draw z8--z9;
char_center(c); x.t=w-3u; y.t=y1+3u;
char_negate(c,t,b);
penlabels(1,2,3,8,9); endchar;

iff known ll_floor:
cmchar "Left merge or left double-floor";
beginchar(ll_floor,10u#,body_height#,paren_depth#);
adjust_fit(0,0); pickup rule.nib;
compute_spread(.45x_height#,.55x_height#);
x1=x2; top y1=h; .5[y1,y2]=math_axis;
x4=x3; rt x5=rt x6=w; y5=y3=y1; y6=y4=y2;
x3-x1=x5-x3=hround spread;
draw z1--z2; draw z3--z4; % stems
draw z2--z6; % horizontal
labels(1,2,3,4,5,6); endchar;

iff known rr_floor:
cmchar "Right merge or right double-floor";
beginchar(rr_floor,10u#,body_height#,paren_depth#);
adjust_fit(0,0); pickup rule.nib;
compute_spread(.45x_height#,.55x_height#);
x5=x6; top y1=h; .5[y1,y2]=math_axis;
x4=x3; lft x1=lft x2=0; y5=y3=y1; y6=y4=y2;
x3-x1=x5-x3=hround spread;
draw z3--z4; draw z5--z6;  % stems
draw z2--z6; % horizontal
labels(1,2,3,4,5,6); endchar;

iff known ll_ceil:
cmchar "Left double-ceiling";
beginchar(ll_ceil,10u#,body_height#,paren_depth#);
adjust_fit(0,0); pickup rule.nib;
compute_spread(.45x_height#,.55x_height#);
x1=x2; bot y1=-d; .5[y1,y2]=math_axis;
x4=x3; rt x5=rt x6=w; y5=y3=y1; y6=y4=y2;
x3-x1=x5-x3=hround spread;
draw z1--z2; draw z3--z4; % stems
draw z2--z6; % horizontal
labels(1,2,3,4,5,6); endchar;

iff known rr_ceil:
cmchar "Right double-ceiling";
beginchar(rr_ceil,10u#,body_height#,paren_depth#);
adjust_fit(0,0); pickup rule.nib;
compute_spread(.45x_height#,.55x_height#);
x5=x6; bot y1=-d; .5[y1,y2]=math_axis;
x4=x3; lft x1=lft x2=0; y5=y3=y1; y6=y4=y2;
x3-x1=x5-x3=hround spread;
draw z3--z4; draw z5--z6;  % stems
draw z2--z6; % horizontal
labels(1,2,3,4,5,6); endchar;

iff known arrow_not:
cmchar "Negated nonexistant arrow";
compute_spread(.45x_height#,.55x_height#);
beginchar(arrow_not,18u#,v_center(spread#+rule_thickness#));
adjust_fit(0,0); pickup crisp.nib;
y3=.24asc_height+eps+math_axis;
char_center(100); top y101=top y3; x101=x100+2u;
char_negate(100,101,102);
zero_width; endchar;

iff known Arrow_not:
cmchar "Negated nonexistant double arrow";
compute_spread(.45x_height#,.55x_height#);
beginchar(Arrow_not,18u#,v_center(spread#+rule_thickness#));
adjust_fit(0,0); pickup rule.nib;
y1-y2=spread; .5[y1,y2]=math_axis;
y3=.24asc_height+eps+y1;
char_center(100); top y101=top y3; x101=x100+1.5u; char_negate(100,101,102);
zero_width; endchar;

iff known Maps_to_char:
cmchar "Maps-To relation";
compute_spread(.45x_height#,.55x_height#);
beginchar(Maps_to_char,14u#,v_center(spread#+rule_thickness#));
% this character should be followed immediately by equals or Rightarrow
adjust_fit(0,0); pickup rule.nib;
lft x1=hround u; x6=x2=x1+.5u; x3=x4=x5=x1;
.5[y1,y5]=.5[y2,y6]=math_axis; y5-y3=y4-y1=.24asc_height+eps;
y1-y5=y2-y6=spread;
draw z3--z4;  % stem
draw z1--z2;  % top bar stub
draw z5--z6;  % bottom bar stub
labels(1,2,3,4,5,6); zero_width; endchar;

iff known maps_from_char:
cmchar "Maps-from relation";
compute_spread(.45x_height#,.55x_height#);
beginchar(maps_from_char,14u#,v_center(spread#+rule_thickness#));
% this character should be preceded immediately by minus or leftarrow
adjust_fit(0,0); pickup rule.nib;
lft x1=hround u; x2=x1+.5u; x3=x4=x1;
y1=y2=math_axis; y1-y3=y4-y1=.24asc_height+eps;
draw z3--z4;  % stem
draw z1--z2;  % bar stub
zero_width;
currentpicture:= currentpicture xscaled -1;
endchar;

iff known Maps_from_char:
cmchar "Maps-From relation";
compute_spread(.45x_height#,.55x_height#);
beginchar(Maps_from_char,14u#,v_center(spread#+rule_thickness#));
% this character should be preceded immediately by equals or Rightarrow
adjust_fit(0,0); pickup rule.nib;
lft x1=hround u; x6=x2=x1+.5u; x3=x4=x5=x1;
.5[y1,y5]=.5[y2,y6]=math_axis; y5-y3=y4-y1=.24asc_height+eps;
y1-y5=y2-y6=spread;
draw z3--z4;  % stem
draw z1--z2;  % top bar stub
draw z5--z6;  % bottom bar stub
zero_width;
currentpicture:= currentpicture xscaled -1;
endchar;

iff known left_right_arrow_triangle:
cmchar "Left-right arrow with triangular heads";
beginchar(left_right_arrow_triangle,18u#,4u#+math_axis#,4u#-math_axis#);
adjust_fit(0,0); pickup rule.nib;
z1=z2 + whatever*(dir -150); y4=y1=math_axis;
lft x1=hround u-eps; x4=x3=x2;
top y2=h-u; bot y3=-d+u;
z5=z6 + whatever*(dir 150); y8=y5=math_axis;
rt x5=hround(w-u)+eps; x8=x7=x6;
top y6=h-u; bot y7=-d+u;
draw z1--z2--z3--cycle; % left head
draw z5--z6--z7--cycle; % right head
draw z4--z8; % stem
labels(1,2,3,4,5); endchar;

iff known left_arrow_triangle:
cmchar "Left arrow with triangular head";
beginchar(left_arrow_triangle,18u#,4u#+math_axis#,4u#-math_axis#);
adjust_fit(0,0); pickup rule.nib;
rt x1=w-u; y1 = math_axis;
z2=z3 + whatever*(dir -150); y5=y2=y1;
lft x2=u; x5=x4=x3;
top y3=h-u; bot y4=-d+u;
draw z1--z5; draw z2--z3--z4--cycle;
labels(1,2,3,4,5); endchar;

iff known right_arrow_triangle:
cmchar "Right arrow with triangular head";
beginchar(right_arrow_triangle,18u#,4u#+math_axis#,4u#-math_axis#);
adjust_fit(0,0); pickup rule.nib;
lft x1=u; y1 = math_axis;
z2=z3 + whatever*(dir 150); y5=y2=y1;
rt x2=w-u; x5=x4=x3;
top y3=h-u; bot y4=-d+u;
draw z1--z5; draw z2--z3--z4--cycle;
labels(1,2,3,4,5); endchar;

iff known big_triangle_down:
cmchar "\textstyle triangular join";
beginchar(big_triangle_down,15u#,0,10/6dh#);
adjust_fit(0,0); pickup pencircle scaled stem;
lft x1=hround u-eps; x3=w-x3; x5=w-x1;
top y1=eps; bot y3=-d; y5=y1;
draw z1--z3--z5--cycle;  % diagonals
labels(1,3,5); endchar;

iff known big_triangle_up:
cmchar "\textstyle triangular meet";
beginchar(big_triangle_up,15u#,0,10/6dh#);
adjust_fit(0,0); pickup pencircle scaled stem;
lft x1=hround u-eps; x3=w-x3; x5=w-x1;
top y3=0; bot y1=-d-eps; y5=y1;
draw z1--z3--z5--cycle;  % diagonals
labels(1,3,5); endchar;

iff known big_curly_vee:
cmchar "\textstyle big curly vee";
beginchar(big_curly_vee,15u#,0,10/6dh#);
adjust_fit(0,0); pickup pencircle scaled stem;
lft x1=hround u-eps; x3=w-x3; x5=w-x1;
top y1=eps; bot y3=-d; y5=y1;
draw z1{dir -30}..{down}z3{up}..{dir 30}z5;  % diagonals
labels(1,3,5); endchar;

iff known big_curly_wedge:
cmchar "\textstyle big curly wedge";
beginchar(big_curly_wedge,15u#,0,10/6dh#);
adjust_fit(0,0); pickup pencircle scaled stem;
lft x1=hround u-eps; x3=w-x3; x5=w-x1;
top y3=0; bot y1=-d-eps; y5=y1;
draw z1{dir 30}..{up}z3{down}..{dir -30}z5;  % diagonals
labels(1,3,5); endchar;

iff known big_sq_cap:
cmchar "\textstyle square set intersection sign";
beginchar(big_sq_cap,15u#,0,10/6dh#);
adjust_fit(0,0); pickup pencircle scaled stem;
lft x1=hround u; x2=x1; x4=x5=w-x1;
top y1=eps; bot y2=-d; y4=y2; y5=y1;
draw z2---z1---z5---z4;  % stems and bar
labels(1,2,4,5); endchar;

iff known big_box:
cmchar "\textstyle box sign";
beginchar(big_box,15u#,0,10/6dh#);
adjust_fit(0,0); pickup pencircle scaled stem;
lft x1=hround u; x2=x1; x4=x5=w-x1;
top y1=eps; bot y2=-d; y4=y2; y5=y1;
draw z1---z2---z4---z5---cycle;  % stems and bar
labels(1,2,4,5); endchar;

iff known big_parallel:
cmchar "\textstyle big parallelism sign";
beginchar(big_parallel,8u#,0,10/6dh#);
adjust_fit(0,0); pickup pencircle scaled stem;
lft x1=hround u; x2=x1; x4=x5=w-x1;
top y1=eps; bot y2=-d; y4=y2; y5=y1;
draw z1---z2;  % left line
draw z4---z5;  % right line
labels(1,2,4,5); endchar;

iff known big_interleave:
cmchar "\textstyle big interleaving sign";
beginchar(big_interleave,9u#,0,10/6dh#);
adjust_fit(u#,u#); pickup pencircle scaled stem;
lft x1=hround 0; x2=x1;
top y1=eps; bot y2=-d;
x4=x5=x1+2hround(.5w);
y4=y1;y5=y2;
x6=x7=x1+hround(.5w);
y6=y1;y7=y2;
draw z1---z2;  % left line
draw z4---z5;  % right line
draw z6---z7;  % middle line
labels(1,2,4,5,6,7); endchar;

iff known big_triangle_down:
cmchar "\displaystyle triangular join";
beginchar(big_triangle_down+8,20u#,0,14/6dh#); padded 1/6dh#;
adjust_fit(0,0); pickup pencircle scaled curve;
lft x1=hround u-eps; x3=w-x3; x5=w-x1;
top y1=eps; bot y3=-d; y5=y1;
draw z1--z3--z5--cycle;  % diagonals
labels(1,3,5); endchar;

iff known big_triangle_up:
cmchar "\displaystyle triangular meet";
beginchar(big_triangle_up+8,20u#,0,14/6dh#); padded 1/6dh#;
adjust_fit(0,0); pickup pencircle scaled curve;
lft x1=hround u-eps; x3=w-x3; x5=w-x1;
top y3=0; bot y1=-d-eps; y5=y1;
draw z1--z3--z5--cycle;  % diagonals
labels(1,3,5); endchar;

iff known big_curly_vee:
cmchar "\displaystyle big curly vee";
beginchar(big_curly_vee+8,20u#,0,14/6dh#); padded 1/6dh#;
adjust_fit(0,0); pickup pencircle scaled curve;
lft x1=hround u-eps; x3=w-x3; x5=w-x1;
top y1=eps; bot y3=-d; y5=y1;
draw z1{dir -30}..{down}z3{up}..{dir 30}z5;  % diagonals
labels(1,3,5); endchar;

iff known big_curly_wedge:
cmchar "\displaystyle big curly wedge";
beginchar(big_curly_wedge+8,20u#,0,14/6dh#); padded 1/6dh#;
adjust_fit(0,0); pickup pencircle scaled curve;
lft x1=hround u-eps; x3=w-x3; x5=w-x1;
top y3=0; bot y1=-d-eps; y5=y1;
draw z1{dir 30}..{up}z3{down}..{dir -30}z5;  % diagonals
labels(1,3,5); endchar;

iff known big_sq_cap:
cmchar "\displaystyle square set union sign";
beginchar(big_sq_cap+8,20u#,0,14/6dh#); padded 1/6dh#;
adjust_fit(0,0); pickup pencircle scaled curve;
lft x1=hround u; x2=x1; x4=x5=w-x1;
top y1=eps; bot y2=-d; y4=y2; y5=y1;
draw z2---z1---z5---z4;  % stems and bar
labels(1,2,4,5); endchar;

iff known big_box:
cmchar "\displaystyle box sign";
beginchar(big_box+8,20u#,0,14/6dh#); padded 1/6dh#;
adjust_fit(0,0); pickup pencircle scaled curve;
lft x1=hround u; x2=x1; x4=x5=w-x1;
top y1=eps; bot y2=-d; y4=y2; y5=y1;
draw z1---z2---z4---z5---cycle;  % stems and bar
labels(1,2,4,5); endchar;

iff known big_parallel:
cmchar "\displaystyle big parallelism sign";
beginchar(big_parallel+8,10u#,0,14/6dh#); padded 1/6dh#;
adjust_fit(0,0); pickup pencircle scaled curve;
lft x1=hround u; x2=x1; x4=x5=w-x1;
top y1=eps; bot y2=-d; y4=y2; y5=y1;
draw z1---z2;  % left line
draw z4---z5;  % right line
labels(1,2,4,5); endchar;

iff known big_interleave:
cmchar "\displaystyle big interleaving sign";
beginchar(big_interleave+8,13u#,0,14/6dh#); padded 1/6dh#;
adjust_fit(u#,u#); pickup pencircle scaled curve;
lft x1=hround 0; x2=x1;
top y1=eps; bot y2=-d;
x4=x5=x1+2hround(.5w);
y4=y1;y5=y2;
x6=x7=x1+hround(.5w);
y6=y1;y7=y2;
draw z1---z2;  % left line
draw z4---z5;  % right line
draw z6---z7;  % middle line
labels(1,2,4,5,6,7); endchar;

iff known big_n_plus:
cmchar "\textstyle multiset intersection sign";
beginchar(big_n_plus,15u#,0,10/6dh#);
adjust_fit(0,0); pickup pencircle scaled stem;
lft x1=hround u; x2=x1; x3=w-x3; x4=x5=w-x1;
top y3=0; bot y1=-d-eps; y2=y4=2/3[y1,y3]; y5=y1;
draw z1---z2...z3...z4---z5;  % stems and cap
y8=y9=.47[y1,y3]; x8=w-x9=x1+2stem+eps; x6=x7=x3;
.5[y6,y7]=y8; y7-y6=x9-x8; draw z8--z9; draw z6--z7;  % enclosed `$+$'
labels(1,2,3,4,5,6,7,8,9); endchar;

iff known big_ll_bracket:
cmchar "\big left semantic bracket";
beginchar(big_ll_bracket,8u#,rule_thickness#,2dh#-rule_thickness#);
adjust_fit(1.5u#,0); left_semantic_bracket(rule_thickness,true,true); endchar;

iff known big_ll_bracket:
cmchar "\Big left semantic bracket";
beginchar(big_ll_bracket+1,8.5u#,rule_thickness#,3dh#-rule_thickness#);
adjust_fit(2u#,0); left_semantic_bracket(.25[rule_thickness,stem],true,true); endchar;

iff known big_ll_bracket:
cmchar "\bigg left semantic bracket";
beginchar(big_ll_bracket+2,9u#,rule_thickness#,4dh#-rule_thickness#);
adjust_fit(2.5u#,0); left_semantic_bracket(.5[rule_thickness,stem],true,true); endchar;

iff known big_ll_bracket:
cmchar "\Bigg left semantic bracket";
beginchar(big_ll_bracket+3,9.5u#,rule_thickness#,5dh#-rule_thickness#);
adjust_fit(3u#,0); left_semantic_bracket(.75[rule_thickness,stem],true,true); endchar;

iff known big_ll_bracket:
cmchar "Extensible left semantic bracket---top";
beginchar(big_ll_bracket+4,10u#,rule_thickness#,3dh#-rule_thickness#);
adjust_fit(4u#,0); pickup crisp.nib;
pos1(stem,0); pos2(stem,0);
top y1=h-1; y2=-d-eps; lft x1l=lft x2l=hround(2.5u-.5stem);
filldraw stroke z1e--z2e;  % stem1
pos3(stem,90); pos4(stem,90);
x3=x1l; rt x4=hround(w-.75u+.5stem); y3r=y4r=y1;
filldraw stroke z3e--z4e;  % upper bar
pos7(stem,0); pos8(stem,0);
y7=y1; y8=y2; x7=x8=0.5(x1+x4);
filldraw stroke z7e--z8e;  % stem2
penlabels(1,2,3,4,7,8); endchar;

iff known big_ll_bracket:
cmchar "Extensible left semantic bracket---bottom";
beginchar(big_ll_bracket+5,10u#,rule_thickness#,3dh#-rule_thickness#);
adjust_fit(4u#,0); pickup crisp.nib;
pos1(stem,0); pos2(stem,0);
y1=h+eps; bot y2=1-d; lft x1l=lft x2l=hround(2.5u-.5stem);
filldraw stroke z1e--z2e;  % stem1
pos5(stem,90); pos6(stem,90);
x5=x1l; rt x6=hround(w-.75u+.5stem); y5l=y6l=y2;
filldraw stroke z5e--z6e;  % lower bar
pos7(stem,0); pos8(stem,0);
y7=y1; y8=y2; x7=x8=0.5(x1+x6);
filldraw stroke z7e--z8e;  % stem2
penlabels(1,2,5,6); endchar;

iff known big_ll_bracket:
cmchar "Extensible left semantic bracket---extension module";
beginchar(big_ll_bracket+6,10u#,0,dh#);
adjust_fit(4u#,0); pickup crisp.nib;
pos1(stem,0); pos2(stem,0);
y1=h+1+eps; bot y2=-d-1-eps; lft x1l=lft x2l=hround(2.5u-.5stem);
filldraw stroke z1e--z2e;  % stem1
rt x6=hround(w-.75u+.5stem);
pos7(stem,0); pos8(stem,0);
y7=y1; y8=y2; x7=x8=0.5(x1+x6);
filldraw stroke z7e--z8e;  % stem2
penlabels(1,2,7,8); endchar;

iff known big_n_plus:
cmchar "\displaystyle multiset intersection sign";
beginchar(big_n_plus+8,20u#,0,14/6dh#); padded 1/6dh#;
adjust_fit(0,0); pickup pencircle scaled curve;
lft x1=hround u; x2=x1; x3=w-x3; x4=x5=w-x1;
top y3=0; bot y1=-d-eps; y2=y4=2/3[y1,y3]; y5=y1;
draw z1---z2...z3...z4---z5;  % stems and cap
y8=y9=.47[y1,y3]; x8=w-x9=x1+2curve+eps; x6=x7=x3;
.5[y6,y7]=y8; y7-y6=x9-x8; draw z8--z9; draw z6--z7;  % enclosed `$+$'
labels(1,2,3,4,5,6,7,8,9); endchar;

iff known big_rr_bracket:
cmchar "\big right semantic bracket";
beginchar(big_rr_bracket,8u#,rule_thickness#,2dh#-rule_thickness#);
adjust_fit(0,1.5u#); right_semantic_bracket(rule_thickness,true,true); endchar;

iff known big_rr_bracket:
cmchar "\Big right semantic bracket";
beginchar(big_rr_bracket+1,8.5u#,rule_thickness#,3dh#-rule_thickness#);
adjust_fit(0,2u#); right_semantic_bracket(.25[rule_thickness,stem],true,true); endchar;

iff known big_rr_bracket:
cmchar "\bigg right semantic bracket";
beginchar(big_rr_bracket+2,9u#,rule_thickness#,4dh#-rule_thickness#);
adjust_fit(0,2.5u#); right_semantic_bracket(.5[rule_thickness,stem],true,true); endchar;

iff known big_rr_bracket:
cmchar "\Bigg right semantic bracket";
beginchar(big_rr_bracket+3,9.5u#,rule_thickness#,5dh#-rule_thickness#);
adjust_fit(0,3u#); right_semantic_bracket(.75[rule_thickness,stem],true,true); endchar;

iff known big_rr_bracket:
cmchar "Extensible right semantic bracket---top";
beginchar(big_rr_bracket+4,10u#,rule_thickness#,3dh#-rule_thickness#);
adjust_fit(0,4u#); pickup crisp.nib;
pos1(stem,0); pos2(stem,0);
top y1=h-1; y2=-d-eps; rt x1r=rt x2r=hround(w-2.5u+.5stem);
filldraw stroke z1e--z2e;  % stem1
pos3(stem,90); pos4(stem,90);
x3=x1r; lft x4=hround(.75u-.5stem); y3r=y4r=y1;
filldraw stroke z3e--z4e;  % upper bar
pos7(stem,0); pos8(stem,0);
y7=y1; y8=y2; x7=x8=0.5(x1+x4);
filldraw stroke z7e--z8e;  % stem2
penlabels(1,2,3,4,7,8); endchar;

iff known big_rr_bracket:
cmchar "Extensible right semantic bracket---bottom";
beginchar(big_rr_bracket+5,10u#,rule_thickness#,3dh#-rule_thickness#);
adjust_fit(0,4u#); pickup crisp.nib;
pos1(stem,0); pos2(stem,0);
y1=h+eps; bot y2=1-d; rt x1r=rt x2r=hround(w-2.5u+.5stem);
filldraw stroke z1e--z2e;  % stem1
pos5(stem,90); pos6(stem,90);
x5=x1r; lft x6=hround(.75u-.5stem); y5l=y6l=y2;
filldraw stroke z5e--z6e;  % lower bar
pos7(stem,0); pos8(stem,0);
y7=y1; y8=y2; x7=x8=0.5(x1+x6);
filldraw stroke z7e--z8e;  % stem2
penlabels(1,2,5,6,7,8); endchar;

iff known big_rr_bracket:
cmchar "Extensible right semantic bracket---extension module";
beginchar(big_rr_bracket+6,10u#,0,dh#);
adjust_fit(0,4u#); pickup crisp.nib;
pos1(stem,0); pos2(stem,0);
y1=h+1+eps; bot y2=-d-1-eps; rt x1r=rt x2r=hround(w-2.5u+.5stem);
filldraw stroke z1e--z2e;  % stem1
lft x6=hround(.75u-.5stem);
pos7(stem,0); pos8(stem,0);
y7=y1; y8=y2; x7=x8=0.5(x1+x6);
filldraw stroke z7e--z8e;  % stem2
penlabels(1,2,7,8); endchar;
