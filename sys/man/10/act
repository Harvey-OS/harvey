.TH ACT 10.1
.SH NAME
act, adil \- minterm to actel/simulator
.SH SYNOPSIS
.B cda/act
[
.I flag
\&... ]
.I file
.br
.B cda/adil
.I file
.br
.I simprog
[
.B -d
[
.I id
\&... ] ] [
.B -i
[
.I id value
] ...] [
.B -g
] [
.B -n
.I iter
] [
.B -p
[
.I id period
] ...] [
.B -s
] [
.B -t
[
.I id value
] ...] [
.B -v
.I var value
] ...]
.SH DESCRIPTION
.PP
.I Act
takes a
.I file
in
.IR minterm (10.6)
format and produces a variety of output forms, selected by
.I flag .
If no
.I flag
is given,
.I act
constructs a balanced and factored tree of the circuit in the input
.I file
and covers it with gate patterns from the Actel FPGA
gate library, printing the result in human readable form.
.PP
The basic Actel primitive is a two-level multiplexer, so
.I act
by default tries to express logic trees in terms of multiplexers
prior to template matching.  The
.B -m
flag reduces the zeal of this
process.
.PP
The other
.I flags
select the output format.  They are described in more detail
below; here is a summary:
.TP
.B -a
print in Actel-like format suitable for
.IR adil .
.TP
.B -c
generate a C program for simulation.
.TP
.B -d
debug; just print the resulting tree.
.TP
.BI -f n
set maximum fanout to
.I n
(default 10)
.TP
.B -u
unique; find common subexpressions
.TP
.B -v
verbose; include pin names in output
.PP
The
.B -u
flag causes
.I act
to output gate counts and usage (if default output
is selected) or indicating fanout (for debug output).
.I Act
adds buffers when a signal or gate fanout exceeds the maximum
specified by
.BR -f .
.PP
.I Adil
takes output from
.B "act -a"
and produces Actel ADL format that can be fed to the
proprietary Unix-resident Actel placing and routing software.
.PP
The C program generated by
.B "act -c"
can be compiled and loaded with loader options
.BR "-lsim -lg -lstdio" .
The resulting executable
is a simulator that displays signal traces in an
.IR 8Â½ (1)
window and takes the following arguments:
.TP
.B -d
display the values of the named
.I ids.
Each
.I id
may be an identifier or an element of an
.I lde
array, in the form
.IB id [ n ]
where
.I n
is an integer.
.TP
.B -i
set the initial value of the named
.I ids
to the corresponding
.I values.
.TP
.B -g
suppress graphics; give textual output only
.TP
.B -n
set number of iterations for the simulation
.TP
.B -p
set half period of the named
.I ids
to the corresponding
.IR periods,
forcing the
.I ids
to be clock signals.
.TP
.B -s
suppress screen graphics; output
.IR pic (1)
input.
.TP
.B -t
specify the trigger values for the named
.I ids.
.TP
.B -v
draw a guide edge when
.I id
attains
.I value.
.PP
Given the number of details involved in running a simulation,
simulators are typically invoked from
.IR mk (1).
If the
.B -p
flag is not given, the simulator takes forcing input from
standard input.
The format for this input is identical to that of the output, so it is
possible to run simulators in a pipeline.
.PP
Beware when catenating multiple
.I minterm
files to form input to
.IR act ;
the scope of external symbols in the input files is lost,
so there can be name conflicts.
On the other hand, this approach makes it easy
to add an external environment to a simulation.
.SH FILES
.TF /$objtype/lib/libsim.a
.TP
.B /$objtype/lib/libsim.a
simulator driver
.SH SEE ALSO
.IR lde (10.1)
.SH BUGS
.I Adil
should be subsumed in
.I act
.br
.I Act
doesn't check the fanout of buffers it adds.
