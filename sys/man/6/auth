.TH AUTH 6
.EQ
delim $$
define lbr ' roman "{" '
define rbr ' roman "}" '
.EN
.SH NAME
ticket \- authentication service
.SH DESCRIPTION
This manual page describes
the protocols used to authorize connections, confirm the identities
of users and machines, and maintain the associated databases.
The machine that provides these services is called the
.I authentication server
(AS).
The AS may be a stand-alone machine or a general-use machine such as a CPU server.
The network database
.IR ndb (6)
holds for each public machine, such as a CPU server or
file server, the name of the authentication server that machine uses.
.PP
Each machine contains three values important to authentication; a 56-bit DES
key, a 28-byte authentication ID, and a 48-byte authentication domain name.
The ID is a user name and identifies who is currently responsible for the
kernel running on that machine.
The domain name identifies the machines across which the ID is valid.
Together, the ID and domain name identify the owner of a key.
.PP
When a terminal boots, the user is prompted for user name and password.
The user name becomes the terminal's authentication ID. 
The password is converted using
.I passtokey
(see
.IR auth (2))
into a 56-bit DES key and saved as the machine's key.
The authentication domain is set to the null string.
If possible, the terminal validates the key with the AS
before saving it.
For Internet machines the correct AS to ask is found using
.IR bootp (8).
For Datakit machines the AS is a system called
.I p9auth
on the same Datakit node as the file server the terminal booted from.
.PP
When a CPU or file server boots, it reads the key, ID, and domain name from
non-volatile RAM.
This allows servers to reboot without operator intervention.
.PP
The details of any authentication are mixed with the semantics
of the particular service they are authenticating so we describe
them one case at a time.  The following definitions will be used
in the descriptions:
.TF nullx
.TP
.I $CH sub c$
an 8-byte random challenge from a client
.TP
.I $CH sub s$
an 8-byte random challenge from a server
.TP
.I $K sub s$
server's key
.TP
.I $K sub c$
client's key
.TP
.I $K sub n$
a nonce key created for a ticket
.TP
.I $K lbr m rbr$
message $m$
encrypted with key $K$
.TP
.I $ID sub s$
server's ID
.TP
.I $DN sub s$
server's authentication domain name
.TP
.I $ID sub c$
client's ID
.TP
.I $UID sub c$
user's name on the client
.TP
.I $UID sub s$
user's name on the server
.PD
.PP
A number of constants defined in
.B auth.h
are also used:
.IR AuthTreq ,
.IR AuthChal ,
.IR AuthOK ,
.IR AuthErr ,
.IR AuthTs ,
.IR AuthTc ,
.IR AuthAs ,
and
.IR AuthAc .
.SS "File Service"
File service sessions are long-lived connections between a client host
and a file server.
Processes belonging to different users share the session.
Whenever a user process on the client
.I mounts
a file server
(see
.IR bind (2)),
it must authenticate itself.
There are four players in an authentication: the server, the client kernel,
the user process on the client, and the authentication server.
The goal of the authentication protocol is to convince the server
that the client may validly speak for the user process.
.PP
To reduce the number of messages for each authentication,
common information is exchanged once at the
beginning of the session within a
.I session
message
(see
.IR attach (5)):
.TF "Client→Server"
.TP
.IR Client → Server
Tsession($CH sub c$)
.TP
.IR Server → Client
Rsession(${CH sub s},~{ID sub s},~{DN sub s}$)
.PD
.PP
Each time a user mounts a file server connection, an attach
message is sent identifying/authenticating the user:
.TF "Client→Server"
.TP
.IR Client → Server
Tattach($K sub s lbr AuthTs, ~ {CH sub s},~{UID sub c}, ~ {UID sub s}, ~ K sub n rbr , ~ {K sub n} lbr AuthAc, ~ {CH sub s}, count rbr )$
.TP
.IR Server → Client
Rattach($ K sub n lbr AuthAs,~{CH sub c},~count rbr$)
.PD
.PP
The part of the attach request encrypted with
.BR $K sub s$
is called a
.IR ticket .
Since it is encrypted in the server's secret key, this message is guaranteed
to have originated on the AS.
The part encrypted with the
.B $K sub n$
found in the ticket is called an
.IR authenticator .
The authenticator is generated by the client kernel and guarantees that
the ticket was not stolen.
The
.I count
is incremented with each mount to make every authenticator unique,
thus foiling replay attacks.
The server is itself authenticated by the authenticator
it sends as a reply to the attach.
.PP
Tickets are created by the AS at the request of a user process.
The AS contains a database of which $ID sub c$'s may speak for which $UID sub c$'s.
If the $ID sub c$ may speak for the $UID sub c$, two tickets are returned.
.TF "UserProc→AS"
.TP
.IR UserProc → AS
$AuthTreq, ~ CH sub s , ~ ID sub s , ~ DN sub s , ~ ID sub c , ~ UID sub c$
.TP
.IR AS → UserProc
$AuthOK, ~ K sub c  lbr AuthTc, ~  CH sub s , ~  UID sub c , ~  UID sub s , ~  K sub n  rbr , ~  K sub s  lbr AuthTs, ~  CH sub s , ~  UID sub c , ~  UID sub s , ~  K sub n  rbr$
.PD
.PP
Otherwise an error message is returned.
.TF "UserProc→AS"
.TP
.IR AS → UserProc
$AuthErr$, 64-byte error string
.PD
.PP
The user passes both tickets to the client's kernel using
the
.I fauth
system call
(see
.IR fsession (2)).
The kernel decrypts the ticket encrypted with $K sub c$.
If $UID sub c$
matches the user's login ID, the tickets are remembered for
any subsequent attaches by that user of that file server session.
Otherwise, the ticket is assumed stolen and an error is returned.
.SS "Remote Execution"
.PP
A number of applications require a process on one machine to start
a process with the same user ID on a server machine.
Examples are
.IR cpu (1),
.I rx
(see
.IR con (1)),
and
.IR exportfs (4).
The called process replies to the connection with a ticket request.
.TF "Server→UserProc"
.TP
.IR Server → UserProc
$AuthTreq, ~  CH sub s , ~  ID sub s , ~  DN sub s , ~  xxx, ~  xxx$
.PD
.PP
Here
.I xxx
indicates a field whose contents do not matter.
.PP
The calling process adds its machine's $ID sub c$ and its $UID sub c$ to the request
and follows the protocol outlined above to get two tickets from the AS.
The process passes the
$K sub s$
encrypted ticket plus an authenticator generated by
.B /dev/authenticator
from the 
$K sub c$
ticket to the remote server, which writes them to the
kernel to set the user ID (see 
.IR cons (3)).
The server replies with its own authenticator which can be written
to the kernel along with the
$K sub c$
encrypted ticket to confirm the server's identity (see
.IR cons (3)).
.TF "UserProc→Server"
.TP
.IR UserProc → Server
$ K sub s lbr AuthTs, ~  CH sub s , ~  UID sub c , ~  UID sub s , ~  K sub n  rbr , ~  K sub n lbr AuthAc, ~  CH sub s , ~  0 rbr $
.TP
.IR Server → UserProc
$K sub n lbr AuthAs, ~  CH sub s , ~  0 rbr$
.PD
.SS "Challenge Box"
A user may also start a process on a CPU server from a non Plan 9
machine using commands such as
.IR con ,
.IR telnet ,
or
.I ftp
(see
.IR con (1)
and
.IR ftpfs (4)).
In these situations, the user can authenticate using a hand-held
DES encryptor.
The telnet or FTP daemon first sends a ticket request to the
authentication server.
If the AS has keys for both the $ID sub c$ and $UID sub c$ in the ticket
request it returns a challenge as a hexadecimal number.
.TF "Daemon→AS"
.TP
.IR Daemon → AS
$AuthChal, ~  CH sub c , ~  ID sub c , ~  DN sub s , ~  ID sub c , ~  UID sub c $
.TP
.IR AS → Daemon
$AuthOK$, 16-byte
.SM ASCII
challenge
.PD
.PP
Otherwise, it returns a null-terminated 64-byte error string.
.TF "Daemon→AS"
.TP
.IR AS → Daemon
$AuthErr$, 64-byte error string
.PD
.PP
The daemon relays the challenge to the calling program,
which displays the challenge on the user's screen.
The user encrypts it and types in the
result, which is relayed back to the AS.
The AS checks it against the expected response and returns
either a ticket or an error.
.TF "Daemon→AS"
.TP
.IR Daemon → AS
16-byte ASCII response
.TP
.IR AS → Daemon
$AuthOK, ~  K sub c lbr AuthTs, ~  CH sub c , ~  UID sub c , ~  UID sub c , ~  K sub n  rbr$
.PD
.PP
or
.TF "Daemon→AS"
.TP
.IR AS → Daemon
$AuthErr$, 64-byte error string
.PD
.PP
Finally, the daemon passes the ticket to the kernel
to set the user ID (see
.IR cons (3)).
.SS "Password Change"
Any user can change the key stored for him or her on the AS.
Once again we start by passing a ticket request to the AS.
Only the user ID in the request is meaningful.
The AS replies with a single ticket (or an error message)
encrypted in the user's personal key.
The user encrypts both the old and new keys with the
$K sub n$ from the returned ticket and sends that back to the AS.
The AS checks the reply for validity and replies with an
AuthOK byte or an error message.
.TF "UserProc→AS"
.TP
.IR UserProc → AS
$AuthPass, ~  xxx, ~  xxx, ~  xxx, ~  xxx, ~  UID sub c$
.TP
.IR AS → UserProc
$AuthOK, ~  K sub c lbr AuthTc, ~  xxx, ~  xxx, ~  xxx, ~  K sub n  rbr$
.TP
.IR UserProc → AS
$K sub u lbr AuthPass, ~ roman "old password", ~ roman "new password" rbr$
.TP
.IR AS → UserProc
$AuthOK$
.PD
.PP
or
.TF "UserProc→AS"
.TP
.IR AS → UserProc
$AuthErr$, 64-byte error string
.PD
.PP
.SS "Data Base"
An
.IR ndb (2)
database file exists for the authentication server.
The attribute types used by the AS are
.B hostid
and
.BR uid .
The value in the
.B hostid
is a client host's ID.
The values in the
.B uid
pairs in the same entry list which users that host ID
make speak for.
A uid value of
.B *
means the host ID may speak for all users.
A uid value of
.BI ! user
means the host ID may not speak for
.IR user .
For example:
.EX
hostid=bootes
	uid=!sys uid=!adm uid=*
.EE
.PP
is interpreted as
.B bootes
may speak for any user except
.B sys
and
.BR adm .
.SH FILES
.TF /lib/ndb/auth.*xxx
.TP
.B /lib/ndb/auth
database file
.TP
.B /lib/ndb/auth.*
hash files for
.B /lib/ndb/auth
.SH SEE ALSO
.IR fsession (2),
.IR auth (2),
.IR cons (3),
.IR attach (5),
.IR auth (8)

