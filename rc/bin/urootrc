#!/bin/rc
# terminal startup

if(test -e '/boot/uroot') {
	# Unpack uroot cpio into the ramdisk and bind to root
	cd '#@'
	/boot/decompress /boot/uroot > uroot.cpio
	/boot/cpio i < uroot.cpio
	rm uroot.cpio
	cd
	bind -b '#@' /
	bind -b /bbin /bin
}

TIMESYNCARGS=(-rLa1000000)
NDBFILE=/lib/ndb/local

# Hack
terminal = "ninep"

mntgen -s slashn && chmod 666 /srv/slashn

# bind all likely devices (#S was bound in boot)
for(i in t m v C)
	/bin/bind -a '#'^$i /dev >/dev/null >[2=1]

# set up any partitions
diskparts

rm -f /env/disk

# we do this before we have a name.  we may need to do network
# setup so that we can get a name.
if(test -e /rc/bin/termrc.local)
	. /rc/bin/termrc.local

# cs sets sysname (termrc.local may already have started it so check)
if(! test -e /srv/cs && ! test -e /net/cs)
	ndb/cs -f $NDBFILE
sysname=`{cat /dev/sysname}
if (~ $#sysname 0 || ~ $sysname '') {
	sysname = harvey			# default
	echo -n $sysname >/dev/sysname
}

# machine specific startup (e.g., for devices not probed)
if(test -e /cfg/$sysname/termrc)
	. /cfg/$sysname/termrc

# start IP on the LAN, if not already configured.  diskless terminals
# are already configured by now.  It's commented out to avoid a long timeout
# on startup waiting for DHCP.
#
# If your site provides DHCP service,
#
#if(! test -e /net/ipifc/0/ctl)
#	ip/ipconfig
#
# Otherwise, see /cfg/$sysname/termrc (/cfg/example/termrc is an example).

# start dns if we have an internet
if(test -e /net/ipifc/0/ctl && ! test -e /srv/dns)
	ndb/dns -r

if(! ~ $terminal *vx32* && ! ~ $terminal *ninep*){
	# start timesync if it isn't running and we weren't told not to
	if(! ps|grep -s timesync)
		if(! ~ $TIMESYNCARGS '')
			aux/timesync $TIMESYNCARGS

	# add the loop-back medium
	if(! grep -s 127.0.0.1 /net/ipselftab)
		ip/ipconfig loopback /dev/null 127.1

	# set things up for vmware
	if(! ~ `{cat /dev/user} none)
		if(test -e /bin/aux/vmware)
			aux/vmware
}

# query user if terminal isn't adequately configured yet
if(~ $mouseport ask){
	echo -n 'mouseport is (ps2, ps2intellimouse, 0, 1, 2)[ps2]: '
	mouseport=`{read}
	if(~ $#mouseport 0)
		mouseport=ps2
}
if(~ $vgasize ask){
	echo -n 'vgasize [640x480x8]: '
	vgasize=`{read}
	if(~ $#vgasize 0)
		vgasize=640x480x8
}
if(~ $monitor ask){
	echo -n 'monitor is [xga]: '
	monitor=`{read}
	if(~ $#monitor 0)
		monitor=xga
}
if(test -f /dev/mousectl){
	switch($mouseport){
	case ps2 ps2intellimouse 0 1 2
		aux/mouse $mouseport
		ms& #soft mouse
		# parse vgasize into fields
		vgasize=`{echo $vgasize}
		if(! ~ $"monitor '' && ! ~ `{cat /dev/user} none)
			aux/realemu
			aux/vga -m $monitor -l $vgasize
		if(~ $accupoint 1)
			pipefile -dr /bin/aux/accupoint /dev/mouse
	}
}

dontkill '^(ipconfig|factotum|mntgen|fossil|cs|dns|listen|reboot)$'

# If we're running uroot, we're assuming everything's come from the ramdisk
# at this point.  There may be no usr profile, so let's put sensible defaults here.
# Can then run something in the $home/lib/profile if it exists
home=/usr/$user
cd

# This is what would traditionally be in lib/profile by default
bind -a $home/bin/rc /bin
bind -a $home/bin/$cputype /bin
bind -c tmp /tmp

font=/lib/font/bit/go/Go-Mono/Go-Mono.14.font
fn cd { builtin cd $* && awd }  # for acme
fn acme { /bin/acme -f $font $* }

plumber
echo -n accelerated > '#m/mousectl'
echo -n 'res 3' > '#m/mousectl'
prompt=('term% ' '	')
fn term%{ $* }
exec rio -s -i riostart
